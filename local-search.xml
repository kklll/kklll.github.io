<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL中的各种log以及他们的作用</title>
    <link href="/2022/07/01/mysql%E4%B8%AD%E7%9A%84log/"/>
    <url>/2022/07/01/mysql%E4%B8%AD%E7%9A%84log/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql中的Log"><a href="#mysql中的Log" class="headerlink" title="mysql中的Log"></a>mysql中的Log</h2><p>首先上一个Mysql的架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/181121105137362.png" alt="img"></p><h3 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h3><p>binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo&#x2F;undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以”事务”的形式保存在磁盘中；</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的</li><li>数据恢复：通过mysqlbinlog工具恢复数据，因为binlog中存储了数据库中所有的增删改查的信息，所以可以用来进行数据库的恢复。</li><li>增量备份</li></ul><p><strong>怎样开启</strong></p><p>一般来说开启binlog日志大概会有1%的性能损耗</p><p>在配置文件中加入 <code>log-bin</code> 配置，表示启用binlog，如果没有给定值，写成 <code>log-bin=</code>，则默认名称为主机名。（注：名称若带有小数点，则只取第一个小数点前的部分作为名称）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[mysqld]<br>log-bin=my-binlog-name<br></code></pre></td></tr></table></figure><h4 id="什么时候数据库写binlog"><a href="#什么时候数据库写binlog" class="headerlink" title="什么时候数据库写binlog"></a><strong>什么时候数据库写binlog</strong></h4><p>对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候<strong>刷新到磁盘</strong>跟参数 <code>sync_binlog</code> 相关。</p><ul><li>如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；</li><li>如果设置为不为0的值，则表示每 <code>sync_binlog</code> 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。</li><li>设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。</li></ul><p>如果 <code>sync_binlog=0</code> 或 <code>sync_binlog大于1</code>，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。</p><p>在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。</p><h4 id="Binlog-的日志格式"><a href="#Binlog-的日志格式" class="headerlink" title="Binlog 的日志格式"></a>Binlog 的日志格式</h4><p>记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：</p><ul><li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li><li>ROW：基于行的复制（row-based replication, RBR）</li><li>MIXED：混合模式复制（mixed-based replication, MBR）</li></ul><p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code>，在 <code>MySQL 5.7.7</code> 及更高版本中，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定，如 <code>binlog-format=STATEMENT</code>、<code>binlog-format=ROW</code>、<code>binlog-format=MIXED</code>。</p><h5 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h5><p>每一条会修改数据的sql都会记录在binlog中</p><p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p><p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。</p><h5 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h5><p>5.1.5版本的MySQL才开始支持 <code>row level</code> 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p><p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p><blockquote><p>注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。</p></blockquote><h5 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h5><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li></ul><h4 id="什么时候数据库写redo-log"><a href="#什么时候数据库写redo-log" class="headerlink" title="什么时候数据库写redo log"></a><strong>什么时候数据库写redo log</strong></h4><p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，他的关键点是先写日志，再写磁盘。事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p><p><strong>redo log日志的大小是固定的，即记录满了以后就从头循环写</strong></p><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有<code>crash-safe</code>能力的。</p><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>undo log也叫做<strong>回滚日志</strong>它保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p><p>undo日志用于存放数据修改被修改前的值，假设修改 table表中 id&#x3D;2的行数据，把Name&#x3D;’B’ 修改为Name &#x3D; ‘B2’ ，那么undo日志就会用来存放Name&#x3D;’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p><p>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型，一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。</p><h4 id="什么时候数据库写入undo-log"><a href="#什么时候数据库写入undo-log" class="headerlink" title="什么时候数据库写入undo log"></a>什么时候数据库写入undo log</h4><p>事务开始之前，将当前的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性。</p><p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><h3 id="什么是两段锁协议"><a href="#什么是两段锁协议" class="headerlink" title="什么是两段锁协议"></a>什么是两段锁协议</h3><p>两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。</p><ul><li><p>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</p></li><li><p>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</p></li></ul><p>两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁。</p><p><strong>两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁</strong></p><ol><li><p>在对任何数据进行读、写操作之前，要申请并获得对该数据的封锁。</p></li><li><p>每个事务中，所有的封锁请求先于所有的解锁请求。</p></li></ol><h4 id="两段锁和避免死锁有什么异同点"><a href="#两段锁和避免死锁有什么异同点" class="headerlink" title="两段锁和避免死锁有什么异同点"></a>两段锁和避免死锁有什么异同点</h4><p>两段锁协议和防止死锁的一次封锁法的异同之处在于一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此<strong>一次封锁法遵守两段锁协议</strong>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此<strong>遵守两段锁协议的事务可能发生死锁</strong></p><p><strong>若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写时复制</title>
    <link href="/2022/07/01/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/07/01/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="写时复制技术"><a href="#写时复制技术" class="headerlink" title="写时复制技术"></a>写时复制技术</h2><h3 id="什么是写时复制技术"><a href="#什么是写时复制技术" class="headerlink" title="什么是写时复制技术"></a>什么是写时复制技术</h3><p> 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><h4 id="什么是exec系统调用"><a href="#什么是exec系统调用" class="headerlink" title="什么是exec系统调用"></a>什么是exec系统调用</h4><hr><blockquote><p>The  exec()  family  of  functions  replaces  the  current process image with a new process image. </p></blockquote><p>exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p><p>我们都知道一个进程的主要组成包括以下几个部分：</p><ol><li>程序（可执行的数据）</li><li>数据（变量，内存中的值，缓冲区的）</li><li>PCB（进程控制块）</li></ol><p>exec系统调用做的就是把进程进行替换，但是不会替换进程的PID等信息，会替换掉<code>数据段</code>、<code>堆栈段</code>和<code>代码段</code>等其他的信息,也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。</p><p>exec是一个函数簇，由6个函数组成，分别是以excl和execv打头的。具体如下:</p><p>execl(const char* filepath,const char* arg1,char*arg2……)</p><p>execlp(const char<em>filename,const char</em>arg1,const char*arg2….. )</p><p>execle(const char<em>filepath,const char</em>arg1,const char<em>arg2,…..,char</em> cons envp[])</p><p>execv  (const char* filepath,char* argv[])</p><p>execvp (const char* filename,char* argv[])</p><p>execve (const char* filepath,char<em>argv[],char</em> const envp[])</p><p>我们都知道system系统调用也有执行新程序的功能，那么exec系统调用和system系统调用有什么区别呢？</p><ol><li>exec是直接用新的进程去代替原来的程序运行，运行完毕之后不回到原先的程序中去</li><li>system是调用shell执行你的命令，system&#x3D;fork+exec+waitpid,执行完毕之后，回到原先的程序中去。继续执行下面的部分</li></ol><p><strong>通俗一点来时如果你用system系统调用的话，那么操作系统会给你创建一个进程，然后执行你要执行的代码，但是你用exec的话就要使用fork去新建一个新的进程，然后在新的进程里面调用exec去执行你的代码</strong></p><hr><p>理解了上面的exec系统调用的话我们就理解了上面说的写时复制（COW）是上面意思了。</p><p>我们可以联想一下，如果我通过fork新开了一个进程，按照我们传统的想法，当然是要把父进程的所有代码段，数据段堆栈段复制给子进程一份，但是很多情况下我们其实新开了一个线程都是大部分还是去做一些exec的系统调用，这时候就如果没有写时复制，就会出现性能问题，你刚开了一个新的进程，我辛辛苦苦的给你把数据，代码段给你搞好了，结果你上来第一句就是exec系统调用，把我辛辛苦苦搞好的代码段和数据段的信息给我作废，去重新加载新的代码段和堆栈段，这样效率肯定是不好的，也就是因为有这样的问题，我们就推出了写时复制的技术。</p><p>写时复制技术，它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制，这意味着如果任何一个进程写入共享页面，那么就创建共享页面的副本。这样我们就不必给每个子进程都创建相同的内存区域，节省了内存资源和系统运行效率。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2-1Q10Q45045312.gif" alt="进程1修改页面C前后"></p><p>假设子进程试图修改包含部分堆栈的页面，并且设置为写时复制。操作系统会创建这个页面的副本，将其映射到子进程的地址空间。然后，子进程会修改复制的页面，而不是属于父进程的页面。显然，当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的处理SpringBoot Web中的异常</title>
    <link href="/2022/07/01/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/01/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="如何优雅的处理SpringBoot-Web中的异常"><a href="#如何优雅的处理SpringBoot-Web中的异常" class="headerlink" title="如何优雅的处理SpringBoot Web中的异常"></a><center>如何优雅的处理SpringBoot Web中的异常</center></h2><p>大家在开发Web项目中的时候总是会遇到一些让人很麻烦的参数校验和一些固定的返回格式，如果我们在每个方法中都加入这些代码就很麻烦，大大降低我们的开发效率。今天我们就看一下如何进行优雅的异常抛出，来做个记录吧。</p><p>首先定义一个异常的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BasicException</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">getResultCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误描述</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">getResultMsg</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们定义一些常见的基础的枚举异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CommonEnum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BasicException</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基础的一些错误定义。</span><br><span class="hljs-comment">     */</span><br>    SUCCESS(<span class="hljs-string">&quot;200&quot;</span>, <span class="hljs-string">&quot;成功!&quot;</span>),<br>    BODY_NOT_MATCH(<span class="hljs-string">&quot;400&quot;</span>, <span class="hljs-string">&quot;请求的数据格式不符!&quot;</span>),<br>    SIGNATURE_NOT_MATCH(<span class="hljs-string">&quot;401&quot;</span>, <span class="hljs-string">&quot;请求的数字签名不匹配!&quot;</span>),<br>    NOT_FOUND(<span class="hljs-string">&quot;404&quot;</span>, <span class="hljs-string">&quot;未找到该资源!&quot;</span>),<br>    INTERNAL_SERVER_ERROR(<span class="hljs-string">&quot;500&quot;</span>, <span class="hljs-string">&quot;服务器内部错误!&quot;</span>),<br>    SERVER_BUSY(<span class="hljs-string">&quot;503&quot;</span>, <span class="hljs-string">&quot;服务器正忙，请稍后再试!&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> String resultCode;<br>    <span class="hljs-keyword">private</span> String resultMsg;<br><br>    CommonEnum(String resultCode, String resultMsg) &#123;<br>        <span class="hljs-built_in">this</span>.resultCode = resultCode;<br>        <span class="hljs-built_in">this</span>.resultMsg = resultMsg;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResultCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> resultCode;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResultMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> resultMsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来一个自定义异常的包装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BasicException</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String errorCode;<br>    <span class="hljs-keyword">private</span> String errorMsg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(BasicException exception)</span> &#123;<br>        <span class="hljs-built_in">super</span>(exception.getResultCode());<br>        <span class="hljs-built_in">this</span>.errorCode = exception.getResultCode();<br>        <span class="hljs-built_in">this</span>.errorMsg = exception.getResultMsg();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String errorMsg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String errorCode, String errorMsg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String errorCode, String errorMsg, Throwable cause)</span> &#123;<br>        <span class="hljs-built_in">super</span>(cause);<br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getErrorCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> errorCode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setErrorCode</span><span class="hljs-params">(String errorCode)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getErrorMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> errorMsg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setErrorMsg</span><span class="hljs-params">(String errorMsg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.errorMsg = errorMsg;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResultCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.errorCode;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResultMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.errorMsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再进行一下异常的全局捕获抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 捕捉自定义异常，减少代码量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exception</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(CustomException.class)</span><br>    <span class="hljs-keyword">public</span> ResultBody <span class="hljs-title function_">handleCustomException</span><span class="hljs-params">(HttpServletRequest request, CustomException exception)</span> &#123;<br>        log.error(<span class="hljs-string">&quot;发生异常&quot;</span>);<br>        <span class="hljs-keyword">return</span> ResultBody.error(exception.getErrorCode(), exception.getMessage());<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = NullPointerException.class)</span><br>    <span class="hljs-keyword">public</span> ResultBody <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(HttpServletRequest req, NullPointerException e)</span> &#123;<br>        log.error(<span class="hljs-string">&quot;发生空指针异常！原因是:&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> ResultBody.error(CommonEnum.BODY_NOT_MATCH);<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(ConstraintViolationException.class)</span><br>    <span class="hljs-keyword">public</span> ResultBody <span class="hljs-title function_">constraintViolationExceptionHandle</span><span class="hljs-params">(HttpServletRequest req, ConstraintViolationException e)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> e.getMessage();<br>        String[] messages = message.split(<span class="hljs-string">&quot;: &quot;</span>);<br>        <span class="hljs-keyword">return</span> ResultBody.error(messages[messages.length - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201111230227278.png" alt="image-20201111230227278"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201111230302968.png" alt="image-20201111230302968"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201111230506476.png" alt="image-20201111230506476"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201111230816506.png" alt="image-20201111230816506"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法复习</title>
    <link href="/2022/07/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/07/01/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="回溯算法复习"><a href="#回溯算法复习" class="headerlink" title="回溯算法复习"></a>回溯算法复习</h2><blockquote><p>题目来源：力扣</p></blockquote><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p></blockquote><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,6,7]</span>, target = 7,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h4><p>因为题目中每个数字可以重复使用多次，那么我们就可以画出如下的图，利用回溯算法进行选择，开始写代码。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/39_fig1.png"></p><p>排序后进行剪枝更加的高效，首先上图中，因为每个数字都要被重复的使用，那么例如[1,3,9,5,2]中，我们如果不进行排序，那么只有在</p><h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(candidates.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-comment">//排序后进行剪枝更加的高效</span><br>        Arrays.sort(candidates);<br>        dfs(candidates,<span class="hljs-number">0</span>,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;(),result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result)</span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//为什么从begin开始？，因为我们的数组是无重复的，那么数组如果已经进行到了第i个元素，</span><br>        <span class="hljs-comment">//那么0到（i-1）中的每个结果都被包括在结集中，所以不用进行重复的考虑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(target-candidates[i]&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            path.addLast(candidates[i]);<br>            dfs(candidates,i,target-candidates[i],path,result);<br>            path.removeLast();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p></blockquote><p><strong>说明</strong>：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 2, 5]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2, 6]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 1, 6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii">https://leetcode-cn.com/problems/combination-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="解题思想-1"><a href="#解题思想-1" class="headerlink" title="解题思想"></a>解题思想</h4><p>此题与上题组合总和不同点在于，本题目中的数组中的元素只能使用一次，那么我们就要考虑如何去重重复：先对数组 升序 排序，重复的元素一定不是排好序以后相同的连续数组区域的第 1 个元素。也就是说，剪枝发生在：同一层数值相同的结点第 2、3 … 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果。那么我们就可以使用语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.length;i++)&#123;<br><span class="hljs-keyword">if</span>(candidates[i]==candidates[i-<span class="hljs-number">1</span>])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">//do somethng！</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>进行剪枝</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(candidates.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        Arrays.sort(candidates);<br>        dfs(candidates,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;(),result,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result,<span class="hljs-type">int</span> begin)</span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(target-candidates[i]&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//解释一下这句话，i&gt;begin保证了两个相同的数不会出现在同一层级</span><br>            <span class="hljs-comment">//candidates[i]==candidates[i-1]保证了同一层不会出现重复元素的</span><br>            <span class="hljs-keyword">if</span>(i&gt;begin&amp;&amp;candidates[i]==candidates[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.addLast(candidates[i]);<br>            dfs(candidates,target-candidates[i],path,result,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>找出所有相加之和为 <em><strong>n</strong></em> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p></blockquote><p><strong>说明：</strong></p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">9</span><br>输出: <span class="hljs-string">[[1,2,6], [1,3,5], [2,3,4]]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iii">https://leetcode-cn.com/problems/combination-sum-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="解题思想-2"><a href="#解题思想-2" class="headerlink" title="解题思想"></a>解题思想</h4><p>思想和上面一样，不再赘述了。</p><h4 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        dfs(k,n,result,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n,List&lt;List&lt;Integer&gt;&gt; result,<span class="hljs-type">int</span> begin,Deque&lt;Integer&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size()==k&amp;&amp;n==<span class="hljs-number">0</span>)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(path.size()&gt;k||n&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n-i&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            path.add(i);<br>            dfs(k,n-i,result,i+<span class="hljs-number">1</span>,path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p></blockquote><p>示例:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><br><span class="hljs-comment">]</span><br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/permutations<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="解题思想-3"><a href="#解题思想-3" class="headerlink" title="解题思想"></a>解题思想</h4><p>回溯法，和上面一样，思路的话，组成和途中一样的树，不过判断条件不同，是将</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/39_fig1.png"></p><h4 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        dfs(nums,result,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length]);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; result,Deque&lt;Integer&gt; path,<span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size()==nums.length)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i]=<span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            dfs(nums,result,path,used);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p></blockquote><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,1,2]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations-ii">https://leetcode-cn.com/problems/permutations-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="解题思想-4"><a href="#解题思想-4" class="headerlink" title="解题思想"></a>解题思想</h4><p>思路和组合中的二一样，只不过是判断条件略有不同，且其中判断重复的语句略有不同。</p><h4 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        ArrayDeque&lt;Integer&gt; deque=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        Arrays.sort(nums);<br>        dfs(nums,deque,<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length],result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,Deque&lt;Integer&gt; path,<span class="hljs-type">boolean</span>[] used,List&lt;List&lt;Integer&gt;&gt; result)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size()==nums.length)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//剪枝的过程中去重。</span><br>            <span class="hljs-comment">//i&gt;0&amp;&amp;nums[i-1]==nums[i]防止同一层出现重复，但是同一路径下的重复是被允许的。</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i-<span class="hljs-number">1</span>]==nums[i]&amp;&amp;!used[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i]=<span class="hljs-literal">true</span>;<br>            path.addLast(nums[i]);<br>            dfs(nums,path,used,result);<br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[]</span></span><br><span class="hljs-comment">]</span><br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/subsets<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="解题思想-5"><a href="#解题思想-5" class="headerlink" title="解题思想"></a>解题思想</h4><p>这道题同样也是用了回溯算法，和上面的组合一样，我们可以将其拆分成从<code>0到length-1</code>长度的数组求其组合，最后得到的答案就是本题的答案。</p><h4 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=nums.length;i++)&#123;<br>            dfs(nums,i,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(),result,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[]nums,<span class="hljs-type">int</span> count,ArrayList&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result,<span class="hljs-type">int</span> begin)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == count)&#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(path.size() &gt; count)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.length;i++)&#123;<br>            path.add(nums[i]);<br>            dfs(nums,count,path,result,i+<span class="hljs-number">1</span>);<br>            path.remove((<span class="hljs-type">int</span>)path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集模版</title>
    <link href="/2022/07/01/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/07/01/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="版本一：加权快速合并"><a href="#版本一：加权快速合并" class="headerlink" title="版本一：加权快速合并"></a>版本一：加权快速合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] father;<br><span class="hljs-type">int</span>[] sz;<br><span class="hljs-type">int</span> num;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p != father[p]) &#123;<br>        p = find(father[p]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> find(q);<br>    <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">return</span>;<br>    num -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sz[i] &lt; sz[j]) &#123;<br>        father[i] = j;<br>        sz[j] += sz[i];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        father[j] = i;<br>        sz[i] += sz[j];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initUF</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    sz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    num = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        father[i] = i;<br>        sz[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="版本二：路径压缩的加权快速合并"><a href="#版本二：路径压缩的加权快速合并" class="headerlink" title="版本二：路径压缩的加权快速合并"></a>版本二：路径压缩的加权快速合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] father;<br><span class="hljs-type">int</span>[] sz;<br><span class="hljs-type">int</span> num;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p != father[p]) &#123;<br>        father[p] = find(father[p]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> father[p];<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> find(q);<br>    <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">return</span>;<br>    num -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sz[i] &lt; sz[j]) &#123;<br>        father[i] = j;<br>        sz[j] += sz[i];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        father[j] = i;<br>        sz[i] += sz[j];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initUF</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    sz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    num = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        father[i] = i;<br>        sz[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己的并查集模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] father;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] depth;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>            num=n;<br>            father=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            depth=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                father[i]=i;<br>                depth[i]=<span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>            <span class="hljs-type">int</span> rootX=find(i);<br>            <span class="hljs-type">int</span> rootY=find(j);<br>            <span class="hljs-keyword">if</span>(rootX==rootY)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(depth[rootX]&gt;depth[rootY])&#123;<br>                father[rootY]=rootX;<br>                depth[rootX]+=depth[rootY];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                father[rootX]=rootY;<br>                depth[rootY]+=depth[rootX];<br>            &#125;<br>            num--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>            <span class="hljs-keyword">if</span>(father[i]!=i)&#123;<br>                father[i]=find(father[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> father[i];<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序代码复习</title>
    <link href="/2022/07/01/%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/01/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>复习一下各个排序的代码，加深理解。</p><p>首先看一下各个排序算法的时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/image-20200915204407956.png" alt="image-20200915204407956" style="zoom:50%;" /><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><blockquote><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length - <span class="hljs-number">1</span> -i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度:</p><p>平均：$O(n^2)$最好 :$O(n)$最坏:$O(n^2)$稳定性：<code>稳定</code></p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><blockquote><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> temp= nums[minIndex];<br>        nums[minIndex]=nums[i];<br>        nums[i]=temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>平均：$O(n^2)$最好 :$O(n^2)$最坏:$O(n^2)$稳定性：<code>不稳定</code></p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> preIndex, now;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        preIndex = i - <span class="hljs-number">1</span>;<br>        now = nums[i];<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[preIndex] &gt; now) &#123;<br>            nums[preIndex + <span class="hljs-number">1</span>] = nums[preIndex];<br>            preIndex--;<br>        &#125;<br>        nums[preIndex+<span class="hljs-number">1</span>] = now;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>平均：$O(n^2)$最好 :$O(n)$最坏:$O(n^2)$稳定性：<code>稳定</code></p><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><blockquote><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p></blockquote><p>算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">//先分组，组数每次变为原来的1/2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> step; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//从增量那组进行插入排序，直到完毕</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>            <span class="hljs-keyword">while</span> (j-step&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[j-step]&gt;temp)&#123;<br>                nums[j]= nums[j-step];<br>                j=j-step;<br>            &#125;<br>            nums[j]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><blockquote><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    quickSortSub(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSortSub</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">benchmark</span> <span class="hljs-operator">=</span> nums[i];<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; benchmark &lt;= nums[j]) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; benchmark &gt;= nums[i]) &#123;<br>            i++;<br>        &#125;<br>        temp = nums[j];<br>        nums[j] = nums[i];<br>        nums[i] = temp;<br>    &#125;<br>    nums[start]= nums[i];<br>    nums[i]=benchmark;<br>    quickSortSub(nums,start,i-<span class="hljs-number">1</span>);<br>    quickSortSub(nums,i+<span class="hljs-number">1</span>,end);<br>&#125;<br></code></pre></td></tr></table></figure><p>平均：$O(nlog_2n)$最好 :$O(nlog_2n)$最坏:$O(n^2)$稳定性：<code>不稳定</code></p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, temp);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        sort(nums, <span class="hljs-number">0</span>, mid, temp);<br>        sort(nums, mid + <span class="hljs-number">1</span>, right, temp);<br>        merge(nums, left, mid, right, temp);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] temp)</span> &#123;<br>    <span class="hljs-comment">//左序列指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;<br>    <span class="hljs-comment">//右序列指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//temp指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            temp[t++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp[t++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        temp[t++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br>        temp[t++] = nums[j++];<br>    &#125;<br>    t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        nums[left++] = temp[t++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>平均：$O(nlog_2n)$最好 :$O(nlog_2n)$最坏:$O(nlog_2n)$稳定性：<code>稳定</code></p><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><blockquote><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span><br>        adjustHeap(nums, i, nums.length);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span><br>        swap(nums, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//重新调整</span><br>        adjustHeap(nums, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    <span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; len; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span><br>        <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[k] &lt; nums[k + <span class="hljs-number">1</span>]) &#123;<br>            k++;<br>        &#125;<br>        <span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br>        <span class="hljs-keyword">if</span> (nums[k] &gt; temp) &#123;<br>            nums[i] = nums[k];<br>            i = k;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    nums[i]=temp;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>平均：$O(nlog_2n)$最好 :$O(nlog_2n)$最坏:$O(nlog_2n)$稳定性：<code>不稳定</code></p><p>本文就是笔者关于排序算法的一次记录，以便加深理解，如果需要详细了解具体的排序算法，请参考其他博主对这些排序算法的讲解，如果有好的建议，希望大家指出！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统面试题</title>
    <link href="/2022/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h6 id="1-进程和线程以及他们的区别与联系？"><a href="#1-进程和线程以及他们的区别与联系？" class="headerlink" title="1.进程和线程以及他们的区别与联系？"></a>1.进程和线程以及他们的区别与联系？</h6><p>  进程是程序在某个数据集合上的一次执行过程，是系统资源调度和分配的最小单位。<br>  线程是进程的实体，是cpu调度和分派的最小单位，线程自己基本上不拥有系统资源，只拥有一些必要资源，但是他可以与同属于一个进程的线程共享所有的资源。<br>  一个进程可以拥有很多个线程，但是一个线程只能属于一个进程，一个线程还可以创建多个子进程，同时多个线程可以并发执行。线程执行开销小，但是不利于资源的管理和保护，而进程则正好相反。</p><h6 id="2-分段和分页以及他们的区别是什么？"><a href="#2-分段和分页以及他们的区别是什么？" class="headerlink" title="2.分段和分页以及他们的区别是什么？"></a>2.分段和分页以及他们的区别是什么？</h6><p>  页是信息的物理单位，是为了实现信息的离散分配方式，提高内存的利用率，分页仅仅是由于系统的需要而非用户的需要。页的大小是固定的，把逻辑地址分为页号和页内地址，但是用户只用提供一个逻辑地址就能标识对应的地址，所以分页作业地址空间是一维的。<br>  段是信息的逻辑单位，它包含了一组意义相对完整的信息，长度可变，由用户决定，程序员标识一个地址时，要给出段号还有段内偏移量，所以分段的作业地址空间是二维的。</p><h6 id="3-进程通信方式？"><a href="#3-进程通信方式？" class="headerlink" title="3.进程通信方式？"></a>3.进程通信方式？</h6><p>  1）匿名管道：通常称为管道，管道是IPC最基本的一种实现机制，在Linux下一切皆文件，其实这里的管道就是一个文件。管道实现进程的通信就是让两个进程都能访问这个文件。管道的特点只提供单向通信，虽然两个进程都能访问这个文件，但是一个在写的时候另一个只能读。同时只能用于具有血缘关系的进程之间通信，常用于父子进程通信。<br>  2）FIFO命名管道：管道虽然实现了进程通信，但是也存在一定局限性，故提出了命名管道。其特点是提供了一个路径名与之关联，以FIFO文件的形式存储在文件系统中，它不局限于父子进程，而能够实现任意两个进程之间的通信。同时遵循先进先出的原则，即第一个写进的数据会第一个被读走。<br>  3）消息队列：存放在内核中，在内核中创建一块内存存放消息，生命周期随内核，消息队列会一直存在。同时可以双向通信，不一定按照先进先出的方式取消息，也可以按照类型取消息。<br>  4）信号量：类似于一个计数器，可以控制多个进程对共享资源的访问，需要限制在同一时刻最大访问资源的进程数。<br>  5）共享内存：顾名思义，映射一段与其他进程共享的内存空间，当一个进程写完后另一个进程读就实现了进程通信，同时要注意写的过程不能读，这就需要配合信号量机制使用。共享内存区是IPC形式中最快的，因为进程不通过执行任何进入内核的系统调用就可以进行通信。</p><h6 id="4-线程同步方式？"><a href="#4-线程同步方式？" class="headerlink" title="4.线程同步方式？"></a>4.线程同步方式？</h6><p>  临界区：访问临界资源的代码段，在任意时刻只允许一个线程对临界资源进行访问，如果有多个线程试图访问临界资源，那么在有一个线程进入后，其他试图访问临界资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。<br>  互斥量：采用互斥对象机制，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。<br>  信号量：同进程同步方式。</p><h6 id="5-什么是线程安全？"><a href="#5-什么是线程安全？" class="headerlink" title="5.什么是线程安全？"></a>5.什么是线程安全？</h6><p>  指某个函数、函数库在并发环境中被调用时，能后正确地处理多个线程之间的共享变量，是程序能够正确的完成。</p><h6 id="6-什么是死锁？"><a href="#6-什么是死锁？" class="headerlink" title="6.什么是死锁？"></a>6.什么是死锁？</h6><p>  在两个或多个并发进程中，如果每个进程持有各自的资源而又都等待其余进程释放正在持有的资源，在没有外力的情况下谁都无法推进，相互等待的一种状态，称为死锁。</p><h6 id="7-死锁产生的原因以及避免方法？"><a href="#7-死锁产生的原因以及避免方法？" class="headerlink" title="7.死锁产生的原因以及避免方法？"></a>7.死锁产生的原因以及避免方法？</h6><p>  死锁产生的原因1）系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。2）进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。<br>  死锁产生的必要条件：1）互斥条件：一个资源每次只能被一个进程使用。2）请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，但是请求的资源又正在被其他进程所占有。3）不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走。4）循环等待条件：若干进程键形成首尾相连循环等待资源的关系。<br>  死锁避免方法：系统对进程发出的资源申请进行动态检查，若分配后可能发生死锁，那么不与分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。</p><h6 id="8-操作系统的fork-过程？"><a href="#8-操作系统的fork-过程？" class="headerlink" title="8.操作系统的fork()过程？"></a>8.操作系统的fork()过程？</h6><p>  父进程调用fork()函数后，系统给子进程分配资源时，fork并不直接复制父进程的内存空间，而是与父进程共享一个写时复制的内存空间。Fork()返回时会返回两次，分别返回到父进程和子进程。</p><h6 id="9-说说Cpu调度算法？"><a href="#9-说说Cpu调度算法？" class="headerlink" title="9.说说Cpu调度算法？"></a>9.说说Cpu调度算法？</h6><p>  1）先来先服务算法：按照进程就绪的先后顺序使用处理器。<br>  2）短作业优先算法：具有最短完成时间的进程优先使用处理器。<br>  3）最高响应比优先算法：首先计算响应比，选择最高响应比的进程使用处理器（响应比&#x3D;（等待时间+处理时间）&#x2F;处理时间）。<br>  4）时间片轮转调度算法：每个进程分配一个时间片，如果在时间片内没有执行完毕则剥夺处理器并分配给其他进程。<br>  5）最高优先级调度算法：选择优先级最高的进程优先执行。优先级可以静态不变，也可以动态调整。<br>  6）多级反馈队列调度算法：根据先来先服务原则给就绪队列排序，为就绪队列赋予不同的优先级数，不同的时间片，按照优先级抢占CPU的调度算法。</p><h6 id="10-用户态和内核态是什么？进程什么时候由用户态转化为内核态？"><a href="#10-用户态和内核态是什么？进程什么时候由用户态转化为内核态？" class="headerlink" title="10.用户态和内核态是什么？进程什么时候由用户态转化为内核态？"></a>10.用户态和内核态是什么？进程什么时候由用户态转化为内核态？</h6><p>  Linux进程地址空间分为用户空间和内核空间，内核空间可以执行比用户空间更高权限的动作。应用程序如果运行在用户空间，就叫用户态；如果运行在内核空间，就叫内核态。<br>  系统调用：用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的程序服务完成工作，总是返回接着执行下一条指令。<br>  异常：当CPU在执行运行在用户态的程序时，出现了某些异常，这时会出发异常处理程序，由用户态切换到内核态中，可能会返回到用户态接着执行出现异常的指令，也可能直接终止而不返回。<br>  中断：当外围设备准备完成之后，会向用户发送相应的中断信号，这时用户在执行完当前指令后注意到中断引脚的电压变高了，就从系统总线读取异常信号，然后调用适当的中断处理程序。如果先执行的指令是在用户态下那么自然就发生了用户态到内核态的切换。</p><h6 id="11-互斥量与信号量的区别？"><a href="#11-互斥量与信号量的区别？" class="headerlink" title="11.互斥量与信号量的区别？"></a>11.互斥量与信号量的区别？</h6><p>  互斥量用于线程的互斥，信号量用于线程的同步。<br>  互斥量只能为0&#x2F;1，信号量可以为非负值。<br>  互斥量只能由一个线程加锁或者解锁，信号量可以由一个线程释放，另一个线程得到。</p><h6 id="12-进程切换会发生什么"><a href="#12-进程切换会发生什么" class="headerlink" title="12.进程切换会发生什么?"></a>12.进程切换会发生什么?</h6><p>  1)正在运行的用户态进程X<br>  2)发生中断<br>  3)保存现场<br>  4)进程上下文切换<br>  5)开始运行用户态进程Y(这里Y曾经通过以上步骤被切换出去过因此可以继续执行）<br>  6)恢复现场<br>  7)继续运行用户态进程Y</p><h6 id="13-linux线程同步的方法？"><a href="#13-linux线程同步的方法？" class="headerlink" title="13.linux线程同步的方法？"></a>13.linux线程同步的方法？</h6><p>  互斥锁（或称互斥量Mutex)，读写锁(rdlock)，条件变量(cond)，信号量(Semophore)等。</p><h6 id="14-互斥锁、读写锁和自旋锁的区别和使用场景？"><a href="#14-互斥锁、读写锁和自旋锁的区别和使用场景？" class="headerlink" title="14.互斥锁、读写锁和自旋锁的区别和使用场景？"></a>14.互斥锁、读写锁和自旋锁的区别和使用场景？</h6><p>  互斥锁:保护了一个临界区，在这个临界区中，一次最多只能进入一个线程。<br>  读写锁:从广义的逻辑上讲，也可以认为是一种共享版的互斥锁。可以多个线程同时进行读,但是写操作必须单独进行,不可多写和边读边写。如果对一个临界区大部分是读操作而只有少量的写操作，读写锁在一定程度上能够降低线程互斥产生的代价。<br>  自旋锁:当要获取一把自旋锁的时候又被别的线程持有时,不断循环的去检索是否可以获得自旋锁,一直占CPU资源，直到获取到锁才会退出循环。 </p><h6 id="15-怎么解决死锁？"><a href="#15-怎么解决死锁？" class="headerlink" title="15.怎么解决死锁？"></a>15.怎么解决死锁？</h6><p>  发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程。</p><h6 id="16-多进程和多线程那个更可靠？"><a href="#16-多进程和多线程那个更可靠？" class="headerlink" title="16.多进程和多线程那个更可靠？"></a>16.多进程和多线程那个更可靠？</h6><p>  多进程相比而言更可靠，因为多进程的进程之间不会互相影响，然而多线程一个线程崩溃会导致进程出错使得进程中所有线程都出错。</p><h6 id="17-僵尸进程是什么，孤儿进程是什么？"><a href="#17-僵尸进程是什么，孤儿进程是什么？" class="headerlink" title="17.僵尸进程是什么，孤儿进程是什么？"></a>17.僵尸进程是什么，孤儿进程是什么？</h6><p>  子进程先于父进程结束，而父进程又没有调用wait或者waitpid获取其退出信息。子进程还需要在其PCB中保存其退出的相关信息，所以，子进程的执行主体已经结束，但是操作系统并没有释放该进程PCB结构，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程为僵尸进程。<br>  父进程结束或者异常终止，但是子进程继续运行。此时子进程的PPID被设置为1，即init进程。init进程接管了该子进程，并等待它结束，在父进程退出之后，子进程退出之前，该子进程属于孤儿进程</p><h6 id="18-进程上下文切换的过程？"><a href="#18-进程上下文切换的过程？" class="headerlink" title="18.进程上下文切换的过程？"></a>18.进程上下文切换的过程？</h6><p>  (1接收到切换信号，挂起进程，记录当前进程的虚拟内存、栈等资源存储;<br>  (2将这个进程在 CPU 中的上下文状态存储于起来;<br>  (3然后在内存中检索下一个进程的上下文;<br>  (4并将其加载到 CPU的寄存器中恢复;<br>  (5还需要刷新进程的虚拟内存和用户栈;<br>  (6最后跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p><h6 id="19-什么时候会发生进程调度？"><a href="#19-什么时候会发生进程调度？" class="headerlink" title="19.什么时候会发生进程调度？"></a>19.什么时候会发生进程调度？</h6><p>  1)进程时间片耗尽；<br>  2)系统资源不足（如内存不足）；<br>  3)进程通过睡眠函数 sleep 把自己挂起来；<br>  4)当有优先级更高的进程运行时，为了去运行高优先级进程，当前进程会被挂起；<br>  5)发生硬中断，CPU 上的进程会被挂起，然后去执行内核中的中断服务进程。</p><h6 id="20-进程切换与线程切换的区别？"><a href="#20-进程切换与线程切换的区别？" class="headerlink" title="20.进程切换与线程切换的区别？"></a>20.进程切换与线程切换的区别？</h6><p>  线程和进程的最大区别就在于地址空间，线程共享进程的地址空间，所以不会进行新的页表的切换。</p><h6 id="21-线程有什么是共享的什么是私有的？"><a href="#21-线程有什么是共享的什么是私有的？" class="headerlink" title="21.线程有什么是共享的什么是私有的？"></a>21.线程有什么是共享的什么是私有的？</h6><p>  线程共享的包括进程代码段、进程的公有数据、进程打开的文件描述符、信号的处理器、进程当前目录、进程用户ID与进程组ID。<br>  线程私有的有线程ID、寄存器组的值、线程的堆栈、错误返回码、线程的信号屏蔽码。</p><h6 id="22-堆和栈分配的速度，为什么？"><a href="#22-堆和栈分配的速度，为什么？" class="headerlink" title="22.堆和栈分配的速度，为什么？"></a>22.堆和栈分配的速度，为什么？</h6><p>  栈更快，因为栈中的数据生存周期固定，定位数据快速，而堆是动态随机分配的内存空间。</p><h6 id="23-为什么要用虚拟内存"><a href="#23-为什么要用虚拟内存" class="headerlink" title="23.为什么要用虚拟内存?"></a>23.为什么要用虚拟内存?</h6><p>  隔离进程地址空间、提高内存利用率、程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径的求法</title>
    <link href="/2022/07/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/07/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="最短路径的求法"><a href="#最短路径的求法" class="headerlink" title="最短路径的求法"></a>最短路径的求法</h2><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a><a href="https://link.zhihu.com/?target=https://wangjingxin.top/2018/01/18/zuiduanlu/%23floyd">Floyd算法</a></h3><p>初始化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    n = <span class="hljs-number">5</span>;<br>    a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            a[i][j] = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        a[i][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>    a[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">30</span>;<br>    a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">30</span>;<br>    a[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">100</span>;<br>    a[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>    a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">50</span>;<br>    a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">50</span>;<br>    a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">20</span>;<br>    a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">20</span>;<br>    a[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">10</span>;<br>    a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">60</span>;<br>    a[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">60</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                a[i][j] = Math.min(a[i][j], a[i][k] + a[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + j + <span class="hljs-string">&quot;:&quot;</span> + a[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个算法很好理解（如果理解了的话），首先我们创建一个邻接矩阵，这个时候我们就知道了初始状态下x[i][j]之间的长度，我们在进行遍历节点的时候，A[i][j]标识的就是从i到j节点的最短路径，这个时候还是初始化的值，然后我们可以让节点从i到j的时候再通过K这个节点，这个时候最短路径就变成了从i-&gt;k的长度加上k-&gt;j的长度之后和已经求得的最短路径得最小值，重复这个过程直到经过所有得K节点，这个时候求得得路径就是最短路径。</p><h3 id="迪杰斯特拉最短路径算法（Dijkstra’s）"><a href="#迪杰斯特拉最短路径算法（Dijkstra’s）" class="headerlink" title="迪杰斯特拉最短路径算法（Dijkstra’s）"></a>迪杰斯特拉最短路径算法（Dijkstra’s）</h3><p>dijkstra算法基于贪心，贪心算法中最重要的一部分就是贪心策略，贪心算法对不对，就是贪心策略的正确不正确，在这个算法中，贪心策略就是，去寻找点i，满足min(d[i]) i∈B，满足这个条件的点i，必定是无法被继续松弛的点，如果说要松弛点i，那么必定通过A中或者B中的点进行更新，若通过B中的点j进行更新那么松弛之后的路径为d[j] + a[j][i] 由于d[i]已经是最小了，因此d[j]+a[j][i]&gt;d[i] 因此不可能是通过B中的点进行松弛，若通过A中的点m进行松弛，由于m是点集A中的点，因此点m一定松弛过点i，重复的松弛没有意义的。因此，我们找到的点i，现在的d[i]，一定是从源点到点i路径最小的点了，因此，该算法的正确性是可以保证的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(n);<br>    set.add(p);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        d[i] = a[p][i];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (set.size() &lt; n) &#123;<br>        <span class="hljs-comment">//找到点周围最近的一个点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">le</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(i) &amp;&amp; le &gt; d[i]) &#123;<br>                le = d[i];<br>                num = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//计算将这个点加入集合后最短距离的变化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(i)) &#123;<br>                d[i] = Math.min(d[i], d[num] + a[num][i]);<br>            &#125;<br>        &#125;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;点&quot;</span> + p + <span class="hljs-string">&quot;到点&quot;</span> + i + <span class="hljs-string">&quot;的距离为：&quot;</span> + d[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树相关代码</title>
    <link href="/2022/07/01/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/07/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><center>红黑树</center></h1><p><strong>最近面试老是被问到红黑树，堪称灵魂拷问：</strong></p><p><strong>面试官：Java的HashMap在JDK1.8之后用的是红黑树，那你知道红黑树是什么吗？</strong></p><p><strong>我：是一个自平衡的二叉排序树吧。</strong></p><p><strong>面试官：能不能跟我细细说一下红黑树呢？</strong></p><p><strong>我：底层源代码没有看过。</strong></p><p><strong>面试官：那你走吧。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1917785-7308462df72e697a.jpg" alt="img"></p><p>太真实了，那今天就看看红黑树的底层是怎么实现的吧。</p><h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。</p><p><strong>什么是二叉平衡树？</strong></p><p>左右子树的高度相差不超过 1 的树为平衡二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/634705-20151010200833471-1139191179.png" alt="二叉查找树_frostime的博客-CSDN博客"></p><p>图中(a)是二叉平衡树（b）不是二叉平衡树</p><p><strong>什么是二叉查找树？</strong></p><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p><p>对于任意一个节点 n，</p><ul><li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li><li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值。</li></ul><p>上面的（a）和（b）都是二叉查找树</p><p><strong>红黑树是一种含有红黑结点并能自平衡的二叉查找树。</strong>它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li><strong>性质5：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/v2-a183459a6010189e8b2b9415d85e550e_r.jpg" alt="preview"></p><p>这些约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</strong></p><p>怎么得出这个结论的呢？</p><p>性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p><h2 id="红黑树有什么用呢，为什么要出现这个树结构呢？"><a href="#红黑树有什么用呢，为什么要出现这个树结构呢？" class="headerlink" title="红黑树有什么用呢，为什么要出现这个树结构呢？"></a>红黑树有什么用呢，为什么要出现这个树结构呢？</h2><p>相比于BST，因为<strong>红黑树可以能确保树的最长路径不大于两倍的最短路径的长度</strong>，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。</p><p>比如这样：</p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/v2-38e1125c3caa7bc83723f70f28533638_720w.jpg" alt="img" style="zoom:80%;" /><p><strong>与二叉平衡树相比：</strong></p><p>红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。</p><h2 id="红黑树怎么保证自平衡的？"><a href="#红黑树怎么保证自平衡的？" class="headerlink" title="红黑树怎么保证自平衡的？"></a>红黑树怎么保证自平衡的？</h2><p>约定一下红黑树中节点的名称：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2392382-abedf3ecc733ccd5.png" alt="img"></p><p>红黑树能自平衡，它靠的是什么？三种操作：<strong>左旋、右旋和变色。</strong></p><p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</p><p><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</p><p><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2392382-a95db442f1b47f8a.png" alt="img"></p><center>左旋</center><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2392382-0676a8e2a12e2a0b.png" alt="img"></p><center>右旋</center><p>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br> <strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br> <strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><h2 id="红黑树如何进行插入"><a href="#红黑树如何进行插入" class="headerlink" title="红黑树如何进行插入"></a>红黑树如何进行插入</h2><p>插入操作包括两部分工作：首先是先找到插入的位置，然后就是把节点插入之后看树结构有没有平衡，如果没平衡的话那么就去利用上述红黑树的特征进行自平衡。</p><p>插入的流程：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>找到插入节点之后，我们对节点进行插入，那么插入的时候节点颜色应该是上面颜色呢？答案是<strong>红色</strong>，原因是红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p><strong>做一个约定：</strong></p><p>将要插入的节点标为<strong>N</strong>，N的父节点标为<strong>P</strong>，N的祖父节点标为<strong>G</strong>，N的叔父节点标为<strong>U</strong>。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含（imply）的。</p><p><strong>插入的几种方式：</strong></p><ul><li><strong>情形1</strong>:新节点N位于树的根上，没有父节点。</li><li><strong>情形2</strong>:新节点的父节点P是黑色（新节点是红色的）。</li><li><strong>情形3</strong>:如果父节点P和叔父节点U二者都是红色</li><li><strong>情形4</strong>:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。</li><li><strong>情形5</strong>:父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。</li></ul><p>我们就一个一个来分析这几种情况：</p><h3 id="1、新节点N位于树的根上，没有父节点。"><a href="#1、新节点N位于树的根上，没有父节点。" class="headerlink" title="1、新节点N位于树的根上，没有父节点。"></a>1、新节点N位于树的根上，没有父节点。</h3><p>这时候我们只需要把节点加入进去，然后把节点的颜色换成黑色，因为根据规则二，根节点必须为黑色。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case1</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent == <span class="hljs-literal">NULL</span>)<br>        n-&gt;color = BLACK;<br>    <span class="hljs-keyword">else</span><br>        insert_case2 (n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、新节点的父节点P是黑色"><a href="#2、新节点的父节点P是黑色" class="headerlink" title="2、新节点的父节点P是黑色"></a>2、新节点的父节点P是黑色</h3><p>在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case2</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent-&gt;color == BLACK)<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 树仍旧有效*/</span><br>    <span class="hljs-keyword">else</span><br>        insert_case3 (n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、如果父节点P和叔父节点U二者都是红色"><a href="#3、如果父节点P和叔父节点U二者都是红色" class="headerlink" title="3、如果父节点P和叔父节点U二者都是红色"></a>3、如果父节点P和叔父节点U二者都是红色</h3><p>此时新插入节点N做为P的左子节点或右子节点都属于情形3,下图仅显示N做为P左子的情形，则我们可以<strong>将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）</strong>。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。<strong>但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。</strong>（把G当成是新加入的节点进行各种情形的检查）</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/Red-black_tree_insert_case_3.png" alt="情形3示意图"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case3</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(uncle(n) != <span class="hljs-literal">NULL</span> &amp;&amp; uncle (n)-&gt;color == RED) &#123;<br>        n-&gt;parent-&gt;color = BLACK;<br>        uncle (n)-&gt;color = BLACK;<br>        grandparent (n)-&gt;color = RED;<br>        insert_case1(grandparent(n));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insert_case4 (n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点"><a href="#4、父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点" class="headerlink" title="4、父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点"></a>4、父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点</h3><p>因为有点绕，先看看图，再进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/Red-black_tree_insert_case_4.png" alt="情形4示意图"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/Tree_rotation_animation_250x250.gif"></p><center>旋转示意图</center><p>在这种情形下，我们进行一次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">左旋转</a>调换新节点和其父节点的角色;接着，我们按<strong>情形5</strong>处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case4</span><span class="hljs-params">(node *n)</span>&#123;<br>     <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;right &amp;&amp; n-&gt;parent == grandparent(n)-&gt;left) &#123;<br>         rotate_left(n);<br>         n = n-&gt;left;<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;left &amp;&amp; n-&gt;parent == grandparent(n)-&gt;right) &#123;<br>         rotate_right(n);<br>         n = n-&gt;right;<br>     &#125;<br>     insert_case5 (n);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5、父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点"><a href="#5、父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点" class="headerlink" title="5、父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点"></a>5、父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点</h3><p>因为有点绕，先看看图，再进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/Red-black_tree_insert_case_5.png" alt="情形5示意图"></p><p>在这种情形下，我们进行针对祖父节点G的一次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">右旋转</a>；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case5</span><span class="hljs-params">(node *n)</span>&#123;<br>    n-&gt;parent-&gt;color = BLACK;<br>    grandparent (n)-&gt;color = RED;<br>    <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;left &amp;&amp; n-&gt;parent == grandparent(n)-&gt;left) &#123;<br>        rotate_right(n-&gt;parent);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Here, n == n-&gt;parent-&gt;right &amp;&amp; n-&gt;parent == grandparent (n)-&gt;right */</span><br>        rotate_left(n-&gt;parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零拷贝相关</title>
    <link href="/2022/07/01/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/07/01/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><strong>什么是零拷贝？</strong></p><p>零拷贝技术，就是避免将数据从一块存储拷贝到另外一块存储的技术，从而节省拷贝带来的CPU开销，零拷贝并不是将拷贝操作完全消除掉。</p><ul><li><strong>传统拷贝</strong>：这个没什么说的，就是平时我们一般都会用到的拷贝方式；</li><li><strong>MMAP方式的拷贝</strong>：当应用程序不需要对数据进行访问时，则可以避免将数据从内核空间拷贝到用户空间；</li><li><strong>SendFile方式的拷贝</strong>：写时拷贝技术，数据不需要提前拷贝，而是当需要修改的时候再进行部分拷贝。</li></ul><h4 id="传统拷贝"><a href="#传统拷贝" class="headerlink" title="传统拷贝"></a>传统拷贝</h4><p>传统的Linux系统中，标准的I&#x2F;O接口（例如read，write）都是基于数据拷贝操作的，即是I&#x2F;O操作会导致数据在内核地址空间的缓冲区和用户地址空间的缓冲区之间进行拷贝，所以标准I&#x2F;O也被称作缓存I&#x2F;O。这样做的好处是，如果所请求的数据已经存放在内核的高速缓冲存储器中，那么就可以减少实际的I&#x2F;O操作，但坏处就是数据拷贝的过程，会导致CPU开销。</p><blockquote><p><strong>DMA（Direct Memory Access）</strong>：直接存储器访问。DMA是一种无需CPU的参与，让外设和系统内存之间进行双向数据传输的硬件机制。当DMA完成数据的传送之后，使用系统中断提醒CPU，然后CPU就可以高效的处理数据。使用DMA可以使系统CPU从实际的I&#x2F;O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201011212100.png" alt="1"></p><p>我们可以看到需要经历四个阶段，2次DMA，2次CPU中断，总共四次拷贝，有四次上下文切换，并且会占用两次CPU。</p><ol><li>CPU发指令给I&#x2F;O设备的DMA，由DMA将我们磁盘中的数据传输到内核空间的内核buffer。</li><li>第二阶段触发我们的CPU中断，CPU开始将将数据从kernel buffer拷贝至我们的应用缓存</li><li>CPU将数据从应用缓存拷贝到内核中的socket buffer.</li><li>DMA将数据从socket buffer中的数据拷贝到网卡缓存。</li></ol><p><strong>优点</strong>:开发成本低，适合一些对性能要求不高的，比如一些什么管理系统这种我觉得就应该够了</p><p><strong>缺点</strong>:多次上下文切换，占用多次CPU，性能比较低。</p><h4 id="MMAP方式的拷贝"><a href="#MMAP方式的拷贝" class="headerlink" title="MMAP方式的拷贝"></a>MMAP方式的拷贝</h4><p>我们提到用户态的进程是不能随意操作内核地址空间的，而且mmap也没有提供用户进程直接操作内核地址空间的能力，而是通过内存映射的机制，把内核中的部分内存空间映射到用户空间的内存，用户空间和内核空间共享一块相同的物理内存，从而提供用户进程对内存直接访问的能力。</p><p>有了mmap的支持，数据从文件中读取到内核空间之后，就不会再拷贝到用户空间，当调用socket的write时，数据会直接从内核缓存中直接拷贝到Socket的缓冲区中，避免了在用户空间中多中转一次。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201011213802.png" alt="3"></p><p>我们可以看到，MMP与传统的拷贝方式相比，mmp减少了数据在用户空间进行一次拷贝mmap虽然能减少一次数据拷贝，但是还是需要4次上下文切换，拷贝的话需要执行三次，即两次DMA拷贝，一次CPU的拷贝：</p><ul><li><p>用户进程通过 mmap() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</p></li><li><p>将用户进程的内核空间的读缓冲区（read buffer）与用户空间的缓存区（user buffer）进行内存地址映射。</p></li><li><p>CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</p></li><li><p>上下文从内核态（kernel space）切换回用户态（user space），mmap 系统调用执行返回。</p></li><li><p>用户进程通过 write() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</p></li><li><p>CPU将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。</p></li><li><p>CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</p></li><li><p>上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返回。</p></li></ul><h4 id="SendFile方式的拷贝"><a href="#SendFile方式的拷贝" class="headerlink" title="SendFile方式的拷贝"></a>SendFile方式的拷贝</h4><p>sendfile内核调用是在Linux 2.1版本开始引入的，主要功能是在内核态中，在两个文件描述符之间传递数据，避免了用户空间和内核空间之间的数据拷贝操作。</p><p>使用sendfile时，数据中转与mmap类似，不经过用户空间，但是由于sendfile全程在内核态执行，因此只需要2次上下文切换：</p><ul><li>调用sendfile将文件内容通过socket发送出去时候，从用户态切换到内核态；</li><li>任务完成之后，切换回来。</li></ul><p>在Linux 2.4版本中，对sendfile进一步做了优化，之前从“文件数据缓存”到“socket缓存”时候，也需要一次拷贝，优化之后，“socket缓存”中只存储要发送的数据在“文件数据缓存”中的位置和偏移量，在实际发送时，根据位置和偏移量直接将“文件数据缓存”中的数据拷贝到网卡设备中，又省掉了一次拷贝操作。</p><p>基于 sendfile和DMA系统调用的零拷贝方式，整个拷贝过程会发生<strong>2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝</strong>用户程序读写数据的流程如下：</p><ol><li>用户进程通过 sendfile() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 把读缓冲区（read buffer）的文件描述符（file descriptor）和数据长度拷贝到网络缓冲区（socket buffer）。</li><li>基于已拷贝的文件描述符（file descriptor）和数据长度，CPU 利用 DMA 控制器的 gather&#x2F;scatter 操作直接批量地将数据从内核的读缓冲区（read buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），sendfile 系统调用执行返回。</li></ol><p>但是使用这种方式也是有缺点的，就是我们再拷贝的过程中<strong>不能对数据进行任何的修改</strong>，如果我们对数据进行修改后再进行拷贝的话这种方式就行不通了。如果我们要对文件进行修改的话就必须使用传统的拷贝方式了。</p><p>因为基于SendFile的这种特性，零拷贝技术被用在Nginx等软件上，提升了很大的效率，比如我们使用nginx的时候对静态资源的读写就会用到零拷贝，大大增加了我们服务器的性能。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统相关知识</title>
    <link href="/2022/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>多进程如何组织</strong></p><p>使用PCB+状态+队列进行组织</p><p>进程的状态：<code>新建</code> <code>就绪</code> <code>运行</code> <code>阻塞</code> <code>终止</code> </p><p>使用每个状态的列表进行组织，这样就完成了进程的调用。</p><p><strong>多进程如何交替执行？</strong></p><ol><li>启动磁盘读写</li><li>pCur.state&#x3D;’W’</li><li>把当前进程的PCB放到WaitQueue</li><li>schedule()</li></ol><p>其中schedule函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">schedule()&#123;<br>    <span class="hljs-comment">//其中找到的是进程的进程控制块PCB</span><br>    pNew=getNext(ReadQueue);<br>    switch_to(pCur,pNew);<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>多进程间的影响怎么解决？</strong></p><p>多进程之间进行运行的时候会出现这种情况：</p><p>即线程A使用了地址为0x1000的地址，那么进程B也使用了0x1000的地址，这样的话进程A就可能破坏B进程中的数据导致B程序崩溃，这时候我们就想了一个办法，使用地址变换机构将每个进程之间的地址进行隔离，这样做到多进程之间没有影响。即进行<code>内存空间管理</code></p><p>使用地址映射机构，可以使得每个变量虽然具有相同的逻辑地址，但是被映射到不同的物理内存地址，这样的话使相应的进程没有地址使用上冲突。</p><p><strong>多进程如何进行合作？</strong></p><p>为了防止多进程对共享资源的使用出现竞争导致出现问题，提出了锁的概念，通过使用锁来实现进程间顺序的推进。</p><p><strong>线程为什么使用起来代价比较小？</strong></p><p>因为进程之间的切换回涉及到PCB的切换，<code>进程=资源+指令</code>进程是拥有着操作系统的资源的（内存），因为进程间的切换要涉及到资源映射表的使用，而使用线程的话不需要进行资源映射表的切换使用，所以线程比进程的切换代价更小。</p><p><strong>内核级线程切换过程</strong></p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201210153659546.png" alt="image-20201210153659546" style="zoom:67%;" /><ol><li>首先用户通过运行系统调用的函数，比如fock()函数</li><li>fork()函数会 执行Int 0x80 中断处理，0x80是系统调用的入口，以此入口进入int 0x80的系统调用函数</li><li>将用户态程序SS:ip压入到内核栈，然后执行systemCall(systemCall即系统调用的入口函数)</li><li>进入中断的处理函数，将用户态寄存器的信息压栈。然后去执行sys_fork()函数</li><li>执行sys_fork()函数的时候可能阻塞，操作系统就会去调度。</li></ol><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><strong>操作系统中进程调度策略有哪几种？</strong></p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a><strong>批处理系统</strong></h4><ul><li><p>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU</p></li><li><p>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度</p></li><li><p><strong>最短剩余时间优先 （SRTN）</strong>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p></li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ul><li>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：<strong>老化</strong></li><li>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</li><li>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</li><li>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</li></ul><h3 id="进程间通信方法"><a href="#进程间通信方法" class="headerlink" title="进程间通信方法"></a>进程间通信方法</h3><ul><li>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li><li>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</li><li>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</li><li>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li></ul><h2 id="操作系统对内存的管理"><a href="#操作系统对内存的管理" class="headerlink" title="操作系统对内存的管理"></a>操作系统对内存的管理</h2><h3 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h3><h4 id="为什么要用分段管理"><a href="#为什么要用分段管理" class="headerlink" title="为什么要用分段管理"></a>为什么要用分段管理</h4><ol><li>方便编程：用户可以把自己的作业按照逻辑关系划分为若干个段，而且每一个段的地址都是从0开始编址的，并且具有自己的段名和长度。逻辑地址是由段名（段号）和段内偏移量（段内地址）组成的。</li><li>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的，而段恰恰是这样的逻辑单位（页只是存放信息的物理块，并无实际的含义）。</li><li>信息保护：在实现对信息的保护时，也是以信息的逻辑单位为基础的。</li><li>动态增长：在实际的应用中，有些段（数据段）会随着程序的运行而不断的动态增长，而且事前不知道数据段会增长到多大。</li><li>在运行时动态链接中，主程序会在运行过程中调用某段时才将该段调入内存并进行链接。可见运行时动态链接也要求以段作为内存管理单位。</li><li>方便管理，如果不采用分段管理的话，那么我们运行一个程序要把整个程序装入内存，但是使用分段管理的话我们就可以让不同的段分别进行内存的装入，这样的话我们就可以更加高效的使用内存。</li></ol><h4 id="内存分区的两种方式"><a href="#内存分区的两种方式" class="headerlink" title="内存分区的两种方式"></a>内存分区的两种方式</h4><p>分区即对内存进行区域的划分，其中可变分区需要对内存已经使用的部分和未使用的部分进行记录。其中有两种方法：</p><ol><li><strong>固定分区的方法</strong> 对内存进行等大小的划分，这显然是不合理的，有些应用使用比较大块的内存，有些应用使用比较小的内存，这样划分的话可能导致太耗内存的应用无法装入，小的内存才能运行。</li><li><strong>可变分区的方法</strong> 对内存进行记录，此时需要记录内存的哪些地址已经使用，哪些地址没有被使用。</li></ol><p>当然可变分区还要选择与之相应的算法，比如，有两块大小不同的区域，一个区域是10K，另一个空闲区域是100K，此时来了一个需要内存为7K的程序，应该怎样使用。</p><p><strong>可变分区的问题</strong></p><p><strong>内存碎片</strong> 即现在内存并没有用完，只是在划分的过程中因为不合理的划分导致没有一块连续的内存可以给应用程序使用，如果发生这种情况的话那我们就需要进行内存紧缩，即把使用过的内存忘一起放，留下来一块整体的内存结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201217201354719.png" alt="image-20201217201354719"></p><p>但是这样的内存紧缩是非常耗费操作系统资源的，对每段内存的移动还需要修改对应的内存记录的值，此外对数据的移动也是非常耗费时间的，而且在此期间我们不能运行任何的应用程序。这对操作系统是及其不友好的，那么这样的话我们就要使用分页的方法进行内存的分配。</p><h3 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h3><p>我们把程序分成<strong>等长</strong>的小块。这些小块叫做“<strong>页（Page）</strong>”，同样内存也被我们分成了和页面同样大小的”<strong>页框（Frame）“，</strong>一个页可以装到一个页框里。在执行程序的时候我们根据一个页表去查找某个页面在内存的某个页框中，由此完成了逻辑到物理的映射。</p><h4 id="多级页表为什么省内存"><a href="#多级页表为什么省内存" class="headerlink" title="多级页表为什么省内存"></a>多级页表为什么省内存</h4><p>做个简单的数学计算，假设虚拟地址空间为32位（即4GB）</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/v2-c735fe62ca8684b83d94de95703a677c_720w.jpg"></p><p>每个页面映射4KB以及每条页表项占4B：</p><ul><li><p>一级页表：进程需要1M个页表项（<code>4GB / 4KB = 1M, 2^20个页表项</code>），即页表（每个进程都有一个页表）占用4MB（<code>1M * 4B = 4MB</code>）的内存空间。</p></li><li><p>二级页表：一级页表映射4MB（2^22）、二级页表映射4KB，则需要1K个一级页表项（<code>4GB / 4MB = 1K, 2^10个一级页表项</code>）、每个一级页表项对应1K个二级页表项（<code>4MB / 4KB = 1K</code>），这样页表占用4.004MB（<code>1K * 4B + 1K * 1K * 4B = 4.004MB</code>）的内存空间。</p></li></ul><p>如果以这种方式去理解，那么多级页表反而使用了更多的内存空间。</p><p>我们反过来想，每个进程都有4GB的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到4GB，何必去映射不可能用到的空间呢？</p><p>也就是说，一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB（<code>1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB</code>）</p><h3 id="段页内存管理"><a href="#段页内存管理" class="headerlink" title="段页内存管理"></a>段页内存管理</h3><p>段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。</p><p>　 (1) 用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。</p><p>   (2) 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20130519103507462" alt="地址空间"></p><p>(3)  逻辑地址结构。一个逻辑地址用三个参数表示：段号S；页号P；页内地址d。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20130519103522884" alt="img"></p><p>4）段表、页表、段表地址寄存器。为了进行地址转换，系统为每个作业建立一个段表，并且要为该作业段表中的每一个段建立一个页表。系统中有一个段表地址寄存器来指出作业的段表起始地址和段表长度。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20130519103644850" alt="img"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/VirtualMem01.png" alt="img"></p><h4 id="页面如何换入"><a href="#页面如何换入" class="headerlink" title="页面如何换入"></a>页面如何换入</h4><p>对于用户而言，用户看到的是一个整体的内存入4G，而且用户可以随便访问4G内存空间的任意位置；但是对于真实的物理内存可能只有1G大小，当用户访问内存时，如果内存里面有需要的内容，就直接访问；如果没有，就去磁盘上查找，然后再把需要找到的数据，再将这些数据载入到内存中供用户使用。那么在这个过程中就需要把磁盘上的数据写到内存里面（换入），也需要把内存中的一些数据写回磁盘上（换出）。</p><p>请求调页（换入）</p><p>当用户访问一个页时，MMU回去查询一个操作系统维护的页表，看看用户访问的页是否存在于内存当中，如果存在，就直接调用；如果没有，就需要开启中断，执行页错误处理程序，在磁盘中找到相应的数据页，并在内存中找到一块空闲，将其载入进来，然后中断返回，执行用户程序，在去访问内存中用户需要的页。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201218093034628.png" alt="image-20201218093034628"></p><h4 id="页面换出"><a href="#页面换出" class="headerlink" title="页面换出"></a>页面换出</h4><p>当我们不断地将页面换入内存当中，内存肯定会不足的，我们需要选择一些页面进行换出，为新的数据腾出空间，但是我们应该选择那些页面换出呢？以下主要讨论一些常用的换出策略。</p><h5 id="FIFO：先进先出页面置换"><a href="#FIFO：先进先出页面置换" class="headerlink" title="FIFO：先进先出页面置换"></a><strong>FIFO：先进先出页面置换</strong></h5><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>0</td><td>0</td><td></td><td></td><td>7</td><td>7</td><td>7</td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>1</td><td>1</td><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>2</td><td></td><td></td><td>2</td><td>2</td><td>1</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td></tr></tbody></table><p>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p><h5 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a><strong>最近最久未使用(LRU)置换算法</strong></h5><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>1</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td></td><td>0</td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td></td><td>2</td><td></td><td>7</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td></tr></tbody></table><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p><h5 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a><strong>最佳置换算法(OPT)</strong></h5><p>最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td></td><td>7</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>4</td><td></td><td></td><td>0</td><td></td><td></td><td>0</td><td></td><td></td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td></td><td></td><td>3</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td>√</td><td></td><td></td></tr></tbody></table><h5 id="第二次机会算法-SCR"><a href="#第二次机会算法-SCR" class="headerlink" title="第二次机会算法(SCR)"></a><strong>第二次机会算法(SCR)</strong></h5><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67.png" alt="68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67"></p><p>我们用循环队列组织这个结构更加合适</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20170813165010609" alt="img"></p><p>对于SCR算法，有一个问题，就是程序是具有局部性的，所以经常出现在替换间期内每一页都被访问过，当需要替换时，每一页的引用位都是1，这样每次被替换出去的就是指针所指的那一页，从而退化成了FIFO算法。</p><h5 id="Clock算法"><a href="#Clock算法" class="headerlink" title="Clock算法"></a>Clock算法</h5><p>SCR算法中的问题原因就是替换期间比较长，在这个期间内每页都被访问了，那么解决方式就是引入一根更新指针，每隔一段时间，把所有页的引用位设置为0，通过这样的防止SCR算法的退化。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20170813165017614" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2022/07/01/%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/07/01/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h1><h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>根据上面索引的定义，可以知道索引其实是一种数据结构，主要用于<strong>提高表中的查询效率</strong>，除此之外，索引还是数据库<strong>随机高速读取</strong>和对记录进行<strong>有效排序</strong>的基础。</p><h3 id="不使用索引情况下数据的读取"><a href="#不使用索引情况下数据的读取" class="headerlink" title="不使用索引情况下数据的读取"></a>不使用索引情况下数据的读取</h3><p>除了像 Redis 这样的内存型数据库外，大部分的关系型数据库如 MySQL 等的数据都是直接存储在磁盘上的，而对于从磁盘查找数据来说，需要经历<strong>寻道</strong>， <strong>寻址</strong>， <strong>数据传输</strong>三个阶段。</p><ul><li>寻道：驱动器驱动磁头前后移动到对应的磁道，一般为 5 ~ 14 ms</li><li>寻址：磁盘旋转到指定扇区的过程，寻址时间与磁盘转速有关，对于一个 7200 转的磁盘来说，意味着一分钟转 7200 圈，每秒可以转 120 圈，在寻址时，最好情况下磁头正好在正确扇区不需要再次寻址，最差情况下需要转一圈才能到正确扇区，所以寻址的平均时间为 1&#x2F;120&#x2F;2 &#x3D; 4.17ms1&#x2F;120&#x2F;2&#x3D;4.17<em>m</em> <em>s</em></li><li>数据传输：数据传输阶段的耗时主要包括两部分，一是磁头从磁盘读取到数据并存储到磁盘缓存所需要的时间，二是从磁盘缓存中读取数据到对应控制器所需的时间；数据传输耗时主要与硬件性能有关，但一般为零点几毫秒。</li></ul><p>所以直接从磁盘读取数据的 IO 耗时一般在 10ms 左右，为了避免频繁的磁盘 IO，所以操作系统在读取数据时会以<strong>页</strong>为单位，一次读取目标数据以及和目标数据相邻的一页大小（4K或8K）的数据并放在缓存中，这样下次再读取相邻的数据时就可以直接从缓存中返回了。</p><p>在不使用索引的情况下，如果要查询最后一条数据，就需要从头遍历到尾，<br>这种情况下，数据库需要读取所有的片才能得到目标数据，大量时间会浪费在磁盘 IO 上，为此，我们需要一种数据结构去记录数据项和磁盘中页的关系，这样在查询某条记录时就可以直接定位到某一页，这样只需要进行一次磁盘IO便可以得到目标数据，可以大大优化查询效率，这种数据结构便是索引。</p><p><strong>Mysql 默认读入的是16KB 也就是4页哦！</strong></p><h2 id="为什么是-B-树"><a href="#为什么是-B-树" class="headerlink" title="为什么是 B+ 树"></a>为什么是 B+ 树</h2><p>要实现上面的功能，首先可以采用 Hash Table 的方式，将索引键 Hash 之后存储哈希值和键对应的行指针，这样一来，在使用哈希索引查询的时候就可以直接计算出要查询记录的哈希值，然后查询此哈希值对应的行指针，由于每一行所需要的存储空间是固定的，所以得到行指针就相当于定位到了记录对应的页，这时每次查询只需要进行一次磁盘 IO， 可以大大优化查询效率，但哈希索引存在一些问题：</p><ul><li><strong>哈希冲突</strong>: 只要使用 Hash Table 的数据结构，哈希冲突就是不可避免的，MySQL 中解决冲突的方式是<strong>拉链法</strong>，即一旦发生冲突就把新的记录以链表的方式链接到原来的记录之后，这样每次查询都需要先遍历这个链表得到一个行指针，再根据行指针查询记录，得到记录后再与要查询的记录作比较，如果得到的不是要查询的记录，要回去取链表中的下一个行指针，再去查询比较，直到得到期望的数据，因此使用哈希索引后的磁盘IO次数取决于冲突的发生率，在存在大量冲突时，哈希索引的查询效率会急速下降。</li><li><strong>哈希索引只支持等值查询</strong>：由于哈希索引是根据哈希键计算出哈希值，所以它只能在进行等值查询（如 <code>IN</code>, <code>=</code>, <code>&lt;=&gt;</code>）时才能起到优化效率的效果，在进行非等值操作（如 <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;&gt;</code>）时起不到任何作用。</li><li><strong>组合索引</strong>：在使用组合索引时，哈希索引的做法是将所有索引键合并后再做哈希，这就导致对多个字段做组合索引后，再查询其中某一个字段时无法利用索引。</li><li><strong>无法根据索引进行有效排序</strong>，哈希之后的的值已经丢失了原来的索引键的大小信息，所以无法根据索引进行高效排序</li></ul><p>除了使用 Hash Table, 另一个思路是使用排序树，以排序树的结构组织页后，可以将原来查询 O(n)的复杂度降低到 lg <em>n</em> 而 <em>o</em>(<em>n</em>)的复杂度就意味着每次查询需要进行 <em>n</em> 次磁盘IO，使用排序树后虽然不能像哈希表一样达到 <em>O</em>(1) 的复杂度，但相比不使用索引可以大大减少磁盘 IO 的次数 。</p><p>MySQL 中默认使用 B+ 树构建索引，之所以使用 B+ 树而不是 B 树或二叉排序树的原因在于：</p><ol><li>要选取的树结构必须是稳定的，如果采用二叉排序树，在插入有序序列后，二叉树就会退化为链表，起不到好的优化效果</li><li>根据排序树查询其实是在进行树的深度遍历，而每遍历一层树节点都是一次磁盘IO，所以具体的IO次数取决于树的高度，这就要求树要尽可能矮，也就要求能一个根节点能持有多个子节点。</li></ol><p>B+ 树就满足上面的要求，首先 B+ 树是一棵多路平衡二叉树，其次由于磁盘IO以固定大小的页为单位，所以每次进行磁盘IO能够查询出的数据量是有限制的，这同样意味着树的一个父节点能够持有的子节点数量是有限的，而 B+ 树的数据只存储在叶子节点，中间节点只存储指针，这使得每个中间节点能持有更多的子节点，相比 B 树，B+ 树的高度更低，且每次查询都必须遍历到叶子节点，使得 B+ 树的查询稳定性更高。</p><p>虽然上面说 B+ 树的叶子节点存储数据，但具体到 MySQL 对索引的实现上，叶子节点存储的依然不是真正的数据，存储的只是指向真实数据的指针，当然聚簇索引除外，聚簇索引存储数据的顺序和索引顺序是一致的，一张表也只能建立一个聚簇索引，一般用于主键索引。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>MySQL 索引根据用途不同可以分为以下几种类型：</p><ol><li><p>普通索引（INDEX）</p></li><li><p>唯一索引（UNIQUE INDEX）</p></li><li><p>主键索引（PRIMARY KEY）</p></li><li><p>组合索引（UNION INDEX）</p></li><li><p>全文索引（FULLTEXT ）：这是针对大量文本数据的一种特殊所索引，其组织形式也与一般索引不尽相同，主要用于查找文本中的关键字，只能建立在 <code>char、varchar，text </code> 列上， 需要注意的是，直到 MySQL 5.6 InnoDB 引擎才支持了全文索引，在这之前只有 MyISAM 支持, 同时，全文索引一般配合 <code>match against</code> 使用，而不是 <code>where</code>, 关于全文索引的用法，可以参考<a href="https://zhuanlan.zhihu.com/p/35675553">知乎</a>这篇文章</p><blockquote><p>值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p></blockquote></li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>创建索引有三种方式;</p><ol><li><p>创建表时直接定义</p></li><li><p>使用 <code>ALTER</code> 语句修改表结构创建</p></li><li><p>直接使用 <code>CREATE TABLE</code> 命令创建:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE table_name[col_name data <span class="hljs-built_in">type</span>]<br>[<span class="hljs-keyword">unique</span>|fulltext][<span class="hljs-keyword">index</span>|<span class="hljs-keyword">key</span>][index_name](col_name[<span class="hljs-built_in">length</span>])[<span class="hljs-keyword">asc</span>|<span class="hljs-keyword">desc</span>]<br></code></pre></td></tr></table></figure><ul><li><code>unique|fulltext</code> 为可选参数，分别表示唯一索引、全文索引</li><li><code>index</code> 和 <code>key</code> 为同义词，两者作用相同，用来指定创建索引</li><li><code>col_name</code> 为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</li><li><code>index_name</code> 指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</li><li><code>length</code> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</li><li><code>asc</code> 或 <code>desc</code> 指定升序或降序的索引值存储</li></ul></li></ol><p>删除索引：</p><ol><li><p>直接删除：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过修改表结构删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER TABLE table_name DROP index_name;<br></code></pre></td></tr></table></figure></li></ol><p>查看索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure><h2 id="索引建立的原则"><a href="#索引建立的原则" class="headerlink" title="索引建立的原则"></a>索引建立的原则</h2><p>天下没有免费的午餐，索引也并不是万能的，它带来高查询效率的同时也会带来一些问题：</p><ol><li>占用更多的磁盘空间（一般不考虑）</li><li>导致较低的写效率：由于索引需要维持一个庞大的树结构，加上这是一棵排序树，这就会导致某些插入和修改操作会造成树的重建，因此索引带来高查询效率的同时会导致较低的写效率。</li></ol><p>所以对一些不应该建立索引的列建立索引后可能导致更差的性能，在考量某一列是否应该建立索引时需要参考一个重要的法则：最左前缀法则，不满足该法则可能导致索引失效进而退化成全表扫描。</p><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>最左前缀法则是建立联合索引时最重要的法则。</p><blockquote><p>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配.</p></blockquote><p>如以下的表结构：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">CREATE TABLE `left` (<br>  `id` int(<span class="hljs-number">11</span>) <span class="hljs-literal">NOT</span> NULL AUTO_INCREMENT,<br>  `a` varchar(<span class="hljs-number">255</span>) <span class="hljs-literal">NOT</span> NULL,<br>  `b` varchar(<span class="hljs-number">255</span>) <span class="hljs-literal">NOT</span> NULL,<br>  `c` varchar(<span class="hljs-number">255</span>) <span class="hljs-literal">NOT</span> NULL,<br>  `d` varchar(<span class="hljs-number">255</span>) <span class="hljs-literal">NOT</span> NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `index1` (`a`,`b`,`c`)<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">86139</span> DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>我们建立了 <code>a, b, c</code> 的组合索引后：</p><ol><li><p>在进行等值查询如<code>=</code> 或 <code>IN</code> 时， 可以不考虑顺序，SQL 查询优化器会自动调整语句顺序，如执行下面两条语句的效果是一样的（根据索引长度我们可以推断出对哪几个列使用了索引）：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104722.png" alt="img"></p></li><li><p>可以查询建立了聚合索引的某几列，DBS会根据建立索引时的顺序从左开始匹配能够使用索引的列，如执行<code>a = “” AND b = “” </code> 时会对 a 和 b 使用索引，而在执行 <code>a = “” AND c = “&quot;</code> 时则只会对 a 使用索引，而如果只执行 <code>b = “”</code> 时，由于第一个索引 a 就无法匹配到，所以不会使用索引</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104732.png" alt="img"></p></li><li><p>最左匹配原则在遇到范围查询：**&gt;、&lt;、between、like** 时会停止匹配，如执行 <code>a = “” AND b &gt; 10 AND c = “”</code> 时只会对 a 使用索引。</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1602059417139-1602059417076.png" alt="img"></p><ul><li><p>关于 like: like 相比于其他几个要稍微复杂一点，并不是一旦遇见like就会停止匹配，而是通配符如果出现在首位才会停止匹配，如下面的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104737.png" alt="img"></p></li></ul></li><li><p>对索引列进行运算操作会导致索引失效，原因与 like 的通配符一样，还有需要注意一点，如果索引字段是字符类型，查询时不加引号也会导致索引失效，原因在于MySQL会自动为我们的查询语句转化成字符，这就相当于引入了运算操作:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-symbol">`left`</span> <span class="hljs-keyword">WHERE</span> a = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">AND</span> b = <span class="hljs-number">1</span><br>-- 将 <span class="hljs-number">1</span> 转化为 <span class="hljs-string">&#x27;1&#x27;</span> 的过程引入了运算操作导致索引失效<br></code></pre></td></tr></table></figure></li><li><p>如果 <code>OR</code> 之后的字段没有使用索引，那么整个索引都将失效。</p></li><li><p><code>NOT IN</code> 可能导致的索引失效</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104746.png" alt="img"></p><h4 id="为什么要最左匹配"><a href="#为什么要最左匹配" class="headerlink" title="为什么要最左匹配"></a>为什么要最左匹配</h4><p>首先要明确的是最左匹配原则适用于联合索引，对于普通索引，不存在匹配的问题，而之所以要严格进行最左匹配，也是由联合索引的数据结构形式决定的：</p><p>我们知道 MySQL 默认情况下使用 B+ 树组织索引的数据结构，对于像上文中的联合索引，它的结构是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104749.png" alt="img"></p><p>相比普通索引的叶子节点，联合索引的叶子节点存储所有关键字的数据，比如建立了<code>a, b, c</code>的索引，那么如上图，每个叶子节点都会存储a, b, c 三个关键字的数据信息，并且会按照建立索引时的顺序排序，但中间节点只会存储第一个关键字的位置指针，当我们执行类似</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-symbol">`table`</span> <span class="hljs-keyword">WHERE</span> a = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-keyword">AND</span> b = <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-string">&quot;4&quot;</span> <br></code></pre></td></tr></table></figure><p>时，数据库会根据第一个关键字 a 的值 1 定位到某个叶子（图中左边的叶子节点），然后从所有叶子节点的数据里检索出符合第一条规则<code>a = &quot;1&quot;</code> 的数据（图中前六行），然后再从这些数据里检索出符合第二条规则的数据（图中2， 3， 4）行，依次类推直到找到或确认找不到期望数据为止。</p><p>而之所以遵循最左匹配原则，也是因为叶子节点的排序方式是按照索引建立时的顺序排序的，也就是 b 只有在 a 相等的情况下才是有序的（如图中第二列整体并不是有序的，但只看 a &#x3D; 1 前提下的 b 就是有序的了），所以如果跳过 a 去查询 b, 因为无法保证 b 的有序性，只能进行全表扫描。</p><p><code>like</code> 之所以遇到以通配符开头的情况才停止匹配也是由叶子节点的这种数据排序方式决定的，因为 like 字句如果不以通配符开头那他开头的部分是可以利用到排序信息的，如执行：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-symbol">`left`</span> <span class="hljs-keyword">WHERE</span> a = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-keyword">AND</span> b <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&quot;2%&quot;</span><br></code></pre></td></tr></table></figure><p>虽然 b 的检索不是等值检索，但我们任然可以根据 like 子句开头的 “2” 快速定位到 2 ~ 4 行，但如果以通配符开头，显然就定位不到了。</p><h3 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h3><ol><li><p>对经常需要修改的数据不要建立索引，一般数据的读写比为 10：1， 如果低于此，索引可能造成写数据效率低下</p></li><li><p>对于重复读高的数据不建议建立索引，如性别，区分度公式为：</p><p>\frac{count(distinct col)}{count(*)}<em>c<strong>o</strong>u<strong>n</strong>t</em>(∗)<em>c<strong>o</strong>u<strong>n</strong>t</em>(<em>d<strong>i</strong>s<strong>t</strong>i<strong>n</strong>c<strong>t</strong>c<strong>o</strong>l</em>)</p><p>最好的区分度为 11 ,即所有数据不重复，一般要求区分度高于 0.1</p></li><li><p>不建议对不经常查询的列或 “大数据” 建立索引，如 TXT， 二进制信息等。</p></li><li><p>建议给主键和外键建立索引，一来主键是唯一的，通过索引检索可以大大提高定位速度，其次为外键建立索引也可以提高表之间连接的速度</p></li><li><p>对于经常出现在 WHERE 子句中的或经常按范围查询的列，建议建立索引，由于 MySQL 中使用指针连接了叶子节点，所以对于按范围查询的列，建立索引后可以进一步降低磁盘 IO。</p></li><li><blockquote><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)。</p></blockquote></li><li><blockquote><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></blockquote></li><li></li></ol><h3 id="索引跳跃式扫描（INDEX-SKIP-SCAN）"><a href="#索引跳跃式扫描（INDEX-SKIP-SCAN）" class="headerlink" title="索引跳跃式扫描（INDEX SKIP SCAN）"></a>索引跳跃式扫描（INDEX SKIP SCAN）</h3><p>加入我们建立了 <code>a, b, c</code> 顺序的组合索引，但 <code>a</code> 的区分度不高，然后执行了 <code>WHERE b = &quot;&quot; AND ...</code> 就会出现 INDEX SKIP SCAN 的情况， 也就是说 SQL 查询优化器跳过了 a 对后面的列使用了索引，如下面这种情况:</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104755.png" alt="img"></p><p>上图中 songs 表结构如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+--------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> Field  </span>|<span class="hljs-string"> Type         </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra </span>|<br>+--------+--------------+------+-----+---------+-------+<br>|<span class="hljs-string"> id     </span>|<span class="hljs-string"> bigint(25)   </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> name   </span>|<span class="hljs-string"> varchar(255) </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> link   </span>|<span class="hljs-string"> varchar(200) </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string"> singer </span>|<span class="hljs-string"> int(11)      </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">       </span>|<br>+--------+--------------+------+-----+---------+-------+<br></code></pre></td></tr></table></figure><p>并且为该表建立了 <code>singer, name, link</code> 顺序的组合索引, 但 singer 的区分度约为 0.04， 很低：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select  COUNT(DISTINCT left(singer,110))/COUNT(*) AS singer, COUNT(DISTINCT left(name,255))/COUNT(*) AS name, COUNT(DISTINCT left(link,200))/COUNT(*) AS link  FROM songs ; </span><br><span class="hljs-section">+--------+--------+--------+</span><br><span class="hljs-section">| singer | name   | link   |</span><br><span class="hljs-section">+--------+--------+--------+</span><br><span class="hljs-section">| 0.0390 | 0.7715 | 1.0000 |</span><br><span class="hljs-section">+--------+--------+--------+</span><br>1 row in set (25.82 sec)<br></code></pre></td></tr></table></figure><p>在这种情况下，由于 singer 的区分度很低，所以全表扫描查询 singer 字段的代价并不是很高，同样对于 singer 来说，使用索引的效果并不明显，但相比之下，后面的 name 和 link 字段的区分度很高，使用索引的效果会非常明显，这时如果由于 “无关紧要” 的 singer 导致后面真正需要索引的 name 和 link 无法使用索引显然得不偿失，因此在 MySQL 8.0 之后加入了 ISS 机制，它允许组合索引在左边的列唯一值较少的情况下跳过左边列对右边列使用索引。</p><h3 id="成本优先"><a href="#成本优先" class="headerlink" title="成本优先"></a>成本优先</h3><p>索引的出现本就是为了降低查询成本的，但若在某些情况下使用索引反而增加了查询成本，那就不应该使用索引，MySQL 在执行查询前会预估查询成本，然后根据成本决定是否使用索引或使用哪个索引，不使用索引时的查询成本包括两部分：</p><ol><li>IO 成本：指的是把数据从磁盘读到内存的成本</li><li>CPU 成本：是指将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，一般默认情况下每行的 CPU 成本约为 0.2</li></ol><p>而如果表中有索引，在执行查询前，数据库引擎会估算使用索引所需要的成本，具体估算方法参考：xx , 估算出的值可以通过 <code>optimizer_trace </code> 工具查看，如果索引的成本高于全表扫描的成本，那就会放弃索引。</p><p>如执行 :</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=on&quot;</span>;<br>SELECT * <span class="hljs-keyword">FROM</span> `left` WHERE a &gt; <span class="hljs-string">&quot;1&quot;</span>;<br>SELECT * <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE;<br><span class="hljs-built_in">SET</span> <span class="hljs-attribute">optimizer_trace</span>=<span class="hljs-string">&quot;enabled=off&quot;</span>;<br></code></pre></td></tr></table></figure><p>后得到使用 index1 索引的成本为 54705</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;analyzing_range_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;range_scan_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;1 &lt; a&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rowid_ordered&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;using_mrr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;index_only&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">49977</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">54705</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cost&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;analyzing_roworder_intersect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;too_few_roworder_scans&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>但全表扫描成本为：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1602040996608-1602040996603.png" alt="img"></p><p>显然全表扫描的效率要高于使用索引的效率。</p><p>需要注意的是数据库引擎只是只是在估算成本，这个值不一定准确，上面的例子从最左前缀的角度也不应该使用索引，只是为了说明并不是在任何时候数据库引擎都会去使用索引的在涉及到低区分度，Null 值等的时候，引擎会选取一个相对最优的方案。</p><h2 id="索引的使用建议"><a href="#索引的使用建议" class="headerlink" title="索引的使用建议"></a>索引的使用建议</h2><h3 id="一-避免索引失效"><a href="#一-避免索引失效" class="headerlink" title="一. 避免索引失效"></a>一. 避免索引失效</h3><ol><li>谨慎选择组合索引的建立顺序</li><li>涉及非等值操作查询时，谨慎安排查询语句的顺序，避免范围查询导致索引失效</li><li>不要在索引字段上执行计算操作</li><li>匹配字符串时不要依赖 MySQL 的类型转换</li><li>谨慎使用 <code>OR</code></li><li>谨慎选择 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code></li></ol><h3 id="二-使用索引覆盖"><a href="#二-使用索引覆盖" class="headerlink" title="二. 使用索引覆盖"></a>二. 使用索引覆盖</h3><p>覆盖索引指的是索引字段覆盖了需要查询的所有字段，这时根据索引便可以拿到所有数据而不需要回表查询，反之，如果使用类似 <code>SELECT *</code> 或 索引字段未覆盖期望的所有字段时，未被覆盖的字段就需要回表查询，这便又增加了磁盘 IO 的次数，如果发生了回表查询， EXPLAIN 的描述（Extra）字段会显示 <code>Using index condition</code> 这时我们应该考虑是否需要优化。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008104812.png" alt="img"></p><h3 id="三-有时全表扫描更快"><a href="#三-有时全表扫描更快" class="headerlink" title="三. 有时全表扫描更快"></a>三. 有时全表扫描更快</h3><p>索引不一定能 100% 提高查询效率，使用不当反而会使性能下降</p><h3 id="四-尽量使用复合索引"><a href="#四-尽量使用复合索引" class="headerlink" title="四. 尽量使用复合索引"></a>四. 尽量使用复合索引</h3><p>在每次查询时，数据库只会选择一个最优的索引使用，所以使用复合索引往往优于使用多个单列索引。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>什么是索引：<ul><li>索引是一种数据结构，用来提高在数据表中的数据查询效率，同时也是随机读和有效排序的基础。</li></ul></li><li>为什么使用索引：<ul><li>根本原因在于磁盘速度与内存速度差距甚大，所以我们希望能使用尽可能少的磁盘 IO 次数去拿到想要的数据，因此引入了索引，索引通过哈希表或 B+ 树的方式存储了索引值和数据块的对应关系，使得能够在较低的时间复杂度内拿到数据。</li></ul></li><li>InnoDB 中为什么选择 B+ 树组织索引：<ul><li>实现索引的数据结构必须能在较低的时间复杂度内找到索引键对应的数据，除了哈希表外，可以选择排序树，同时为了减少磁盘 IO 次数，要求这棵树要尽可能低，要实现自平衡，不能在极端情况下退化为链表，再者，由于操作系统以页为单位进行磁盘 IO，这就意味这不能为了降低树高度无限增加一个树节点的子节点，所以为了保证一个中间节点持有更多子节点而选择 B+ 树而不是 B 树，另外，B+ 树所有数据存储在叶子节点，这样每次查询的时间复杂度都是一致的，可以获得更高的稳定性。</li></ul></li><li>聚簇索引和非聚簇索引的区别：<ul><li>聚簇索引在一张表中只能有一个，一般是主键索引，聚簇索引的叶子节点存储的是真实地数据。</li><li>非聚簇索引可以建立多个，其叶子节点存储地并不是真实地数据，而是主键值，根据非聚簇索引只能拿到该行记录地主键值，要拿到真实地数据还需要根据聚簇索引去查询</li></ul></li><li>在什么情况下使用索引：<ul><li>读操作比例大大高于写操作比例时。</li><li>数据区分度高。</li><li>主键和外键建议使用。</li><li>经常出现在 <code>WHERE</code> 子句中的列。</li></ul></li><li>如何高效地使用索引：<ul><li>建立索引时尽量使用组合索引。</li><li>不要对大量数据建立索引。</li><li>建立组合索引时认真考虑先后顺序。</li><li>使用索引时严格遵循最左前缀原则,避免索引失效。</li><li>尽量使用索引覆盖，避免 <code>SELECT *</code></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[【tutorialspoint】mysql-indexes](<a href="https://www.tutorialspoint.com/mysql/mysql-indexes.htm#:~:text=A">https://www.tutorialspoint.com/mysql/mysql-indexes.htm#:~:text=A</a> database index is a,ordering of access to records.)</p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">【美团技术文章】MySQL索引原理及慢查询优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/27700617">【知乎】平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了</a></p><p><a href="https://blog.csdn.net/olizxq/article/details/82313489">【CSDN】数据库中的索引技术——哈希索引</a></p><p><a href="http://www.360doc.com/content/11/1028/20/7695581_159948053.shtml">【360doc】数据库建立索引的原则</a></p><p><a href="http://39.106.168.39/cnblogs.com/luyucheng/p/6289714.html">【博客园】sql 索引类型</a></p><p><a href="https://www.cnblogs.com/xqzt/p/4467482.html">索引跳跃式扫描（INDEX SKIP SCAN）</a></p><p><a href="https://cloud.tencent.com/developer/article/1530142">【腾讯云】 MySQL中IS NULL、IS NOT NULL、!&#x3D;不能用索引？胡扯！</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="首先看看模型（从下到上）"><a href="#首先看看模型（从下到上）" class="headerlink" title="首先看看模型（从下到上）"></a>首先看看模型（从下到上）</h3><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008162810.png" alt="七层模型总"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201008154843.png" alt="OSI七层模型与TCP/IP五层模型"></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>协议：PPP、CSMA&#x2F;CD</strong></p><p>主要解决的问题：<strong>透明传输、封装成帧、差错检测</strong>，**<code>局域网</code>属于数据链路层的范畴**</p><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p><strong>封装成帧就是在数据段的前后分别添加首部和尾部，这样就构成了一个帧。</strong></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p><strong>其实就是对前面的帧定界符号进行字符填充，让其不会出现差错。</strong></p><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>方法：<strong>CRC冗余检验</strong></p><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009194741.png" alt="IP地址分类（A类B类C类D类E类）"></p><p>A类地址范围：0.0.0.0—127.255.255.255</p><p>B类地址范围：128.0.0.0—191.255.255.255</p><p>C类地址范围：192.0.0.0—233.255.255.255</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008163717.jpeg" alt="IP地址中A类、B类、C类地址范围"></p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>主要作用：知道了主机或者路由器的IP地址想要知道MAC地址的话我们就要用到ARP解析。</p><p>具体实现：</p><ol><li>首先主机会在本机存储一个ARP高速缓存中存放一个映射表</li><li>ARP进程本局域网内发送一个ARP请求分组（广播方式），分组内容为我的IP地址是XXXXMAC地址为xxxx，我想知道IP地址为ＸＸＸ的硬件地址是谁</li><li>本局域网内的所有主机都接收到这个请求</li><li>如果某个主机的IP地址与其发送请求的IP地址对应的话，那么该主机会发送响应包，响应包内会有响应主机的MAC地址</li><li>发送方收到响应包之后会把改IP地址与之对应的MAC地址写入到ARP高速缓存中。</li></ol><h4 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h4><ol><li>内部网关协议有：<code>RIP</code> <code>OSPF</code> 外部网关协议：<code>BGP</code></li></ol><p>内部网关协议中的RIP协议：</p><blockquote><p>RIP是内为最早出现的<a href="https://zh.wikipedia.org/wiki/%E8%B7%9D%E9%9B%A2%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%94%E5%AE%9A">距离向量路由协议</a>，RIP允许一条路径最多只能包含15个路由器，因此如果<strong>距离</strong>如果超过15就会显示不可达，（这里所说的距离指的是路由器到非直接连接的网络的距离），因此RIP协议只能用于规模比较小的互联网，RIP并不能在两个网络之间使用多条路由。</p><p>特点：</p><ol><li>仅仅和相邻的路由器交换信息</li><li>路由器交换的是当前本路由器知道的全部信息，即自己现在的路由表</li><li>按照固定时间间隔交换路由信息</li><li>当出现故障时需要很长的时间才能传递到所有本路由器（好消息传得快，坏消息传得慢）</li></ol></blockquote><p>内部网关协议中的OSPF（Open Shortest Path First）协议：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p></blockquote><p>外部网关协议中的BGP（Border Gateway Protocol）协议：</p><blockquote><p>它通过维护IP<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8">路由表</a>或‘前缀’表来实现<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">自治系统</a>（AS）之间的可达性，属于矢量路由协议。BGP不使用传统的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议</a>（IGP）的指标，而使用基于路径、网络策略或规则集来决定路由。因此，它更适合被称为矢量性协议，而不是路由协议。</p></blockquote><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008181435.png" alt="image-20201008181434345"></p><h4 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h4><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008181721.png" alt="image-20201008181719416"></p><p><strong>为什么要三次握手呢？两次行吗？</strong></p><p>当然不行，如果可以的话他就这么做了😄，那为什么最后还需要一次呢？</p><p><strong>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008181958.png" alt="image-20201008181955961"></p><p><strong>为什么建立连接要三次，但是关闭连接要四次呢？</strong></p><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><p><strong>为什么要有TIME_WAIT，而且还要等待2MSL（Maximum Segment Lifetime）</strong></p><blockquote><ol><li>因为可能出现虽然客户端发送了最后的ACK信号，但是服务器并没有收到这个ACK，那么服务端会重发FIN请求，那么此时如果客户端关闭的话，就不能再发送ACK包，所以要等待TIME_WAIT时间，如果2MSL时间内没接收到服务器重传的FIN，证明要么服务器已经成功接收到了ACK报文，要么可能自己的网络出现异常了，比如断网了，那么这两种情况下关闭连接都是合理的选择（好像第二种情况下也就没得选择🤭）</li><li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ol></blockquote><h4 id="TCP的流量控制——使用滑动窗口"><a href="#TCP的流量控制——使用滑动窗口" class="headerlink" title="TCP的流量控制——使用滑动窗口"></a>TCP的流量控制——使用滑动窗口</h4><p>首先明确一下流量控制的概念：<strong>流量控制就是让发送方的发送速率不要太快，让接收方能够来的及接收</strong>，TCP使用的流量控制方法就是<strong>使用滑动窗口来进行流量控制</strong></p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008190152.webp" alt="实现"></p><p>我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是11格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。</p><p><strong>正常情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008190443.png" alt="img"></p><p>看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。</p><p><strong>丢包情况</strong></p><p>有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008190515.webp" alt="丢包"></p><p>比如此时的5号报文，如果没有发过去的话，那么就需要进行重传5号报文，然后将滑动窗口移动。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201008190752.webp" alt="超时重发"></p><h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><p>拥塞控制的概念：<strong>防止过多的数据注入到网络中，造成网络中的路由器或者链路过载。</strong></p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><blockquote><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p></blockquote><p>在刚刚发送报文时，先将cwnd设置为1到2个SMSS(Sender Maximum Segment Size)的数值，然后再没收到有一个新的报文段的确认之后可以把cwnd的数值增加，具体增加的公式为：<code>拥塞窗口cwnd增加量=min(N,SMSS)</code>这里的N指的是原先未被确认的，现在被确认的报文段所确认的字节数。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009172301.jpg"></p><p><strong>我们可以看到，慢开始算法没经过一个传输伦茨，拥塞窗口就加倍</strong></p><p><strong>慢启动涨到什么时候是个头呢？</strong></p><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009173127.jpeg"></p><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg" alt="拥塞发送 —— 超时重传"></p><p>可以看到发生超时情况的时候又会重新执行慢启动，同时设置慢启动门限为原来的一半。</p><p><strong>快速重传</strong></p><p>当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009173703.jpeg"></p><p>快速重传和快速恢复</p><p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><p>来一张总图：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009173902.png" alt="TCP拥塞控制算法"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应</p><p>用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com/">www.ibm.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>查询过程</p><img src="https://www.isqqy.com/img/post/2019/20190503/dns-parse.png" alt="DNS解析过程- is Q的博客| is Q Blog" style="zoom:80%;" /><p>简单说一下域名解析的解析过程：</p><ol><li><code>主机向本地域名服务器查询使用递归查询</code>，递归查询就是：<strong>如果主句询问的本地域名服务器不知道被查域名的IP地址，那么，本地域名服务器就会以DNS客户的身份，向其他根域名服务器查询，而不是让该主机自己进行下一步查询。</strong></li><li>本地域名服务器想根域名服务器的查询通常是<code>迭代查询</code>：当根域名收到本地域名服务器发出的迭代请求报文后，要么给出IP地址，要么告诉本地域名服务器下一步应该去查询的服务器的IP地址，然后<strong>让本地域名服务器进行后续查询，而不是代替本地域名服务器去查询</strong>。</li></ol><h4 id="面试常问-gt-从输入一个url到页面显示，做了哪些事情？"><a href="#面试常问-gt-从输入一个url到页面显示，做了哪些事情？" class="headerlink" title="面试常问-&gt;从输入一个url到页面显示，做了哪些事情？"></a>面试常问-&gt;从输入一个url到页面显示，做了哪些事情？</h4><ol><li>浏览器查询浏览器中的域名缓存，看看能否找到域名对应的IP地址，如果找到的话就直接进行返回Ip地址进行下一步，否则进行域名解析。</li><li>如果查询到IP地址的话会进行TCP的三次握手建立连接。</li><li>建立连接后发送HTTP请求到服务器。</li><li>服务器处理HTTP请求。</li><li>返回HTTP请求结果（可能是页面，图片，或者json数据，或者其他数据）</li><li>本机浏览器解析页面html文本或者其他文件</li><li>浏览器渲染页面</li><li>请求完成</li></ol><p><strong>域名解析过程：</strong></p><ol><li>查询浏览器缓存的DNS解析记录，如果有，返回，否则进入2</li><li>查询本地缓存，本机Hosts文件，是否配置域名解析，如果有返回，否则进入3</li><li>查询本地服务器是否有缓存，如果有返回，否则进入4</li><li>查询本地DNS解析服务器，查询是否有记录，否则，本地DNS解析服务器去请求根DNS服务器。</li><li>根DNS服务器有解析记录的话就返回给本地DNS服务器，然后DNS服务器返回，否则进行递归查询。</li></ol><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP报文的组成部分：</p><ol><li>请求报文<ol><li>请求行</li><li>请求头</li><li>请求主体</li></ol></li><li>响应报文<ol><li>状态行</li><li>消息头</li><li>响应主题</li></ol></li></ol><h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a><strong>常见状态码</strong></h5><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009193628.png" alt="状态码"></p><h5 id="什么是长连接、短连接？"><a href="#什么是长连接、短连接？" class="headerlink" title="什么是长连接、短连接？"></a><strong>什么是长连接、短连接？</strong></h5><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h5 id="Cookie的作用是什么-和Session有什么区别？"><a href="#Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="Cookie的作用是什么?和Session有什么区别？"></a>Cookie的作用是什么?和Session有什么区别？</h5><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p><strong>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</strong></p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h5 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h5><p><strong>端口</strong> ：HTTP的URL由“http:&#x2F;&#x2F;”起始且默认使用端口80，而HTTPS的URL由“https:&#x2F;&#x2F;”起始且默认使用端口443。</p><p>安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul><h5 id="Https请求过程："><a href="#Https请求过程：" class="headerlink" title="Https请求过程："></a>Https请求过程：</h5><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201009194303.webp" alt="img"></p><blockquote><p>1、浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。<br>2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。<br>3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。<em>（注释：证书包括以下这些内容：1. 证书序列号。2. 证书过期时间。3. 站点组织名。4. 站点DNS主机名。5. 站点公钥。6. 证书颁发者名。7. 证书签名。因为证书就是要给大家用的，所以不需要加密传输）</em><br>4、浏览器进入数字证书认证环节，这一部分是浏览器内置的 TSL 完成的：<br>4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。<br>4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面 Bob 和 Susan 的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。<br>4.3 浏览器生成一个随机数 R，并使用网站公钥对 R 进行加密。<br>5、浏览器将加密的 R 传送给服务器。<br>6、服务器用自己的私钥解密得到 R。<br>7、服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。<br> 8、浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络八股文</title>
    <link href="/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h6 id="1-OSI有哪几层，这七层分别有什么作用？"><a href="#1-OSI有哪几层，这七层分别有什么作用？" class="headerlink" title="1.OSI有哪几层，这七层分别有什么作用？"></a>1.OSI有哪几层，这七层分别有什么作用？</h6><ol><li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</li><li>表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密</li><li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机 制，如服务器验证用户登录便是由会话层完成的</li><li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等</li><li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的 传输</li><li>数据链路层（帧）：将物理层的比特流数据封装成帧，提供简单的差错监测</li><li>物理层（比特流）：设备之间比特流的传输，简单的传送01比特</li></ol><h6 id="2-ARP的作用？"><a href="#2-ARP的作用？" class="headerlink" title="2.ARP的作用？"></a>2.ARP的作用？</h6><p>  ARP为IP 地址到对应的硬件地址提供动态映射。 </p><h6 id="3-点对点链路使用ARP吗？"><a href="#3-点对点链路使用ARP吗？" class="headerlink" title="3.点对点链路使用ARP吗？"></a>3.点对点链路使用ARP吗？</h6><p>  点对点链路不使用<a href="https://baike.baidu.com/item/ARP/609343">ARP</a>协议，因为在设置这些链路时，网络设备已获得了链路两端的MAC地址，不需要ARP协议来实现IP地址和不同网络硬件地址的动态映射。</p><h6 id="4-ARP高效运行的关键是什么？"><a href="#4-ARP高效运行的关键是什么？" class="headerlink" title="4.ARP高效运行的关键是什么？"></a>4.ARP高效运行的关键是什么？</h6><p>  关键是每个主机上都有一个ARP的高速缓存。 </p><h6 id="5-数据链路层MTU的最大值和最小值是多少？"><a href="#5-数据链路层MTU的最大值和最小值是多少？" class="headerlink" title="5.数据链路层MTU的最大值和最小值是多少？"></a>5.数据链路层MTU的最大值和最小值是多少？</h6><p>  最小MTU为64字节，最大MTU为1500 字节。</p><h6 id="6-如何理解IP协议的不可靠和无连接。"><a href="#6-如何理解IP协议的不可靠和无连接。" class="headerlink" title="6.如何理解IP协议的不可靠和无连接。"></a>6.如何理解IP协议的不可靠和无连接。</h6><p>  不可靠：指的是不能保证数据报能成功地到达目的地。 发生错误时候，丢弃该数据包，发送ICMP消息给信源端。 可靠性由上层提供。<br>  无连接：IP不维护关于后续数据报的状态信息。 体现在，IP数据可以不按顺序发送和接收。A发送连续的数据报，到达B不一定是连续的， 来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。 </p><h6 id="7-IP-与-ICMP，IGMP，TCP，UDP-的首部校验和有什么区-别与共同点？"><a href="#7-IP-与-ICMP，IGMP，TCP，UDP-的首部校验和有什么区-别与共同点？" class="headerlink" title="7.IP 与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区 别与共同点？"></a>7.IP 与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区 别与共同点？</h6><p>  共同点：用到的算法都是一样的。<br>  区别：IP计算的时候没有将数据包括在内。 ICMP，IGMP，TCP，UDP同时覆盖首部和数据检验码。 </p><h6 id="8-如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？"><a href="#8-如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？" class="headerlink" title="8.如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？"></a>8.如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？</h6><p>  结果取决于该IP 数据报是由主机产生的还是被转发的。 如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。 如果是被转发的数据报，就给原始发送一份ICMP主机不可达的差错报文。 </p><h6 id="9-ICMP的分类和作用。"><a href="#9-ICMP的分类和作用。" class="headerlink" title="9.ICMP的分类和作用。"></a>9.ICMP的分类和作用。</h6><p>  ICMP分为两类，一类是ICMP查询报文，另一类是ICMP差错报文 。主要传递一些差错报文和其他需要注意的信息。 </p><h6 id="10-ICMP的主机不可达报文是在什么情况下发出的？"><a href="#10-ICMP的主机不可达报文是在什么情况下发出的？" class="headerlink" title="10.ICMP的主机不可达报文是在什么情况下发出的？"></a>10.ICMP的主机不可达报文是在什么情况下发出的？</h6><p>  三层设备（路由器）给该主机寻路时，没有找到相应路径，向源IP发回ICMP主机不可达 </p><h6 id="11-什么情况不会导致产生ICMP差错报文？"><a href="#11-什么情况不会导致产生ICMP差错报文？" class="headerlink" title="11.什么情况不会导致产生ICMP差错报文？"></a>11.什么情况不会导致产生ICMP差错报文？</h6><p>  1） ICMP差错报文。<br>  2） 目的地址是广播地址或者多播地址的IP数据报。<br>  3） 链路层广播的数据报<br>  4） 不是IP 分片的第一片<br>  5） 源地址不是单个主机的数据包。 </p><h6 id="12-UDP和TCP-的简单介绍。"><a href="#12-UDP和TCP-的简单介绍。" class="headerlink" title="12.UDP和TCP 的简单介绍。"></a>12.UDP和TCP 的简单介绍。</h6><p>  UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。<br>  TCP是面向字节流，应用程序产生的全体数据与真正发送的单个IP数据包可能没什么联系。</p><h6 id="13-UDP的校验和是怎么计算的？"><a href="#13-UDP的校验和是怎么计算的？" class="headerlink" title="13.UDP的校验和是怎么计算的？"></a>13.UDP的校验和是怎么计算的？</h6><p>  UDP的校验和要计算首部和数据部分。首部还包括伪首部。 如果检验和有错，则UDP数据报被悄悄丢弃，不产生任何差错报文。 </p><h6 id="14-TCP通过哪些方式来保证可靠性？"><a href="#14-TCP通过哪些方式来保证可靠性？" class="headerlink" title="14.TCP通过哪些方式来保证可靠性？"></a>14.TCP通过哪些方式来保证可靠性？</h6><p>  1） 应用数据被分割成TCP认为最适合发送的数据块。<br>  2） 确认机制，发送报文后，等待确认。<br>  3） 超时重传，没有收到确认，将重发数据段。<br>  4） 保持它首部和数据的校验和。确认数据的准确性。<br>  5） 排序，丢弃重复的，流量控制。 </p><h6 id="15-TCP与UDP的概念相互的区别及优劣-？"><a href="#15-TCP与UDP的概念相互的区别及优劣-？" class="headerlink" title="15.TCP与UDP的概念相互的区别及优劣 ？"></a>15.TCP与UDP的概念相互的区别及优劣 ？</h6><p>  \1. TCP面向连接，UDP无连接<br>  \2. TCP面向字节流，UDP面向数据报<br>  \3. TCP提供可靠传输服务（数据顺序、正确性），UDP尽最大努力交付，不可靠<br>  \4. TCP协议传输速度慢，UDP协议传输速度快<br>  \5. TCP协议对系统资源要求多（头部开销大），UDP协议要求少 </p><h6 id="16-画出TCP通信从连接到释放连接的全过程？"><a href="#16-画出TCP通信从连接到释放连接的全过程？" class="headerlink" title="16.画出TCP通信从连接到释放连接的全过程？"></a>16.画出TCP通信从连接到释放连接的全过程？</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUNGZ2bi5qcGc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h6 id="17-为什么要三次握手？"><a href="#17-为什么要三次握手？" class="headerlink" title="17.为什么要三次握手？"></a>17.为什么要三次握手？</h6><p>  三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。同时，三次握手还可以避免两次握手情况下会出现的资源浪费（已过期的连接请求报文突然又传送到服务器，因而产生错误）。</p><h6 id="18-为什么要设置TIME-WAIT？为什么TIME-WAIT是两倍的MSL（IP数据报能够在因特网上存活的最长时间）？"><a href="#18-为什么要设置TIME-WAIT？为什么TIME-WAIT是两倍的MSL（IP数据报能够在因特网上存活的最长时间）？" class="headerlink" title="18.为什么要设置TIME_WAIT？为什么TIME_WAIT是两倍的MSL（IP数据报能够在因特网上存活的最长时间）？"></a>18.为什么要设置TIME_WAIT？为什么TIME_WAIT是两倍的MSL（IP数据报能够在因特网上存活的最长时间）？</h6><p>  因为如果第四次挥手主动方（先请求释放连接的一方）发送的确认在网络中丢失了，那么在两倍MSL时间内能够收到被动方（后请求释放连接的一方）重新发送的释放连接请求。由于被动方超时重发之前需要一倍MSL，发送后最多需要一倍MSL到达主动方。</p><h6 id="19-TCP的拥塞控制机制？"><a href="#19-TCP的拥塞控制机制？" class="headerlink" title="19.TCP的拥塞控制机制？"></a>19.TCP的拥塞控制机制？</h6><p>  慢启动（慢开始）： 1. 慢开始不是指cwnd的增长速度慢（指数增长），而是指TCP开始发送设置cwnd&#x3D;1。  2. 思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大 逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时 拥塞窗口大小是以字节为单位的。 3. 为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限（ssthresh状态变量）  当cnwd＜ssthresh，使用慢开始算法  当cnwd&#x3D;ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法  当cnwd＞ssthresh，使用拥塞避免算法<br>  拥塞避免： 1. 拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增 长，使网络比较不容易出现拥塞。  2. 思路：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一。<br>  无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有 收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做 拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。 如图所示： </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUNUJSSi5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>  快速重传： 1. 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及 早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发 送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设 置的重传计时器时间到期。 2. 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网 络的吞吐量。<br>  快速恢复： 1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。 但是接下去并不执行慢开始算法。  2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小， 然后执行拥塞避免算法。 </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUNTRSSC5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h6 id="20-DNS的概念，用途？"><a href="#20-DNS的概念，用途？" class="headerlink" title="20.DNS的概念，用途？"></a>20.DNS的概念，用途？</h6><p>  域名解析，将域名转换成 ip地址，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 ip 地址。</p><h6 id="21-GET、POST区别？"><a href="#21-GET、POST区别？" class="headerlink" title="21.GET、POST区别？"></a>21.GET、POST区别？</h6><p>  在客户机和服务器之间进行请求-响应时，两种最常被用到的请求方法是：GET 和 POST。GET：从指定的资源请求数据。POST<em>：</em>向指定的资源提交要被处理的数据。<br>  1.GET是从服务器上获取数据，POST是向服务器提交数据。<br>  2.请求参数位置：GET在HTTP包头，POST在HTTP正文。<br>  本质上都是使用的TCP传输协议，只不过在应用层规定了不同的请求格式以适应不同的场景。</p><h6 id="22-HTTP和HTTPS的区别？"><a href="#22-HTTP和HTTPS的区别？" class="headerlink" title="22.HTTP和HTTPS的区别？"></a>22.HTTP和HTTPS的区别？</h6><p>  http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>  http的信息是明文传输，https是具有安全性的ssl加密传输协议。<br>  https需要到证书颁发机构申请证书，而http不用。</p><h6 id="23-一次完整的HTTP请求过程？"><a href="#23-一次完整的HTTP请求过程？" class="headerlink" title="23.一次完整的HTTP请求过程？"></a>23.一次完整的HTTP请求过程？</h6><p>  DNS域名解析，得到对应的IP地址<br>  根据这个IP地址找到对应服务器<br>  TCP三次握手建立连接<br>  发起HTTP请求<br>  服务器响应HTTP请求<br>  浏览器得到html代码<br>  浏览器解析html代码的资源<br>  浏览器对页面进行渲染呈现给用户<br>  释放TCP连接</p><h6 id="24-Socket是什么？（网络编程内容）"><a href="#24-Socket是什么？（网络编程内容）" class="headerlink" title="24.Socket是什么？（网络编程内容）"></a>24.Socket是什么？（网络编程内容）</h6><p>  套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I&#x2F;O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。建立网络通信连接至少要一对端口号(socket)。socket本质是API，对TCP&#x2F;IP的封装。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUNVhGUy5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUSXB5bi5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzAzLzIzLzhUSVBlMC5wbmc?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h6 id="25-说一下几种I-x2F-O模型（linux）？（网络编程内容）"><a href="#25-说一下几种I-x2F-O模型（linux）？（网络编程内容）" class="headerlink" title="25.说一下几种I&#x2F;O模型（linux）？（网络编程内容）"></a>25.说一下几种I&#x2F;O模型（linux）？（网络编程内容）</h6><p>  推荐博客<a href="https://www.cnblogs.com/javalyy/p/8882066.html">https://www.cnblogs.com/javalyy/p/8882066.html</a><br>  1）同步阻塞I&#x2F;O：当用户进程需要进行I&#x2F;O操作时，会执行一个系统调用（recvform），在内核等待数据和数据拷贝到用户内存的时候都处于阻塞状态。<br>  2）同步非阻塞I&#x2F;O：它与同步阻塞I&#x2F;O的区别就是当数据没有准备好的时候不会一直阻塞，而是直接返回，然后不停的去询问数据是否准备完毕（轮询）。准备完毕拷贝数据的过程仍然阻塞。<br>  3）I&#x2F;O多路复用：调用select&#x2F;epoll等待多个socket，从而实现对多个I&#x2F;O端口的监听，其中任意一个端口数据到达了就通知用户进程，之后再调用系统调用recvform，将数据从内核态拷贝到用户进程，这个过程仍然是阻塞的。<br>  4）信号驱动I&#x2F;O：应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，内核等到数据到达时应向应用进程发送信号，之后用户进程执行系统调用拷贝数据。<br>  5）异步I&#x2F;O：用户进程执行系统调用之后立即返回，可以去做其他事情，然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，会给用户进程发送一个signal，告诉它read操作完成了。</p><h6 id="26-说一下Select、poll与epoll的区别？（网络编程内容）"><a href="#26-说一下Select、poll与epoll的区别？（网络编程内容）" class="headerlink" title="26.说一下Select、poll与epoll的区别？（网络编程内容）"></a>26.说一下Select、poll与epoll的区别？（网络编程内容）</h6><p>  1）进程最大连接数：select：单个进程所能打开的最大连接数由FD_SETSIZE限制，默认比较小。Poll：本质与select没有区别，但是它没有最大连接数的限制，原因是它基于链表存储。Epoll：没有fd数量限制。<br>  2）FD剧增后到来的I&#x2F;O效率问题：select：每次调用会对连接进行线性便利，所以随着FD的增加会导致遍历速度的线性下降的性能问题。Poll：同select。Epoll：由于epoll是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll不会有性能问题，但是当所有socket都很活跃的情况下，可能会有性能问题。<br>  3）消息传递方式：select：内核需要将消息传递到用户空间，需要内核的拷贝动作。Poll：同select。Epoll：通过内核和用户空间共享一块内存来实现，性能较高。</p><h6 id="27-epoll中ET与LT的区别？（网络编程内容）"><a href="#27-epoll中ET与LT的区别？（网络编程内容）" class="headerlink" title="27.epoll中ET与LT的区别？（网络编程内容）"></a>27.epoll中ET与LT的区别？（网络编程内容）</h6><p>  LT（level triggered）是缺省的工作方式，在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表．<br>  ET (edge-triggered)是高速工作方式，在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。ET模式减少了epoll被重复触发的次数，效率比LT高。</p><h6 id="28-常见的HTTP状态码？"><a href="#28-常见的HTTP状态码？" class="headerlink" title="28.常见的HTTP状态码？"></a>28.常见的HTTP状态码？</h6><p>  1XX：通知。<br>  2XX：成功。<br>    200(“OK”)：一切正常。<br>  3XX：重定向。<br>    301(“Moved Permanently”)：当客户端触发的动作引起了资源URI的变化时发送此响应代码。<br>    304(“Not Modified”)：未修改。客户端希望只返回在指定日期之后修改的资源<br>  4XX：客户端错误。<br>    400(“Bad Request”)：客户端方面的问题。<br>    404(“Not Found”) ：服务器端不知道客户端要请求哪个资源。<br>    409(“Conflict”)：当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。<br>    410(“Gone”)：服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了。<br>  5XX：服务端错误。<br>    500(“Internal Sever Error”)：服务器执行响应过程中发生错误。<br>    501(“Not Implemented”)：服务器不支持请求的功能，无法完成请求。</p><h6 id="29-DNS的查询方式？"><a href="#29-DNS的查询方式？" class="headerlink" title="29.DNS的查询方式？"></a>29.DNS的查询方式？</h6><p>  递归查询：客户机向dns服务器发送请求，DNS服务器会使用一个准确的查询结果回复给客户机，如果DNS服务器本地没有储存查询的DNS信息，那么它会查询其他的DNS服务器，并将查询结果提交给客户机。<br>  迭代查询：客户机向dns服务器发送请求，如果该服务器本地没有储存查询的DNS信息，那么它会告诉客户机另一台DNS服务器的地址，客户机在向这台DNS服务器查询DNS信息，依次循环直到返回结果。</p><h6 id="30-HTTPS如何实现加密传输？"><a href="#30-HTTPS如何实现加密传输？" class="headerlink" title="30.HTTPS如何实现加密传输？"></a>30.HTTPS如何实现加密传输？</h6><p>  使用SSL&#x2F;TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。</p><h6 id="31-TTL指的是什么？"><a href="#31-TTL指的是什么？" class="headerlink" title="31.TTL指的是什么？"></a>31.TTL指的是什么？</h6><p>  TTL是IP数据包在计算机网络中可以转发的最大跳数。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上。每经过一个路由器，路由器都会把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL&#x3D;0的IP包并向IP包的发送者发送 ICMP消息。</p><h6 id="32-traceroute的过程？"><a href="#32-traceroute的过程？" class="headerlink" title="32.traceroute的过程？"></a>32.traceroute的过程？</h6><p>  首先，tracertout首先给目的主机发送一个TTL&#x3D;1的UDP数据报，而经过一个路由器之后TTL减为0，路由器将这个数据报丢弃，然后发送一份主机不可达的ICMP报文给源主机，主机收到这个报文之后就获得了第一个路由器的IP地址，然后继续发送一个TTL&#x3D;2的UDP数据报给目的地址，以此类推。当UDP到达目的主机之后，由于tracertout发送的是端口号很大的UDP数据报，所以到达目的主机的时候，目的主机只能发送一个目的端口不可达的ICMP报文给主机，这时主机收到报文之后就完成了tracertout操作。</p><h6 id="33-什么是半连接状态？"><a href="#33-什么是半连接状态？" class="headerlink" title="33.什么是半连接状态？"></a>33.什么是半连接状态？</h6><p>  三次握手中，主动发起握手的一方不发最后一次ACK，使得服务器端阻塞在SYN_RECV状态。</p><h6 id="34-什么是SYN攻击？"><a href="#34-什么是SYN攻击？" class="headerlink" title="34.什么是SYN攻击？"></a>34.什么是SYN攻击？</h6><p>  半连接攻击（SYN攻击）：会耗尽服务器资源，使得真正的请求无法建立连接。</p><h6 id="35-session和cookies的区别？"><a href="#35-session和cookies的区别？" class="headerlink" title="35.session和cookies的区别？"></a>35.session和cookies的区别？</h6><p>  1）cookie数据存放在客户端，session数据放在服务器上。<br>  2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。<br>  3）session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。<br>  4）不同浏览器对cookie的数据大小限制不同，个数限制也不相同。<br>  5）可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。</p><h6 id="36-time-wait的原因是什么，如果有大量time-wait会发生什么，该怎么解决"><a href="#36-time-wait的原因是什么，如果有大量time-wait会发生什么，该怎么解决" class="headerlink" title="36.time_wait的原因是什么，如果有大量time_wait会发生什么，该怎么解决?"></a>36.time_wait的原因是什么，如果有大量time_wait会发生什么，该怎么解决?</h6><p>  原因：1）为实现TCP的可靠释放。2）为使旧的数据包在网络因过期而消失。<br>  当请求量比较大的时候，而且所有的请求都是短连接，就会产生大量的time_wait。如果有大量time_wait会使得资源（客户端IP地址和端口）被浪费。<br>  服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</p><h6 id="37-close-wait-状态出现在什么时候？"><a href="#37-close-wait-状态出现在什么时候？" class="headerlink" title="37.close_wait 状态出现在什么时候？"></a>37.close_wait 状态出现在什么时候？</h6><p>  出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket连接，但是我方忙于读或写，没有关闭连接。</p><h6 id="38-什么情况下收到三个连续的重复确认？"><a href="#38-什么情况下收到三个连续的重复确认？" class="headerlink" title="38.什么情况下收到三个连续的重复确认？"></a>38.什么情况下收到三个连续的重复确认？</h6><p>  收到的包的编号乱序会导致收到三个连续的重复确认。</p><h6 id="39-TCP报文接收端怎样保证有序？"><a href="#39-TCP报文接收端怎样保证有序？" class="headerlink" title="39.TCP报文接收端怎样保证有序？"></a>39.TCP报文接收端怎样保证有序？</h6><p>  TCP会将报文编号，如果发现接受的报文失序，那么接收方会将收到的报文暂时缓存，等到失序报文到达再将报文重新排列好。</p><h6 id="40-TCP丢包怎么解决？从客户端和服务器的角度来谈。"><a href="#40-TCP丢包怎么解决？从客户端和服务器的角度来谈。" class="headerlink" title="40.TCP丢包怎么解决？从客户端和服务器的角度来谈。"></a>40.TCP丢包怎么解决？从客户端和服务器的角度来谈。</h6><p>  接收方若收到失序的报文，会对失序的报文发送重复确认。<br>  发送方发送报文段时，会创建一个特定报文段的重传计时器，若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位。当收到三次对报文的重复确认后，会执行快速重传&#x2F;快速恢复。</p><h6 id="41-三次握手涉及到的api？"><a href="#41-三次握手涉及到的api？" class="headerlink" title="41.三次握手涉及到的api？"></a>41.三次握手涉及到的api？</h6><p>  客户端函数调用顺序：socket、connect、read&#x2F;write、close<br>  服务端函数调用顺序：socket、bind、listen、accept、read&#x2F;write、close</p><h6 id="42-TCP和UDP的应用场景？"><a href="#42-TCP和UDP的应用场景？" class="headerlink" title="42.TCP和UDP的应用场景？"></a>42.TCP和UDP的应用场景？</h6><p>  TCP适用于对效率要求相对较低，但对准确性要求相对较高的，或者是有连接的场景。<br>  UDP适用于对效率要求较高，对准确性要求相对较低的场景。</p><h6 id="43-TCP流量控制和拥塞控制的区别？"><a href="#43-TCP流量控制和拥塞控制的区别？" class="headerlink" title="43.TCP流量控制和拥塞控制的区别？"></a>43.TCP流量控制和拥塞控制的区别？</h6><p>  流量控制是为了解决发送方和接收方速度不同导致的数据丢失问题，当发送方发送的太快，接收方来不及接受就会导致数据丢失，是点对点通信量的控制。流量控制用滑动窗口的形式解决问题。<br>  拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。拥塞问题是一个全局性的问题,涉及到所有的主机、所有的路由器、以及与降低网络传输性能有关的所有因素。通过维护一个拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度。注意考虑到接受方的接收能力，发送窗口可能小于拥塞窗口，两者并不等价。</p><h6 id="44-http无状态怎么实现用户登录？"><a href="#44-http无状态怎么实现用户登录？" class="headerlink" title="44.http无状态怎么实现用户登录？"></a>44.http无状态怎么实现用户登录？</h6><p>  通过cookie和session。</p><h6 id="45-局域网内的一次访问网站的流程？"><a href="#45-局域网内的一次访问网站的流程？" class="headerlink" title="45.局域网内的一次访问网站的流程？"></a>45.局域网内的一次访问网站的流程？</h6><p>  首先PC要做域名解析，会向DNS服务器发送请求<br>  而DNS服务器一般和PC不在同一子网里，所以要把数据包发给网关<br>  为了把数据包发给网关，要知道网关的MAC地址，所以向广播ARP数据包<br>  得到了网关的MAC地址可将IP数据包发给网关，收到后可能会进行网络地址转换<br>  当数据包被转发出去之后，就会通过IP路由协议转发到DNS服务器<br>  DNS服务器会回复网站的IP地址<br>  之后就可以把HTTP请求封装到TCP数据包中通过IP包进行交互</p><h6 id="46-为什么挥手不可以三次？"><a href="#46-为什么挥手不可以三次？" class="headerlink" title="46.为什么挥手不可以三次？"></a>46.为什么挥手不可以三次？</h6><p>  因为如果三次就意味着一方关闭连接，另一方也必须被迫关闭连接。但是有可能另一方还有数据未发送则无法实现。</p><h6 id="47-http连接之后服务机内部都会干什么事？"><a href="#47-http连接之后服务机内部都会干什么事？" class="headerlink" title="47.http连接之后服务机内部都会干什么事？"></a>47.http连接之后服务机内部都会干什么事？</h6><p>  (1 建立连接——接受一个客户端连接， 或者如果不希望与这个客户端建立连接， 就将其关闭。<br>  (2 接收请求——从网络中读取一条 HTTP 请求报文。<br>  (3 处理请求——对请求报文进行解释， 并采取行动。<br>  (4 访问资源——访问报文中指定的资源。<br>  (5 构建响应——创建带有正确首部的 HTTP 响应报文。<br>  (6 发送响应——将响应回送给客户端。<br>  (7 记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。</p><h6 id="48-说一下TCP粘包，拆包？"><a href="#48-说一下TCP粘包，拆包？" class="headerlink" title="48.说一下TCP粘包，拆包？"></a>48.说一下TCP粘包，拆包？</h6><p>  TCP是以流动的方式传输数据，传输的最小单位为一个报文段。也就是说发送端发送的消息如果太长了就会被切割成若干个报文段，然后以报文段的形式发送，同时如果消息比较短那么发送方就会先将消息缓存在缓冲区，直到达到可以发送的长度之后再发送。那么如果发送方发送的两条完整的消息在一个数据包中，被接收方接收之后没办法知道第一条消息从哪里结束，这种情况就叫做TCP粘包。同样，如果第一条消息只有一部分在第一个数据包中，剩下的部分在第二个数据包中，那么这种情况就叫做TCP拆包。</p><h6 id="49-粘包，拆包的解决办法？"><a href="#49-粘包，拆包的解决办法？" class="headerlink" title="49.粘包，拆包的解决办法？"></a>49.粘包，拆包的解决办法？</h6><p>  1）使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。<br>  2）设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。<br>  3）设置消息边界，服务端从网络流中按消息编辑分离出消息内容。</p><h6 id="50-什么叫字节流，什么叫数据报？"><a href="#50-什么叫字节流，什么叫数据报？" class="headerlink" title="50.什么叫字节流，什么叫数据报？"></a>50.什么叫字节流，什么叫数据报？</h6><p>  字节流就是散乱的一堆数据，接收方每次取多少由自己决定，而数据报指的是发送方发送多少接收方就要原封不动地接收多少。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中的事务</title>
    <link href="/2022/07/01/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/07/01/Mysql%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><p>之前对事务的了解仅限于知道要么全部执行，要么全部不执行，能背出 ACID 和隔离级别，知其然但不知其所以然，现在觉得非常有必要系统学一下，关于事务，关于 LBCC，关于 MVCC，关于死锁 ……</p><h2 id="并发的问题"><a href="#并发的问题" class="headerlink" title="并发的问题"></a>并发的问题</h2><p>所谓 <strong>事务</strong> 是用户定义的一个 <strong>数据库操作序列</strong>， 这些操作要么全做，要么全不做，是一个不可分割的工作单位，在关系型数据库中，一个事务可以是一条 SQL 语句，一组 SQL 语句或者是整个程序，事务的开始和结束由用户显示控制，如果用户没有显式定义事务，则由 DBMS 按默认规定自动划分事务，如在 MySQL 中默认 <code>autocommit</code> 为 <code>ON</code> 则开启事务自动提交，每条没有显式定义事务的 SQL 语句都会被当作一个单独的事务并自动提交：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; show session variables like &#x27;autocommit&#x27;;</span><br><span class="hljs-section">+---------------+-------+</span><br><span class="hljs-section">| Variable_name | Value |</span><br><span class="hljs-section">+---------------+-------+</span><br><span class="hljs-section">| autocommit    | ON    |</span><br><span class="hljs-section">+---------------+-------+</span><br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p>事务有四个特性，即 ACID：</p><ul><li><strong>A（Atomicity）: 原子性</strong> ，事务是数据库的基本工作单位，事务中包含的诸操作要么都做，要么都不做。</li><li><strong>C（Consistency）: 一致性</strong>，事务的执行结果必须使数据库从一个一致性状态转换到另一个一致性状态，所谓一致性状态是指数据库中因该只包含成功事务执行的结果，如果一个事务在执行过程中被迫中断，但这个未完成的事务对数据库的部分修改已经写入物理数据库，这时数据库就处于一种 “不正确” 的状态，或者称处于 “不一致” 的状态。</li><li><strong>I （Isolation）: 隔离性</strong>，一个事务的执行不能被其他事务所干扰，即一个事务内部操作所使用的数据对其他并发的事务应该是隔离的，所有并发执行的事物之间不能相互干扰。</li><li><strong>D（Durability）：持久性</strong>，一个事务一旦提交，他对数据的操作就应该是持久的，接下来的其他操作或故障不应该对他有任何影响。</li></ul><p>只有保证了事务的 ACID 特性，对数据库的操作才能是安全的，因此，不管是 LDCC 还是 MVCC，其核心目的都是保证事务的 ACID 特性。可能破坏事务 ACID 特性的因素包括：</p><ol><li>多个事务并行运行时，不同事物的操作交叉执行。</li><li>事务执行过程中被强制停止。</li></ol><p>上面两个因素分别对应事务处理的两类技术：并发控制和数据库恢复技术，事务被强制终止一般由事物内部故障，系统故障等造成，发生类似故障时，一般采用日志文件恢复等方法使数据库恢复到上一个一致性状态，这里着重研究由并发导致的 ACID 被破坏的情况和解决方案。</p><p>并发导致的数据不一致包括：<strong>丢失修改，脏读，不可重复读，幻读</strong>。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608282484478-1608282484444.png" alt="img"></p><p>如上图，两个并发的事务 T1, T2 同时读表中的某条记录 total 得到 16， 并且对其进行修改，最终造成后提交的事务 T2 的修改结果覆盖了先提交的事务 T1 的修改结果，这种现象叫做丢失修改。</p><p>针对丢失修改，还有一种情况，就是如果 T2 在修改 total 之后发生异常进行了回滚，就会导致 total 值重置为 16，这种现象被称为 <strong>回滚覆盖</strong>，而第一种情况被称为<strong>提交覆盖</strong></p><h3 id="不可重复读和幻读"><a href="#不可重复读和幻读" class="headerlink" title="不可重复读和幻读"></a>不可重复读和幻读</h3><p>事务 T1 读取数据后，T2 对该数据进行了更新操作， 导致 T1 无法再次读到前一次读取的结果，这种现象叫做不可重复读，导致不可重复读的原因包括下面三种情况：</p><ol><li>T1 读取某一数据后，T2 对其进行了修改，导致 T1 再次读该数据时，得到与之前不一致的值。</li><li>T1 读取某些数据后，T2 删除了其中的某些数据，当 T1 再次读这些数据时，发现之前的一些数据神秘消失了。</li><li>T1 读取某些数据后，T2 向其中插入了一些数据，当 T1 再次读这些数据时，发现莫名其妙多了一些数据。</li></ol><p>后两种情况也被常常称为 <strong>幻读</strong>， 幻读与第一种情况的不同在于：</p><ol><li>幻读往往在读取某一范围的数据时产生。</li><li>幻读是因为其他事务执行了插入或删除语句导致的，但第一种情况一般是执行更新语句导致的。</li></ol><blockquote><p>为了方便，不可重复读一般只指第一种情况，幻读指后两种情况。</p></blockquote><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>事务 T1 修改了某条记录，T2 读取到了 T1 未提交的这条记录，但 T1 由于某些原因被回滚了，这就导致了 T2 读取到的数据与数据库中的数据不一致，即脏数据。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>一致性问题</th><th>产生过程</th><th>一致性问题</th><th>产生原因</th></tr></thead><tbody><tr><td>脏读</td><td><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608284287946-1608284287895.png" alt="img"></td><td>不可重读</td><td><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1608285005116-1608285005114.png" alt="img"></td></tr><tr><td>幻读</td><td><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1608284649653-1608284649645.png" alt="img"></td><td>丢失修改</td><td><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608284927065-1608284927058.png" alt="img"></td></tr></tbody></table><p>导致上述四种不一致的原因就是破坏了事务的隔离性，进而导致一致性被破坏，而保证数据隔离性的方法就是<strong>使用正确的方式调度并发操作</strong>， 但有的时候，为了性能，我们有允许牺牲一部分隔离性，比如对有些数据量很大，少量脏数据对结果影响很小或影响可以接收时，我们可以降低一致性要求以减少系统开销，这就是数据库的<strong>隔离级别</strong>。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交 Read uncommitted</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交 Read committed</td><td></td><td>可能</td><td>可能</td></tr><tr><td>可重复读 Repeatable read</td><td></td><td></td><td>可能</td></tr><tr><td>串行化 Serializable</td><td></td><td></td><td></td></tr></tbody></table><h2 id="并发控制技术"><a href="#并发控制技术" class="headerlink" title="并发控制技术"></a>并发控制技术</h2><p>隔离级别只是定义了在不同的级别下应该保证哪些一致性，具体实现这些隔离级别的方法有很多，如传统的基于锁的并发控制（LBCC），还有一些无锁并发控制方案，如时间戳（timestamp), 乐观控制法（scheduler），多版本并发控制（MVCC）等，我们主要探索基于锁的并发控制（LBCC）和多版本并发控制（MVCC）</p><h3 id="基于锁的并发控制（LBCC）"><a href="#基于锁的并发控制（LBCC）" class="headerlink" title="基于锁的并发控制（LBCC）"></a>基于锁的并发控制（LBCC）</h3><p>所谓封锁就是事务在某个数据对象进行操作之前先申请锁，对该对象加锁后，该事务就拥有了一定的对该对象的控制，在该事务释放该锁前，其他事务不能操作此数据对象。</p><p>从锁的模式来看，锁可以分为共享锁和排它锁，共享锁又称为读锁（S 锁），排它锁又称为写锁（X锁）。</p><ul><li>X 锁：若事务 T 对数据对象 A 加上了 X 锁，则只允许 T 读取和修改 A， 其他任何事务不得再对 A加任何类型的锁，直到 T 释放锁，。</li><li>S 锁：若事务 T 对数据对象 A 加上了 S 锁，则 T 和其他事务都可以可以读 A，同时其他事务可以继续申请 A 的 S 锁，但是直到所有事务都释放 A 的 S 锁为止（所有事务并不包括自己），A 是不允许修改的。这就意味着如果只有一个事务对 A 添加了 S 锁，那他自己是可以修改数据的。</li></ul><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><ul><li><strong>一级封锁协议：</strong> 事务 T 在修改数据 R之前必须对其加 X 锁，直到事务提交或回滚才释放锁，一级封锁协议可以防止丢失修改，一级封锁协议只在写数据时加锁，读数据时并不需要获取锁，所以它无法解决脏读，幻读，不可重复读。</li><li><strong>二级封锁协议：</strong>要求在一级封锁协议的基础上，读数据前必须加 S 锁，读完即可立刻释放 S 锁。因为对数据 A 加 X 锁后，不允许其他事务再申请其他锁，所以事务要想获得 S 锁读，就必须等持有 X 锁的事务写完提交或回滚，这样就可以避免脏读，但由于二级封锁协议允许读完后立刻释放 S 锁，无法保证下一次读时数据不被修改，所以所以它不能保证可重复读（包括幻读）。</li><li><strong>三级封锁协议：</strong>要求在一级封锁协议的基础上，读数据前必须加 S 锁，直到事务结束才释放。该协议可以解决不可重复读（包括幻读）的问题。</li></ul><h4 id="死锁，活锁"><a href="#死锁，活锁" class="headerlink" title="死锁，活锁"></a>死锁，活锁</h4><p>死锁和活锁是使用 LBCC 解决一致性问题时必须考虑的问题：</p><ul><li>活锁：如果 T1 封锁了 R，T2 请求 R 的锁，这时 T2 应该等待，然后 T3 也请求 R 并等待，这时 T1 释放了 R 的锁，但该锁被 T3 获得，在这过程中， T4 也请求 R， T3 释放锁后锁又被 T4 获得…… 这导致 T2 一直无法获得锁，这种某个事务陷入饥饿的状态现象叫做活锁，避免活锁的简单策略是先来先服务。</li><li>死锁：如果 T1 封锁了 R1, T2 封锁了 R2, 然后 T1 又来申请 R2, T2 又来申请 R1, 这会造成 T1 T2 相互等待永远无法结束的局面，形成死锁。</li></ul><h5 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h5><p>死锁出现的原因是两个事务都已经封锁了一些数据对象，然后都去请求已经被对方锁定的数据对象，预防死锁就是要想办法破坏死锁产生的条件，通常使用一次封锁法和顺序封锁法解决：</p><ul><li>一次封锁法：一个事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。但由于数据库中的数据并不是一尘不变的，我们往往很难准确知道要用哪写数据，为了实现一次封锁，就不得不扩大封锁范围，将可能的数据全部加锁，这会造成系统并发度降低，影响性能。</li><li>顺序封锁法：预先对数据对象规定一个封锁顺序，所有事物按这个顺序实施封锁，但这样同样存在问题：<ul><li>数据库中的数据对象很多，要维护这么多对象的封锁顺序并不容易。</li><li>谁应该先被封锁，谁应该后被封锁，关于这个顺序很难得到一个最优解。</li></ul></li></ul><h5 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h5><p>上面个两种预防死锁的办法在现实中可行性很低，所以DBS通常采用诊断并解除死锁的办法解决死锁问题。</p><p>诊断死锁：</p><ol><li>超时法：如果一个事务的等待时间超过特定期限，就认为其发生了死锁。</li><li>等待图法：将事务和其等待的数据对象以有向图的形式组织，检测图中是否有回路，发现回路即为死锁。</li></ol><p>解除死锁：</p><ul><li>发现死锁后，我们往往会选择一个处理死锁代价最小的事务，将其撤销以释放他持有的所有锁，当然，对撤销事务的数据修改操作必须加以修复。</li></ul><h4 id="可串行化调度和两段锁协议"><a href="#可串行化调度和两段锁协议" class="headerlink" title="可串行化调度和两段锁协议"></a>可串行化调度和两段锁协议</h4><p>可串行化调度：</p><ul><li>如果多个事务并发执行的结果和按某一次序串行执行这些事务的结果是一样的，就说这种调度是可串行化调度，他是并发事务正确调度的准则。</li></ul><p>两段锁协议（2PL）：</p><ul><li>两段锁协议用来保证调度是可串行化的</li><li>两段锁协议是指所有事务必须分两个阶段对数据项进行加锁和解锁操作。</li><li>在对一个数据项进行读写操作前，必须申请并获得该数据项的封锁。（拓展阶段）</li><li>释放完一个封锁后，事务不再去申请或获取任何其他锁。（收缩阶段）</li></ul><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>加锁时，你可以选择对一个属性值，关系，索引项，整个索引甚至整个数据库加锁，加锁对象的大小叫做锁的粒度，一般来说，粒度越大，并发度越小，系统开销也越小，封锁粒度越小，并发度越高，系统开销也就越大。一个 DBS 应该尽可能兼顾并发度和系统开销，这样显然不能只支持某一粒度的封锁，这种提供多种封锁粒度供不同事务选择的封锁方法叫做<strong>多粒度封锁</strong>。</p><p>多粒度封锁可以由多粒度树描述，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608383818097-1608383818060.png" alt="img"></p><p>多粒度树的根节点是整个数据库，表示最大的数据粒度，叶子节点表示最小的封锁粒度，<strong>多粒度封锁协议</strong> 允许粒度树的每一个节点可以被单独加锁，某一个节点加锁意味着该节点的所有子节点也被加同样的锁，对该节点来说，这个锁属于<strong>显式加锁</strong>，对于其子节点来说，属于<strong>隐式加锁</strong>，他们的效果是一样的。</p><p>显式和隐式加锁看起来是理所当然的，但这会导致一个问题，在对某一数据项加锁时，我们必须保证当前要加的这把锁与其显示假的锁不冲突，同时还要保证与其隐式假的锁不冲突，为此，在加锁前，我们必须要：</p><ol><li>检查数据项有无显示加锁，保证不与其冲突。</li><li>检查数据项的所有父节点，保证不与其隐式加锁冲突。</li><li>检查数据项的所有子节点，保证加锁后由于本次加锁获得隐式锁的数据项不与其原来的锁冲突。</li></ol><p>这样一来，每次加锁我们不得不遍历整个粒度树，这种效率是非常低下的，为此，我们引入了一种新锁：<strong>意向锁</strong></p><p>意向锁用于提升加锁效率，无法手动创建，它的含义是如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁，对任意节点加锁时，必须先对它的上层节点加意向锁。有三种常用的意向锁，他们分别是：意向共享锁（IS 锁），意向排它锁（IX锁），共享意向排它锁（SIX锁）：</p><ul><li>IS 锁：表示其子节点准备加 S 锁</li><li>IX 锁：表示其子节点准备加 X 锁</li><li>SIX 锁：如果对一个数据对象加 SIX 锁，表示对他加 S 锁，在家 IX 锁，例如对某表加 SIX 锁，表示该事务要通过 S 锁读整个表，同时还要更新个别元组（IX锁）。</li></ul><p>根据上面的描述，我们可以得出以下的锁强度偏序关系图和数据锁的相容矩阵：</p><blockquote><p>锁强度表示一个锁对其他锁的排斥程度</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608385625730-1608385625687.png" alt="img"></p><table><thead><tr><th></th><th>X</th><th>SIX</th><th>IX</th><th>S</th><th>IS</th><th>-</th></tr></thead><tbody><tr><td>X</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td></tr><tr><td>SIX</td><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>IX</td><td>F</td><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td></tr><tr><td>S</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>IS</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>-</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table><p>规律：对于意向锁来说使用强度更高的锁来替换强度低的锁是安全的。</p><p>意向锁如何提高加锁效率？</p><p>如果某一时刻，数据库中数据对象的锁持有情况如下图粒度树所示，对表 T1 加了 S 锁，其父节点对应加了 IS 锁，T1 的子节点也隐式获得了 S 锁（当然所有节点也隐式获得了 IS 锁，所有隐式锁都未画出）</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608387136508-1608387136506.png" alt="img"></p><p>如果现在我们希望更新记录 R1，根据封锁协议，就必须对 R1 添加 X 锁，对其父节点加 IX 锁，这时只需要检查 T1 和 DB 的锁是否与之不相容，T1 持有 S 锁，与 X 锁不相容，调度器会阻止加锁。</p><p>相反，如果我们只是想对 R1 加 S 锁进行读操作，就需要先对父节点加 IS 锁，T1 持有 S 锁，与 IS 锁相容，再检查 R1 持有的锁是否与 S 锁相容，相容，允许加锁。</p><p>加入意向锁后，我们不需要再去遍历所有子节点便可以判断能否未数据项加锁，可以提高系统并发度，减少加锁解锁开销。</p><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><p>通过 LBCC， 我们可以解决所有的并发不一致问题，那为什么还会有其他并发控制方案呢？归根结底还是基于性能的考虑， LBCC 只是实现了允许并发读，但对于并发读写，写写操作只能串行执行，在读写都很频繁的场景下，并发性能将大大降低，因此，人们才提出各种<strong>无锁并发控制方案</strong>，MVCC 就属于其中一种。</p><p>MVCC 的大概思路是每一个事务都有一个唯一的ID，当某一个事务要修改某行数据时，先将这一行原来的数据做一个快照保存下来，当有其他并发事务也要操作这个事务时，可以操作之前的版本，这样，最新的版本只被写事务维持，不会干扰到读事务，以此实现隔离，MVCC 并没有一个统一的标准，不同 DBS 的实现也不尽相同，下面以 MySQL InnoDB 引擎为例说一下 MVCC 的一个具体流程。</p><h4 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h4><p>既然是 MVCC， 那最重要的就是旧版本的数据要存在，在 MySQL InnoDB 中，这些数据会以 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment">回滚段 （rollback segment）</a>的形式保存在表空间中，更具体来说，他们会被保存在 undo log 中。</p><p>其次，InnoDB 会在所有表中加两个隐藏列 DB_TRX_ID 和 DB_ROLL_PTR，前者占 6 字节，表示插入或更新该行的最后一个事务的事务标识符；后者占 7 个字节，称为回滚指针，指向回滚段的 undo log 记录。</p><blockquote><p>InnoDB 插入的隐藏列还有一个 DB_ROW_ID，会随着新行的插入会单调递增，如果使用了默认自增ID的聚簇索引，索引中就会包含这个列。</p></blockquote><p>每当我们插入或更新一行数据（删除被认为是更新的一种），InnoDB 会为这个事务分配一个唯一单调递增的事务ID，这个 ID会记录在这一行的 DB_TRX_ID 中，表示这一行数据的最新版本。</p><p>如下图，设有一张表 t, 包含两个字段 id 和 name, 它的初始状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608474301120-1608474301111.png" alt="img"></p><p>表示最后插入或修改这条记录的事务 ID 是 100，现在如果有一个新的事务要修改这条记录，设其 ID 为 200，则现在表的状态就会变成下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608475248142-1608475248085.png" alt="img"></p><p>灰色行表示历史版本，被记录在 undo log 中，从最新版本的回滚指针可以找到这条记录的历史版本，这条链表被叫做<strong>版本链</strong>，</p><p>除此之外，当一个事务第一次执行读操作时，会为该事务生成一个一致性视图 read-view, 这个数据结构包含此刻所有活跃着的（未提交的）写事务的事务ID列表和此时DBS分配出去的最大事务号，有了 read-view 就可以判断出哪写事务是已经提交了的，哪写事务是未提交的，具体判断逻辑如下：</p><p>从活跃事务列表中找到最小的事务ID，记为 min_t_id, 读取到某一版本的事务ID记为 row_t_id, 系统分配的最大事务ID 记为 max_t_id</p><ol><li>如果 row_t_id &lt; min_t_id, 说明这一版本的事务一定被提交了，这一版本可见</li><li>如果 row_t_id &gt; max_t_id, 说明这一版本的事务还没有开始，一般不存在这种情况，不可见</li><li>如果 row_t_id &gt;&#x3D; min_t_id &amp;&amp; row_t_id &lt;&#x3D; max_t_id, 还需要分两种情况讨论：<ol><li>如果 row_t_id 在活跃事务列表中，则说明该版本是由未提交的事务创建的，不可见，但对于自身事务是可见的。</li><li>如果 row_t_id 不在活跃事务列表中，说明创建该版本的事务已提交，该版本是可见的。</li></ol></li></ol><p>有了版本链和 read-view，一个事务就可以根据 read-view 顺着版本链依照上面的规则一直往下直到找到一个可见的版本，</p><p>以上面的例子为例，如果事务的并发时序图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608536056827-1608536056819.png" alt="img"></p><p>当事务二更新操作执行后，版本链变为：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608536210352-1608536210347.png" alt="img"></p><p>事务三第一次执行查询语句时，生成的 read-view 为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">|    active list    |  max   |<br>+-------------------+--------+<br>|     200, 300      |   300  |<br>+-------------------+--------+<br>          read  view<br></code></pre></td></tr></table></figure><p>根据 read-view 得到 max_t_id &#x3D; 300, min_t_id &#x3D; 200, 从最新版本开始遍历，</p><ol><li>row_t_id &#x3D; 300, 满足条件3，同时 row_t_id 在 active list 中，说明这一版本未提交，不可见，根据回滚指针检查下一个版本。</li><li>row_t_id &#x3D; 200，同样满足条件三，在 active list 中，不可见，看下一个版本。</li><li>row_t_id &#x3D; 100, 满足条件一，可见，则这个读事务会使用这一版本的信息。</li></ol><p>如下图，如果在第五时刻，事务 2 提交，第六时刻事务三再次读取：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608536908939-1608536908937.png" alt="img"></p><p>版本链并没有发生改变，但如果在 <strong>RC</strong> 的隔离界别下，事务三的第二条查询语句会重新生成 read-view, 这时活跃事务只有 200，最大事务为 300，按上面的规则，row_t_id &#x3D; 300 时，满足条件三但不在活跃事务列表中，所以这条记录是可见的，这就会读出 wangwu, 导致不可重复读。</p><p>但如果使用 <strong>InnoDB 默认的 RR</strong> 隔离界别，read-view 只会在事务执行第一条查询语句时生成，后续所有查询语句使用同一个 read-view, 由此避免不可重复读。</p><h2 id="一些其他问题"><a href="#一些其他问题" class="headerlink" title="一些其他问题"></a>一些其他问题</h2><h3 id="InnoDB-中的锁"><a href="#InnoDB-中的锁" class="headerlink" title="InnoDB 中的锁"></a>InnoDB 中的锁</h3><p>在上面我们介绍了 LBCC，这里再简单介绍一下 InnoDB 中几个具体的锁，他们以锁粒度划分。</p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>Record Locks，也叫行锁，加在索引记录上的锁。例如，<code>SELECT c1 FROM t WHERE c1 = 10 For UPDATE</code>, 防止任何其他事务插入、更新或删除 t.c1 值为10的行, 行锁加在索引上而不是记录上，因为innodb一定会有一个聚簇索引，因此最终的行锁都会落到聚簇索引上。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>gap Locks, 是对索引记录之间间隙加的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。例如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> c1 <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> c1 <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br></code></pre></td></tr></table></figure><p>这样可以防止其他事务插入 c1 值在 10 - 20 之间的数据。</p><p>这里的间隙可以是两个索引值之间的间隙，也可以是从无穷到单个索引值之间的间隙</p><p>使用唯一索引检索唯一行时不会使用间隙锁，但是如果检索条件仅包含多列唯一索引的一些列时，仍然会使用间隙锁锁定，例如一个简单的 SELECT 语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> child <span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>如果 id 使用唯一索引，则该语句只会加记录锁。</p><p>但如果 id 未建立索引或建立了非唯一索引，那么从负无穷到100的间隙将会被间隙锁锁定。</p><p>还有一个需要值得注意的问题，在一个间隙上，不同的事务可以持有相互冲突的锁，这是因为如果某条记录被从索引中清除，那我们必须合并由不同事务保存在记录上的间隙锁。所以说间隙锁的唯一目的是为了防止记录被插入间隙， 一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享和专用间隙锁之间没有区别。 它们彼此不冲突，并且执行相同的功能。</p><p>间隙锁定可以显式禁用。 如果将事务隔离级别更改为READ COMMITTED或启用innodb_locks_unsafe_for_binlog系统变量（现已弃用），则会发生这种情况。 在这种情况下，将禁用间隙锁定来进行搜索和索引扫描，并且间隙锁定仅用于外键约束检查和重复键检查。</p><p>使用 READ COMMITTED 隔离级别或启用innodb_locks_unsafe_for_binlog还有其他效果。MySQL 在计算完 WHERE 条件后，将释放不匹配行的记录锁。 对于 UPDATE 语句，InnoDB 进行“半一致”读取，以便将最新的提交版本返回给 MySQL，以便MySQL可以确定该行是否与UPDATE的WHERE条件匹配。</p><h5 id="间隙锁总结"><a href="#间隙锁总结" class="headerlink" title="间隙锁总结"></a>间隙锁总结</h5><ol><li>进行范围查询或使用非唯一索引作为检索条件时会使用间隙锁。</li><li>间隙锁只用于阻止别的事务插入间隙，他不阻止别的间隙锁锁定相同内容，在一个间隙上，不同的事务可以持有相互冲突的锁。</li><li>间隙锁只在 RR 隔离界别下起作用，可以手动关闭。</li></ol><h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h4><p>临键锁是间隙锁和记录锁的结合，临键锁使得一个会话如果在某个索引记录上建立了共享或排它锁，其他会话不能在该索引记录前面的间隙插入数据。</p><p>假设某个表的索引包含值10，11，13，20，则其临键锁可能包含以下间隔：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608605008312-1608605008297.png" alt="img"></p><blockquote><p>其实只需要记住临键锁锁定的是一个左开右闭的区间即可</p></blockquote><h5 id="临键锁总结"><a href="#临键锁总结" class="headerlink" title="临键锁总结"></a>临键锁总结</h5><ol><li>临键锁是行锁和间隙锁的组合。</li><li>临键锁锁定的是一个左开右闭的区间。</li><li>InnoDB RR 隔离级别下，临键锁用来解决幻读。</li></ol><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>insert intention lock， 是在插入新的记录之前通过 INSERT 操作设置的一种间隙锁，该锁以这样一种方式发出插入意图的信号，即如果多个事务要插入的数据在同一间隙内但不是相同的位置，那这些事务就不需要相互等待。比如假设有值为4和7的索引记录。尝试分别插入值5和6的单独事务在获得插入行上的独占锁之前，每个事务都使用插入意图锁锁定4和7之间的间隙，但不会互相阻塞，因为行不冲突。</p><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>AUTO-INC锁是一种特殊的表级锁，如果一个表中有 AUTO_INCREMENT列，则要插入该表的事务在插入之前会先获取该锁，该锁是表级锁，但不是事务级锁，插入语句执行完后就会立刻释放，不会等待事务提交才释放。自增锁也具有不同的模式，可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a> 选项（0， 1， 2）控制自增锁递增算法，以谋求效率和安全性的要求.</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608606996687-1608606996394.png" alt="img"></p><p>在默认状态下，该选项设置为 1，在该模式下：</p><ul><li>“批量插入”使用特殊的AUTO-INC表级锁并将其保持到语句结束。 这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。 一次只能执行一条持有AUTO-INC锁的语句。 如果批量插入操作的源表与目标表不同，则在对源表中选择的第一行进行共享锁之后，将对目标表执行AUTO-INC锁。 如果批量插入操作的源和目标是同一表，则在对所有选定行进行共享锁之后，将获取AUTO-INC锁。</li><li>“简单插入”（预先知道要插入的行数）通过在互斥量（轻型锁）的控制下获得所需数量的自动增量值来避免表级AUTO-INC锁定 仅在分配过程的整个过程中才保留，直到语句完成为止。 除非另一个事务持有AUTO-INC锁，否则不使用表级AUTO-INC锁。 如果另一个事务持有AUTO-INC锁，则“简单插入”将等待AUTO-INC锁，就好像它是“批量插入”一样。</li><li>混合模式插入”，如果用户为多行“简单插入”中的某些行 (但不是所有行) 的AUTO_INCREMENT列提供显式值，InnoDB分配的自动增量值会多于要插入的行数。但是，自动分配的所有值都是由最近执行的上一条语句生成的自动增量值连续生成的，因此“多余的”号码就会丢失。</li></ul><p>其他模式可以参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes">官方文档</a></p><h3 id="关于幻读"><a href="#关于幻读" class="headerlink" title="关于幻读"></a>关于幻读</h3><p>网上对幻读的定义各种各样，有人把幻读囊括在不可重复中（比如我们的教材），有人说对某一范围的数据执行删除或插入会导致幻读，有人说只有插入导致的才叫幻读，实际上在 <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL 92</a> 标准里明确定义了什么是幻读：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">P3 (&quot;Phantom&quot;): SQL-transaction T1 reads the set of rows N that satisfy some &lt;search condition&gt;. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the &lt;search condition&gt; used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same &lt;search condition&gt;, it obtains a different collection of rows.<br></code></pre></td></tr></table></figure><p>当一个事务 T1 读到满足某些条件的行集合后，事务 T2 向表中插入了满足这些条件的一行或多行数据，如果 T1 使用相同的条件重复读取，它将得到不同的结果，这叫幻读，而对于删除的情况，92 标准也明确说了这属于不可重复读。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">P2 (&quot;Non-repeatable read&quot;): SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs  a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.<br>P2(“不可重复读取”)：SQL-Transaction T1读取一行。然后，SQL-Transaction T2修改或删除该行并执行提交。如果T1随后尝试重新读取该行，它可能会收到修改后的值或发现该行已被删除。<br></code></pre></td></tr></table></figure><p>在 InnoDB 的文档中，也可以看见：</p><blockquote><p>Also, a deletion is treated internally as an update where a special bit in the row is set to mark it as deleted.</p></blockquote><p>所以对于 MVCC 解决不可重复读中删除情况的问题和修改其实是一样的。</p><p>还有一个问题是 InnoDB 的 RR 隔离级别有没有解决幻读的问题，这在文档里面也清晰的写了：<strong>解决了</strong>，解决方式就是上面的临键锁。</p><h3 id="关于丢失修改"><a href="#关于丢失修改" class="headerlink" title="关于丢失修改"></a>关于丢失修改</h3><p>上面说到并发导致的问题时提到了两类丢失修改的问题：提交覆盖和回滚覆盖，但似乎在平时说到并发问题时大家只提脏读幻读不可重复读，在 SQL 92 标准里也没有发现对所谓丢失修改问题的描述，事实上，这两种情况都是在读的结果上进行了修改，对于回滚覆盖，InnoDB 的任何隔离级别下他都不会发生，因为回滚到的是针对数据库的上一个已提交的版本，而不是针对该事务的，而对于提交覆盖，我们完全可以在应用程序层面使用诸如 CAS 等技术手段避免这类问题，网上也有使用悲观锁或乐观锁避免的方案，可以参考：<a href="http://fanyilun.me/2015/12/29/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/">事务的隔离级别以及Mysql事务的使用</a></p><h3 id="关于-InnoDB-中的死锁"><a href="#关于-InnoDB-中的死锁" class="headerlink" title="关于 InnoDB 中的死锁"></a>关于 InnoDB 中的死锁</h3><p>在 LBCC 那一节也简单说了一下死锁和活锁，这里再详细了解一下 MySQL InnoDB 的死锁问题。先看一个官方文档给出的死锁的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t (i INT) ENGINE = InnoDB;<br>INSERT INTO t (i) VALUES(1);<br></code></pre></td></tr></table></figure><p>事务一先对数据加 S 锁执行读操作(未提交)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRANSACTION;<br>SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;<br></code></pre></td></tr></table></figure><p>然后再开启一个事务二尝试删除该记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRANSACTION;<br>DELETE FROM t WHERE i = 1;<br></code></pre></td></tr></table></figure><p>由于删除会对数据加 X 锁，这与事务一加的 S 锁并不相容，所以事务二会等待事务一释放 S 锁，像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn/img/1608618978069-1608618978066.png" alt="img"></p><p>而等待一段时间后，会提示获取锁超时并终止事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t WHERE i = 1<br>&gt; 1205 - Lock wait timeout exceeded; try restarting transaction<br>&gt; 时间: 51.473s<br></code></pre></td></tr></table></figure><p>这样并不存在死锁的问题，但如果在事务二等待的期间，事务一执行了对这条记录的删除操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t WHERE i = 1;<br></code></pre></td></tr></table></figure><p>就会发生死锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM t WHERE i = 1<br>&gt; 1213 - Deadlock found when trying to get lock; try restarting transaction<br>&gt; 时间: 12.216s<br></code></pre></td></tr></table></figure><p>原因是事务一如果想要删除就必须要一个 X 锁，但 X 锁已经被事务二请求了，不能授予事务一，且由于事务二事先请求 X 锁，事务一持有的 S 锁也不能升级为 X 锁，这就会导致死锁，出现这个问题时，InnoDB 会回滚一个小事务（事务的大小由插入、更新或删除的行数决定）并抛出上面的错误来解除死锁。</p><p>在高并发系统上，当多个线程等待相同的锁时，死锁检测会导致速度变慢。 所以有时当发生死锁时，禁用死锁检测而依靠<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout"><code>innodb_lock_wait_timeout</code></a> 设置进行事务回滚可能会更有效。 可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect"><code>innodb_deadlock_detect</code></a> 配置选项禁用死锁检测。</p><blockquote><p><code>InnoDB</code>使用自动行级锁定。即使在仅插入或删除单行的事务中，也可能会遇到死锁。这是因为这些操作并不是真正的“原子”操作；它们会自动对插入或删除的行的（可能是多个）索引记录设置锁定。</p><p>您可以使用以下技术来处理死锁并减少发生死锁的可能性：</p><ul><li><p>使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a>命令以确定最近死锁的原因。这可以帮助您调整应用程序以避免死锁。</p></li><li><p>如果频繁出现死锁警告引，请通过启用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks"><code>innodb_print_all_deadlocks</code></a> 配置选项来收集更广泛的调试信息 。有关每个死锁的信息，而不仅仅是最新的死锁，都记录在MySQL <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_error_log">error log</a> 中。完成调试后，请禁用此选项。</p></li><li><p>如果事务由于死锁而失败，在任何时候，请重试一遍，死锁并不可怕。</p></li><li><p>请保持插入或更新事务足够小，避免锁被一个事务长时间占用，以此减少冲突概率。</p></li><li><p>进行一系列相关更改后立即提交事务，以减少冲突的发生。特别是，不要长时间未提交事务而使交互式 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html"><strong>mysql</strong></a>会话保持打开状态。</p></li><li><p>如果您使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking_read">锁定读取</a>（<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT ... FOR UPDATE</code></a>或 <code>SELECT ... LOCK IN SHARE MODE</code>），请尝试使用较低的隔离级别，例如 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a>。</p></li><li><p>在事务中修改处于多个表或同一表中的不同行集时，每次都要以一致的顺序去执行这些操作。这样事务会形成定义明确的队列而不会导致死锁。例如，将数据库操作组织到应用程序内的函数中，而不是在不同位置编码多个类似的INSERT，UPDATE和DELETE语句序列。</p></li><li><p>对表中的数据建立合适索引，这样您的查询将会使用更少的索引记录，同样也会使用更少的锁。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html"><code>EXPLAIN SELECT</code></a>以确定MySQL认为哪些索引最适合您的查询。</p></li><li><p>如果可以，请尽量少的使用锁，以允许 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT</code></a>从一个旧的快照返回数据，不要添加条款<code>FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>给它。在<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a>这里使用隔离级别是件好事，因为同一事务中的每个一致性读取均从其自己的新快照读取。</p></li><li><p>如果没有其他办法，可以使用表级锁序列化事务。对事务表（例如InnoDB表）使用LOCK TABLES的正确方法是：<code>SET autocommit = 0</code>（not <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html"><code>START TRANSACTION</code></a>）后跟来开始事务，直到明确提交事务后才对<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html"><code>LOCK TABLES</code></a>调用 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html"><code>UNLOCK TABLES</code></a>。例如，如果您需要写表 <code>t1</code>和从表中读取数据 <code>t2</code>，则可以执行以下操作：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">SET</span> autocommit=<span class="hljs-number">0</span>;<br>LOCK TABLES t1 WRITE, t2 READ, <span class="hljs-params">...</span>;<br><span class="hljs-params">...</span> <span class="hljs-keyword">do</span> something <span class="hljs-keyword">with</span> tables t1 <span class="hljs-literal">and</span> t2 here <span class="hljs-params">...</span><br>COMMIT;<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><p>表级锁可防止对表的并发更新，从而避免死锁，但代价是对繁忙系统的响应速度较慢。</p></li><li><p>序列化事务的另一种方法是创建一个仅包含一行的辅助“信号量”表。 在访问其他表之前，让每个事务更新该行。 这样，所有事务都以串行方式发生。 注意，在这种情况下，InnoDB即时死锁检测算法也适用，因为序列化锁是行级锁。 对于MySQL表级锁，必须使用超时方法来解决死锁。</p></li></ul></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">MySQL 官方文档 innodb-multi-versioning</a></p><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">美团技术文章 - Innodb中的事务隔离级别和锁的关系</a></p><p><a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">解决死锁之路 - 学习事务与隔离级别</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB是如何存储数据的</title>
    <link href="/2022/07/01/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84/"/>
    <url>/2022/07/01/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="InnoDB-怎么存储数据"><a href="#InnoDB-怎么存储数据" class="headerlink" title="InnoDB 怎么存储数据"></a>InnoDB 怎么存储数据</h1><h2 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h2><p>众所周之，MySQL 的数据是存储在硬盘中的，而操作系统管理硬盘中的数据的方式就是<strong>文件系统</strong>，所以通俗的来说，MySQL 中的数据是存在一个个文件中的，这些文件 的目录就叫 <strong>数据目录</strong>。</p><p>通过 <code>SHOW VARIABLES LIKE &#39;datadir&#39;</code> 可以查看这个目录：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614159505762-1614159505755.png" alt="img"></p><p>进入这个目录，你会发现，每个数据库对应该目录下的一个子目录，比如 MySQL 中有一个 <code>hotsong</code> 的库，Data 目录下就会有一个 hotsong 的文件夹，这个文件夹里面存储的是一些 <code>ibd</code> 类型的文件，数据库里每张表对应一个 <code>ibd</code> 文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">PS C:\ProgramData\MySQL\MySQL Server 8.0\Data\hotsong&gt; <span class="hljs-keyword">ls</span>                                                          <br>    目录: C:\ProgramData\MySQL\MySQL Server 8.0\Data\hotsong<br><br><br>Mode                LastWriteTime         Length Name<br><span class="hljs-params">----</span>                <span class="hljs-params">-------------</span>         <span class="hljs-params">------</span> <span class="hljs-params">----</span><br>-a<span class="hljs-params">----</span>         2019/9/7     20<span class="hljs-function">:44</span>         114688 hotsong.ibd<br>-a<span class="hljs-params">----</span>         2019/9/7     22<span class="hljs-function">:37</span>       12582912 singer.ibd<br>-a<span class="hljs-params">----</span>         2019/9/7     21<span class="hljs-function">:17</span>         114688 singer_type.ibd<br>-a<span class="hljs-params">----</span>        2020/10/6      9<span class="hljs-function">:21</span>      130023424 songs.ibd<br></code></pre></td></tr></table></figure><p>这里是 MySQL 8.0 的样子，但如果你使用的是更早的版本，你还会看到一种 <code>.frm</code> 的文件，这种文件用来描述表结构，8.0 之后, 表结构信息以 SDI 的形式放在了 <code>.ibd</code> 文件中，你可以使用官方提供 的工具 <code>idb2sdi</code> 从 ibd 文件中提取表结构信息，结果会以 json 形式输出</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614229946103-1614229945999.png" alt="img"></p><p>在 8.0 之前，<code>ibd</code> 文件里保存的仅仅是该表的数据，但是再往前，MySQL 5.6.6 之前，MySQL 服务器中所有表的数据都会被放在一个地方，叫<strong>系统表空间</strong>， 对应数据目录下的 <code>ibdata1</code> 文件，这是一个自扩展文件，但是你也可以在服务器启动时使用相关参数指定服务器使用自定义的文件。</p><p>在 5.6.6 之后，InnoDB 引如 <strong>独立表空间</strong> 空间的概念，每张表使用单独的文件存储数据和表结构，也就是上面的 <code>ibd</code> 和 <code>frm</code> 文件，服务器启动时，可以通过 <code>innodb_file_per_table</code> 设置只使用系统表空间（值为 0）或者是使用独立表空间（值为1）.</p><blockquote><p>服务启动后，通过 ALERT 语句，存储在两种表空间中的数据可以相互移动。</p></blockquote><p>需要注意的是，不是说使用了独立表空间系统表空间就没用了，因为系统表空间除了可以存储表数据外，还存储了许多 MySQL 服务运行所必要的公共信息。</p><h3 id="数据目录总结"><a href="#数据目录总结" class="headerlink" title="数据目录总结"></a>数据目录总结</h3><p>MySQL 的数据是存储在磁盘的，或者可以说是存储在文件中的，这些文件的目录叫做数据目录，每个数据库对应数据目录下的一个子目录，每个表中数据存放的地方叫表空间，在 5.6.6 之前，所有数据都被存放在一个地方，叫系统表空间，数据库子目录下只有 <code>frm</code> 文件，用来描述表结构，在 5.6.6 之后，InnoDB 默认将每个表的数据放在一个单独的 <code>ibd</code> 文件中，称为独立表空间，在 8.0 之后，InnoDB 将描述表结构的 <code>frm</code> 信息以 <code>sdi</code> 的形式也放在了 <code>ibd</code> 文件中，所以 8.0 之后，数据库子目录下就只有 <code>ibd</code> 了。</p><p>5.6.6 之后，系统表空间默认只存储一些必要的公共信息，对应数据目录下的 <code>ibdata1</code> 文件，但他仍然很重要。</p><p><strong>InnoDB 的数据存放在数据目录下的某个文件中</strong>，这是把 InnoDB 看作一个黑盒，从操作系统的角度得到的一个宏大的结论，但每条记录是以怎样的形式组织在这个文件中的，就需要深入了解表空间和记录的具体结构了。</p><h2 id="聚簇索引和页"><a href="#聚簇索引和页" class="headerlink" title="聚簇索引和页"></a>聚簇索引和页</h2><p>众所周之，InnoDB 中每张表都一定会有一个聚簇索引，如果该表设置了主键，那就会以主键建立聚簇索引，如果没有设置主键，InnoDB 会选取一个唯一非 NULL 的列建立聚簇索引，如果找不到适合建立聚簇索引的列，InnoDB 会给表插入一个隐藏列 <code>row_id</code>, 并以此建立聚簇索引。</p><p>为什么 InnoDB 如此执着非要建一个聚簇索引呢？原因是聚簇索引的叶子节点会存储表中的完整数据，换句话说，InnoDB 中的数据是存储在聚簇索引叶子节点中的。</p><p>InnoDB 的聚簇索引是一颗 B+ 树，B+ 树的每个节点占一页，“页” 是 InnoDB 中内存分配的基本单位，大小为 16KB，InnoDB 中有许多不同种类的页，如移除页，索引页等，B+ 的树节点类型就是索引页，它的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614250797750-1614250797632.png" alt="img"></p><p>从上往下依次是：</p><ul><li>文件头（File Header）:占 38 字节，用来描述数据页的一些状态信息。</li><li>页头（Page Header）: 占 56 字节，记录了存储在页中的记录的一些状态。</li><li>Infimum + Supermum: 占 26 字节，该页中两条预添加的记录，Infimum 表示该页中的最小记录，Supermum表示一个最大记录。</li><li>User Records: 用户记录。</li><li>Free Space: 空闲空间。</li><li>页目录（Page Directory）: 用来加快页内记录查找速度。</li><li>文件尾（File Tialer）: 用于校验数据。</li></ul><h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>文件头（File Header）:占 38 字节，用来描述数据页的一些状态信息，它的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614251005493-1614251005478.png" alt="img"></p><p>从左到右依次表示：</p><ol><li>该页的校验和</li><li>页号</li><li>上一个页的页号</li><li>下一个页的页号</li><li>页面被最后修改时对应的日志序列号（LSN）</li><li>页面类型</li><li>仅在系统表空间的第一个页上使用</li><li>页属于哪个表空间</li></ol><p>这里面比较重要的是 <code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code> ,这两个字段可以看作指向上一个页和下一个页的指针，我们知道 B+ 树的叶子节点是通过双指针串联起来的，但实际上，InnoDB 的索引里，它的非叶子节点也可以看作是串连起来的。</p><h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>页头（Page Header）: 占 56 个字节，他记录了存储在页中的记录的一些状态，结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614252031601-1614252031578.png" alt="img"></p><p>从上到下依次为：</p><ol><li>页目录中槽的数量（后面会说）</li><li>还未使用的最小地址空间,也就是该地址之后就是 Free Space 了。</li><li>第一位表示本记录是否为紧凑型记录，后 15 为表示本页堆中的记录数。</li><li>已删除记录链表的头节点的偏移。</li><li>已删除的记录占用的字节数。</li><li>最后插入的记录的位置。</li><li>记录插入方向。</li><li>一个方向连续插入的记录数。</li><li>用户记录数（PAGE_N_HEAP 中的记录数包含已经删除了的记录和Infimum + Supermum， 但这里不包含）</li><li>当前页的最大事务 ID。</li><li>该页在 B+ 树中所处的层级。</li><li>B+ 树叶子节点的头部信息（只在 B+ 树的更页面定义）</li><li>B+ 树非叶子节点头部信息（只在 B+ 树的更页面定义）</li></ol><p>关于第一个 <code>PAGE_N_DIR_SLOTS</code> , 他与页目录有关，在后面会说到，关于 3， 4， 5， 9 他们都涉及到了记录的删除，当我们执行 DELETE 语句时，InnoDB 并不会真的把这条记录从磁盘删除，因为这还涉及到紧凑数据，每次都真正删除花销太大，所以 InnoDB 会修改这条记录上的一个标记位，并将这些已经删除的记录链在一起（事实上正常记录也是链在一起的，在说记录格式时会讲到），4 <code>PAGE_FREE</code> 所记录的就是这个链表的头节点在 User Records 中的偏移。</p><p>关于 7，8，记录插入方向描述的是新插入记录的主键值与最后一次插入记录主键值的大小关系。</p><h3 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h3><p>到这儿就需要说一下 InnoDB 的记录行格式了。</p><h4 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h4><p>行格式，也就是每条记录在 InnoDB 中的真实样子，InnoDB 有四种行格式，分别是：COMPACT， REDUNDANT， DYNAMIC， COMPRESSED，通过 <code>ROW_FORMAT</code> 可以修改表的行格式，如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> ROW_FORMAT=COMPACT<br></code></pre></td></tr></table></figure><p>这里以 COMPACT 格式为例，它的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614259522989-1614259522960.png" alt="img"></p><h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>顾名思义，这个结构用来存储这一行里变长字段的长度，唯一需要注意的是这个列表是按表结构逆序排序的，假如一个表结构如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `hotsong` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `song_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `download_link` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `singer` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure><p>其中 <code>name, download_link, singer</code> 的类型是 <code>varchar</code>, 属于变长字段，如果向该表中插入一条记录，其中 <code>name, download_link, singer</code> 的长度分别为 1， 2， 3， 则在变长字段长度列表中会存储 3， 2， 1。</p><p>对于列表中该使用多少字节存储一个字段的长度，这取决于表采用的字符集和该类型能存储的最大字节数，如上表，字符集是 utf8mb4, 该字符集最多使用四个字节表示一个字符，而定义中， <code>name</code> 最多存储 50 个字符，所以这些字段能存储最多 4 * 50 &#x3D; 200 字节的数据，所以用一个字节就可以表示其长度了，而 <code>download_link</code> 最多存储 100 个字符，则需要两个字节来表示其长度了。这里最多也只会使用两个字节，如果某个字段长度特别长，就需要使用溢出字段了，也就是在这一页中只会存部分数据。</p><p>变长字段列表只会存不为 NULL 的列的长度，NULL 列会表现在下面的 NULL 值列表中。</p><h5 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h5><p>很好理解，NULL　值列表类似于一个 BitＭap 表明了这一行中哪写列是 NULL，这些为 NULL 的列是不会占额外的空间的，存记录时， InnoDB 会去查看表格式，看允许为 NULL 的列有多少个，如上面的 <code>hotsong</code> 表，只有两个字段允许为 NULL，那 NULL 值列表就会占用一个字节（必须占用整数字节，高位填0），最低两位用来表示 <code>singer</code> 和 <code>download_link</code>， 这里和长度列表一样，也是逆序排列的，值为 0 时，代表该字段不为 NULL。</p><h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>记录头信息里，我们暂且关注这几个字段：</p><ul><li><p><code>delete_flag</code>: 标识这条记录是否被删除，在 Page Header 那已经说过了，这就是那个标志位，为 1 表示被删除。</p></li><li><p><code>n_owner</code>: 与页目录有关，页中的记录会被分成若干组，这个字段表示这一组中的记录数。</p></li><li><p><code>heap_no</code>: 这条记录在页堆中的偏移。</p></li><li><p>&#96;&#96;&#96;<br>record_type</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>  : 记录类型：<br><br><span class="hljs-bullet">  -</span> 0： 普通记录<br><span class="hljs-bullet">  -</span> 1：B+ 树非叶子节点目录项记录<br><span class="hljs-bullet">  -</span> 2：Infimum 记录<br><span class="hljs-bullet">  -</span> 3：Supermum 记录<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`next_record`</span>: 下一个记录（主键大小上的下一条）的相对位置，通过这个字段，页面中的每条记录都像是使用链表连起来了。<br><br>回到索引页的 User Records 上，通过上面行格式的介绍，我们知道每一条记录的长度是不一样的，并且他们通过 <span class="hljs-code">`next_record`</span> 链在了一起，所以记录在 User Records 中是像下面这样存储的：<br><br>![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614263144987-1614263144943.png</span>)<br><br>记录一条一条紧密排列，这个结构被称之为 Heap(堆)， 记录在这个堆中的相对位置就是上面记录头信息里的 <span class="hljs-code">`heap_no`</span>, <span class="hljs-code">`next_record`</span> 指的也是下一条记录的偏移，而不是真的一个链表指针。<br><br>除此之外，InnoDB 的设计者在每一个堆中加入了两条特殊记录：Infimum 和 Supermum，他们的 <span class="hljs-code">`heap_no`</span> 分别为 0 和 1，这两条记录很简单，只有记录头信息和代表这两个单词的记录体，这两个特殊记录代表了这一页中最大和最小的记录，也就是说，通过 Infimum 的 next<span class="hljs-emphasis">_record 找到的是堆中的第一条用户记录，堆中的最后一条用户记录的 next_</span>record 指向了 Supermum, 如果把紧密排列的堆变成链表的样子，他应该是这样的：<br><br>![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614263919072-1614263919054.png</span>)<br><br>关于 <span class="hljs-code">`next_record`</span> 他还有一个非常重要的特性，就是它允许为负，表示当前记录的下一条记录在它前面，这里的下一条是主键大小排列上的下一条，比如页中有一个主键值为 5 的记录 A（长度为 len<span class="hljs-emphasis">_A*l<span class="hljs-strong">**e**</span>n<span class="hljs-strong">**A*），我们又插入了一条主键值为 6 的记录 B（长度为 len_B*l**</span>e<span class="hljs-strong">**n**</span>B*），那么 A 的 next_</span>record 就是 +len<span class="hljs-emphasis">_A+*l<span class="hljs-strong">**e**</span>n<span class="hljs-strong">**A* 表示沿着记录 A 向后寻找 len_A*l**</span>e<span class="hljs-strong">**n**</span>A* 个字节就是记录 B，但这时如果我们又插入了一条主键值为 4 的记录 C，那 C 的 next_</span>record 就是 -(len<span class="hljs-emphasis">_A + len_</span>B)−(<span class="hljs-emphasis">*l<span class="hljs-strong">**e**</span>n<span class="hljs-strong">**A*+*l**</span>e<span class="hljs-strong">**n**</span>B*</span>) 也就是向前找能找到 C 的下一条记录 A。<br><br>这样的好处是通过 <span class="hljs-code">`next_record`</span> 页中的所有记录会组成一个按主键排序的有序链表，但在物理上，记录还是按插入顺序紧密排列的，配合下面的页目录，能提高页内记录的检索速度。<br><br><span class="hljs-section">### Page Directory</span><br><br>我们知道，索引的存在是为了快速定位到记录所在的页，但定位到页后呢，一页里可能包含许多记录，遍历页中的所有记录同样是不可接受的，所以 InnoDB 设计了页目录，相当于页索引，它的工作原理如下：<br><br><span class="hljs-bullet">1.</span> 将所有未删除的记录（包括Infimum 和 Supermum）划分为多个组。<br><span class="hljs-bullet">2.</span> 将每组中的最后一条记录的偏移提取出来放在 Page Directory 中。<br><span class="hljs-bullet">3.</span> 当查找页中的某条记录时，先通过二分法查找到该记录在哪一组中，然后找到这一组中最小的那条记录，沿着 next<span class="hljs-emphasis">_record 往下遍历这一组的记录。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">这里 Page Directory 中的每一个偏移量被叫做一个 <span class="hljs-strong">**槽**</span>， 一个槽占 2 字节，记录分组的原则是：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- Infimum 独占一组</span><br><span class="hljs-emphasis">- Supermum 那一组只能有 1~8条记录</span><br><span class="hljs-emphasis">- 其他组只能有 4 ~ 8 条记录</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">这样一来，页中最多遍历 8 次，就可以找到（确认找不到）某条记录了，能这样做的前提，还是通过 `next_</span>record` 记录组成了一个有序链表。<br><br>还有一个有趣的问题，槽中记录的是一组中最大的记录的偏移，但定位到组后，需要的是最小的记录，该怎么办呢？上一个槽的下一条记录不就是吗。<br><br><span class="hljs-section">### 总结</span><br><br>第一节 <span class="hljs-strong">**数据目录**</span> 我们站在操作系统的角度，说 InnoDB 是把数据存储在数据目录下的文件中的，这一节，我们从聚簇索引的一个节点（页）出发，说明了一条记录是怎样被存放的，关键点如下：<br><br><span class="hljs-bullet">1.</span> 所有数据被存放在表聚簇索引的叶子节点上。<br><span class="hljs-bullet">2.</span> 索引的一个节点就是一页，大小为 16KB，页是 InnoDB 内存分配的基本单位。<br><span class="hljs-bullet">3.</span> InnoDB 中，页有很多种，索引的节点对应的页类型叫索引页。<br><span class="hljs-bullet">4.</span> 索引页由文件头，页头，用户记录，页目录，文件尾等部分组成。<br><span class="hljs-bullet">5.</span> 通过文件头，页和页可以以双链表的形式连接起来。<br><span class="hljs-bullet">6.</span> 页头记录了页中的一些统计信息。<br><span class="hljs-bullet">7.</span> 用户记录段是存储用户记录的地方，每条记录被紧密地存储在这，称为堆。<br><span class="hljs-bullet">8.</span> 每条用户记录都有一个重要的 <span class="hljs-code">`next_record`</span> 字段，他能保证紧密排列地用户记录能按主键大小组织成一个有序链表。<br><span class="hljs-bullet">9.</span> 有两条特殊的记录 Infimum 和 Supermum被安排在堆中，他们处于堆中最前的位置，但分别表示最大最小的记录。<br><span class="hljs-bullet">10.</span> 页目录是为了提高页内记录检索的速度而存在的，堆中的记录最多会 8 个为一组，每一组中最大的记录偏移量会被存放在页目录中，称为槽，查找记录时，会先通过二分法定位到组，然后在组内遍历。<br><span class="hljs-bullet">11.</span> 文件尾用来校验数据。<br><br>最后，放上索引页的整体图：<br><br>![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614267559935-1614267559906.png</span>)<br><br>接下来，我们要把页和数据目录结合起来，了解页是怎么在表空间中组织的。<br><br><span class="hljs-section">## InnoDB 表空间</span><br><br>在 MySQL 5.6.6 之后， InnoDB 有了独立表空间的概念，每张表对应一个独立表空间（一个 ibd 文件），而系统表空间（ibdata1）则主要用来存储一些公有的信息，这一节，我们以页为单位，看一看 InnoDB 是怎么在表空间中管理每个页的。<br><br><span class="hljs-section">### 页回顾</span><br><br>上面多次说过，页是 InnoDB 分配内存的基本单位，一页大小 16KB，页有许多不同的类型，如：<br><br><span class="hljs-bullet">-</span> Index 页，上面已经说过。<br><span class="hljs-bullet">-</span> Inode 页，用来存储段信息。<br><span class="hljs-bullet">-</span> XDES 页，存储区信息。<br><span class="hljs-bullet">-</span> FPS<span class="hljs-emphasis">_HDR 页，存储表空间头部信息。</span><br><span class="hljs-emphasis">- IBUF_</span>BITMAP 页：存储 Change Buffer 相关的内容。<br><br>除了这几个，其实还有许多种类型的页，但其余的和本文关系不大，我们只关心这几种页就好了。<br><br>上面说 Index 页时讲了它的格式，事实上，<span class="hljs-code">`File Header`</span> 和 <span class="hljs-code">`File Trailer`</span> 是所有页面类型所共有的，在后面介绍其他页面类型的结构时，就不赘述了。<br><br><span class="hljs-section">### 区 , 组和段</span><br><br>前面说过，页是 InnoDB 分配存储空间最小的单位，但问题在于页太小了，只有 16KB，在表中数据非常多时，如果继续以页为单位分配，就可能造成页与页间的物理距离过大，虽然页和页之间是通过指针连接的，但在使用传统机械硬盘时，物理距离大就意味着根据一个页的 Next 指针找到下一个页磁头需要移动更多的距离（随机 IO），造成页和页虽然在逻辑上连续，但在物理上分散，这样不利于高效地数据读写。为了尽量避免这种情况，InnoDB 会尽量让逻辑上相连的页在物理内存上也连续（顺序IO），具体做法就是当表中的数据量很大时，就以更大的 <span class="hljs-strong">**区（extent）\**</span>为单位为表分配存储空间，InnoDB 规定连续的 64 个页是一个区，也就是一个区占 1M 的空间。同时，为了方便管理这些区，将连续的 256 个区被划分为一\<span class="hljs-strong">**组**</span>，每一组的开始几个页面类型是固定的：<br><br>对于表空间中第一个组的前三个页面类型是固定的，他们依次是：<br><br><span class="hljs-bullet">1.</span> FPS<span class="hljs-emphasis">_HDR 页：记录表空间的整体属性和这一组中 256 个区的整体属性。</span><br><span class="hljs-emphasis">2. IBUF_</span>BITMAP 页：存储 Change Buffer 相关的内容。<br><span class="hljs-bullet">3.</span> INODE 页：存储与段相关的内容。<br><br>对于其他组，它的前两个页面类型是固定的，依次是：<br><br><span class="hljs-bullet">1.</span> XDES 页：记录这一组中说有区的属性<br><span class="hljs-bullet">2.</span> IBUF<span class="hljs-emphasis">_BITMAP 页：存储 Change Buffer 相关的内容。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">所以独立表空间的结构类似于下图：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614314976326-1614314976316.png</span>)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">蓝色的表示一个组，大小为 256 MB， 绿色的表示一个区，大小为 1M， 红色的表示一个页，大小为 16KB。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">##### 段</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&gt; 区存在的意义是尽量让页面链表中相邻的页在物理位置上也相邻，这样在扫描叶子节点的大量记录时，才可以使用顺序IO。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">引入区是为了加快扫描叶子节点时的速度，但事实上不管是叶子节点还是非叶子节点，他们的页类型都是 Index, 非叶子节点间也是有链表连起来的，只是我们一般用不到这些指针而已，所以如果把叶子节点和非叶子节点都放在区里面，扫描的性能又会大打折扣了，为此，InnoDB 引入了<span class="hljs-strong">**段**</span>，这是一个逻辑上的概念，每个索引（聚簇索引或二级索引）都有两个段，分别用来存放叶子节点和非叶子节点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">当表中的数据很少时，段会以页为单位申请存储空间，这些零散的页所在的区叫做<span class="hljs-strong">**碎片区**</span>，它直属于表空间。当表中的数据占了 32 个零散的页面后，段会以完整的区为单位分配存储空间，但之前存储在零散页面的数据并不会被移动过去。这样做的目的是尽量减少浪费。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">所以<span class="hljs-strong">**段是一些零散的页面以及一些完整的区构成的集合**</span>。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">##### 区的分类</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">有了段后，区就可以被分为下面几类：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. 空闲区（FREE）：完全没有被使用的区。</span><br><span class="hljs-emphasis">2. 有空闲的碎片区（FREE_</span>FRAG）: 区中的部分页面被用作段的零散页面，但还有空闲的页。<br><span class="hljs-bullet">3.</span> 无空闲的碎片区（FUEE<span class="hljs-emphasis">_FRAG）: 所有页面都被用了的碎片区。</span><br><span class="hljs-emphasis">4. 完整分配给某个段的区（FSEG）：当表中的数据占了 32 页后，段会以完整的区为单位分配空间，这些区就是 FSEG。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">##### XDES Entry</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">为了管理这些区，InnoDB 设计了一个大小为 40 字节的 `XDES Entry` ，它的结构如下：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">| XDES Entry 结构                                              | List Node 结构                                               |</span><br><span class="hljs-emphasis">| ------------------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="hljs-emphasis">| ![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614403201285-1614403201281.png</span>) | ![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614423348895-1614423348889.png</span>) |</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- Segment ID: 对于一个 FSEG 类型的区，Segment ID 用来标识它被分配给了哪个段。</span><br><span class="hljs-emphasis">- List Node: 通过这个结构，XDES Entry 能连成一个链表。</span><br><span class="hljs-emphasis">  - Prev Node Page Number, Prev Node Offset: 上一个 XDES Entry 所在的页面和在页面内的偏移，通过这两个字段，可以在表空间中找到上一个 XDES Entry.</span><br><span class="hljs-emphasis">  - NextNode Page Number, Next Node Offset: 下一个 XDES Entry 。</span><br><span class="hljs-emphasis">  - 这个链表链接的是<span class="hljs-strong">**相同状态的区对应的 XDES Entry**</span>， 也就是说，如果一个 XDES Entry 对应的区是 FREE 状态的，那么根据它的 Next 和 Prev 指针拿到的 XDES Entry 对应的区也是 FREE 状态的。如此一来，不同类型区对应的 XDES Entry 就会被组织成不同的链表，通过这些链表的头节点（保存在固定的地方），我们就可以快速获得一个需要的区或碎片页（由于 FSEG 类型的区已经分配给段了，所以这里的链表不包括这种类型的，FSEG 类型的区会在段内链接成别的链表，马上会说到）。</span><br><span class="hljs-emphasis">- State：表示这个区的状态。</span><br><span class="hljs-emphasis">- Page State Bitmap: 没两位对应区中的一页的状态， 00 表示这一页空闲， 01表示不空闲。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">有了 XDES Entry 后，向表空间申请页插入新记录的的过程就是这样的了：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. 如果表中数据不多（不足 32 页），就从 FREE_</span>FRAG 链表中找到一个 FREE<span class="hljs-emphasis">_FRAG 状态的区，并通过 Page State Bitmap 找到一个空闲的页分配给表（实际上是分配给索引或者说分配给段）之后把记录插进去，如果没有 FREE_</span>FRAG 状态的区，就通过 FREE 链表找到一个 FREE 状态的区，将其中的一页分配给段，并将这个区对应的 XDES Entry 从 FREE 链表移动到 FREE<span class="hljs-emphasis">_FRAG 链表中。</span><br><span class="hljs-emphasis">2. 如果表中的数据到了 32 页，就需要以区为单位给段分配空间，这时只需要根据 FREE 列表找到一个 FREE 分配给段即可。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">##### Inode Entry</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">类似于 XDES Entry，InnoDB 为每个段设计了一个 Inode Entry 结构，这个结构记录了该段的一些必要信息，它的结构如下：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614431671386-1614431671350.png</span>)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">上面说过，段是由一些整块的区和一些零碎的页组成的逻辑上的结构，Inode Entry 记录的就是这些信息，对于段中整块的区，InnoDB 将其分成了三类：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- FREE 区：完全没有使用的区，刚刚分配的。</span><br><span class="hljs-emphasis">- NOT_</span>FULL 区：还有空页面的区。<br><span class="hljs-bullet">-</span> FULL 区：没有空页面的区。<br><br>这三类区对应的 XDES Entry 结构也会组成一个链表（从上面的区的分类来看，他们都是 FSEG 类型的），Inode Entry 中的 List Base Node For FREE List, List Base Node For NOT<span class="hljs-emphasis">_FULL List, List Base Node For FULL List 对应的就是这三个链表的头节点， NOT_</span>FULL<span class="hljs-emphasis">_N_</span>USED 字段储存的就是 NOT<span class="hljs-emphasis">_FULL 链表中已经使用了多少页面了。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Magic Number 字段用来标记 Inode Entry 是不是已经被初始化了，值为 97937874 时，表示已经初始化了（确实是 Magic Number）</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">下面的 32 个 Fragment Array Entry 每个占四字节，用来存储段中 32 个零碎页的页号。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Segment ID 用来记录这个段的唯一 ID。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">##### 小结</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">页是分配存储空间的最小单位，但页太小了，在数据量特别大时，如果依然以页为单位分配，可能导致逻辑上相邻的两个页在物理上相隔很远，这样在遍历叶子节点时就会造成大量的随机 IO，为此，InnoDB 规定当表中数据占用空间小于 32 页时，从碎片区中以页为单位分配，当超过 32 个页后，就以更大的区（连续的 64 个页）为单位分配存储空间，每个区由一个 XDES Entry 结构管理，不同状态的 XDES Entry 结构通过 List Node 链接成一个链表，也就看一看作是不同状态的区链成了不同的链表，在分配区或碎片页时，就可以直接从对应链表获取到对应的区了。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">为了进一步减少随机 IO，InnoDB 还引入一个逻辑上的概念 “段”，每个索引对应两个段，分别是叶子节点段和非叶子节点段，每个段实际上是一些碎片页和一些整块的区（FSEG 状态）的集合，每个段由一个 Inode Entry 结构管理，在段里，完整的区也会被分成三类，每类使用单独的链表链接。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### 页面类型</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">上面说的 XDES Entry, Inode Entry 是被存储在特定的页面类型中的，他们分别是 `XDES 页`， `Inode 页` 和 `FSP_</span>HDR 页`， 他们的结构如下：<br><br>| XDES 页                                                      | INODE 页                                                     | FPS<span class="hljs-emphasis">_HDR 页                                                   |</span><br><span class="hljs-emphasis">| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="hljs-emphasis">| ![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614433995819-1614433995793.png</span>) | ![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614433969866-1614433969862.png</span>) | ![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1614433969866-1614433969862.png</span>) |</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">除了熟悉的 XDES Entry 和 Inode Entry 外， File Header 和 File Tialer 是所有页面共有的，在索引页那已经说过，剩下的就是 INODE 页的 `List Node For INODE Page List` 和 FSP_</span>HDR 页的 <span class="hljs-code">`File Space Header`</span> 了。<br><br><span class="hljs-section">#### List Node For INODE Page List</span><br><br>上面说过，INODE 页是表空间的第一组（第一个区）的第三个页，里面的核心结构式 Inode Entry, 用来描述段信息，但这样一页只能有 85 个 Inode Entry, 如果一张表里的段数量超过85个（索引数量超过 42 ）时，就需要额外的 INODE 页来存储这些 Inode Entry 了， 根据这个 List Node For INODE Page List 字段就找到别的 INDOE 页，它的结构如下：<br><br>![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614434533279-1614434533275.png</span>)<br><br><span class="hljs-section">#### File Space Header</span><br><br>关于 FSP<span class="hljs-emphasis">_HDR 页面，前面也说过了，它类似于 XDES 页面，存储了本组 256 个区的信息，除此之外，他是表空间的第一个页面，因此还存储了表空间的一些通用信息，这些信息就被存储在 File Space Header 里，它的结构如下：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">![<span class="hljs-string">img</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1614434809359-1614434809355.png</span>)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. Space ID: 表空间 ID</span><br><span class="hljs-emphasis">2. Size：表空间拥有的页面数</span><br><span class="hljs-emphasis">3. FREE Limit: 未被初始化的最小页号，大于或等于该页号的区对应的 XDES Entry 都没被加入 FREE 链表, 每个表空间对应的其实是一个自增长的 ibd 文件（当然可以在建表时直接指定一个非常的文件），这些表空间中可能有大量未使用的区，InnoDB 不会把所有空闲区一股脑的加入 FREE 链表，而是会等到空闲区不够时，再加一批到链表中，加入到链表中的就是被初始化了，反之就是未初始化。</span><br><span class="hljs-emphasis">4. Space Flags: 一些标志字段</span><br><span class="hljs-emphasis">5. FRAG_</span>N<span class="hljs-emphasis">_USED: 类似于 Inode Entry 中的 NOT_</span>FULL<span class="hljs-emphasis">_N_</span>USED, 表示 FREE<span class="hljs-emphasis">_FRAG链表中有多少页面被使用了。</span><br><span class="hljs-emphasis">6. List Base Node for FREE List: 上面说 FREE 链表的根节点被保存在固定的地方，就是这。</span><br><span class="hljs-emphasis">7. List Base Node for FREE_</span>FRAG List：FREE<span class="hljs-emphasis">_FRAG 链表根节点。</span><br><span class="hljs-emphasis">8. List Base Node for FULL_</span>FRAG List：FULL<span class="hljs-emphasis">_FRAG 链表根节点。</span><br><span class="hljs-emphasis">9. Next Unused Segment ID: 每个段都有一个唯一 ID，这个字段表示下一个可以分配的段ID。</span><br><span class="hljs-emphasis">10. List Base Node for SEG_</span>INODES<span class="hljs-emphasis">_FULL：上面说，INODE 类型的页面可能有多个，由 `List Node For INODE Page List` 连接，这些 INODE 页也会依据有没有满链成两个链表：`SEG_</span>INODES<span class="hljs-emphasis">_FULL` 和 `SEG_</span>INODES<span class="hljs-emphasis">_FREE`, 这个字段就是 SEG_</span>INODES<span class="hljs-emphasis">_FULL 链表的头节点。</span><br><span class="hljs-emphasis">11. List Base Node for SEG_</span>INODES<span class="hljs-emphasis">_FREE: SEG_</span>INODES<span class="hljs-emphasis">_FREE 链表的头节点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### 总结</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">最后，祭上大图吧</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">![<span class="hljs-string">大三下 (1).svg</span>](<span class="hljs-link">https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/16d6dfe6-2353-406b-87d0-61c9d5f24837.svg</span>)</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">## 系统表空间</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">上面介绍了独立表空间的结构，它对应于数据库里的每一张表，但还有一些问题没有解决，比如如何确定哪张表对应哪个表空间等，这就需要系统表空间，一个 MySQL 服务只会对应一个系统表空间，它是 MySQL 服务的第一个表空间， Space ID 为 0， 记录了整个系统属性的相关信息，第一个组中的前七个页面类型分别为：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. FSP_</span>HDR<br><span class="hljs-bullet">2.</span> IBUF<span class="hljs-emphasis">_BITMAP</span><br><span class="hljs-emphasis">3. SYS_</span>insert buffer header<br><span class="hljs-bullet">4.</span> INODE<span class="hljs-emphasis">_insert buffer root</span><br><span class="hljs-emphasis">5. TRX_</span>SYS: 存储事务系统相关信息<br><span class="hljs-bullet">6.</span> SYS<span class="hljs-emphasis">_first rollback segment: 第一个回滚段信息</span><br><span class="hljs-emphasis">7. SYS_</span>data dictionary header: 数据字段头部信息<br><br>这里简单介绍与 Change Buffer 相关的 IBUF<span class="hljs-emphasis">_BITMAP， SYS_</span>insert buffer header 和 INODE<span class="hljs-emphasis">_insert buffer root 以及数据字典相关的 SYS_</span>data dictionary header， 其他字段都用于事务。<br><br><span class="hljs-section">### Change Buffer</span><br><br>其实 IBUF<span class="hljs-emphasis">_BITMAP 类型的页面在独立表空间也一直出现过，它实质上也是一棵 B+ 树，当我们往表中插入一条记录时，首先完整的记录会被插入到聚簇索引的叶子节点上，其次还需要更新所有二级索引，但这些索引随机处在表空间的不同地方，每次修改这些索引可能引起许多随机 IO，这会影响数据写入的效率，为此，当执行二级索引写入操作时，如果 InnoDB 发现二级索引对应的页面没在内存中，就会暂时把修改数据写到 Change Buffer 里，等服务器空闲时，再把数据写到二级索引对应的页里。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其中，系统表空间的 SYS_</span>insert buffer header 字段用于存储 Change Buffer 的头部信息， INODE<span class="hljs-emphasis">_insert buffer root 用于存储 Change Buffer 的根节点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">### 数据字典</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">InnoDB 的数据字典保存了许多重要的<span class="hljs-strong">**元数据**</span>， 包括：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- 表对应的表空间；</span><br><span class="hljs-emphasis">- 表中有多少列，每一列的类型是什么；</span><br><span class="hljs-emphasis">- 表中有多少索引，索引的字段，索引根节点对应的页面；</span><br><span class="hljs-emphasis">- 外键信息等……</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">这些信息是为了更好的管理用户信息而存在的，InnoDB 将他们放在一些内部表中，比较重要的有：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">1. SYS_</span>TABLES: 存储所有表信息<br><span class="hljs-bullet">2.</span> SYS<span class="hljs-emphasis">_COLUMNS: 存储所有列信息</span><br><span class="hljs-emphasis">3. SYS_</span>INDEXS: 存储所有索引xinx<br><span class="hljs-bullet">4.</span> SYS<span class="hljs-emphasis">_FIELDS: 存储所有索引对应的列信息</span><br><span class="hljs-emphasis">5. SYS_</span>TABLESPACES: 存储所有表空间信息<br><span class="hljs-bullet">6.</span> ……<br><br>其中，前四个表被称为四个基本表，使用这四个表，我们就可以获取其他系统表和用户数据了，比如更具表名就可以在 SYS<span class="hljs-emphasis">_TABLES 表里获取到 Table ID, 根据 ID 到 SYS_</span>COLUMNS 就可以获取到所有列信息，还可以到 SYS<span class="hljs-emphasis">_FIELDS 和 SYS_</span>INDEXS 获取到索引信息……<br><br><span class="hljs-quote">&gt; 具体操作要看这四张表的具体结构</span><br><br>其他表可以使用这四张表定位，那这四张表该怎么定位呢？答案是硬编码，这四张表的信息被硬编码到了系统表空间的第七页上，也就是 SYS<span class="hljs-emphasis">_data dictionary header 关于这一页的结构就不赘述了。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">需要注意的是，这些内部系统表用户是不能直接访问的，但 InnoDB 为了用户能更好的使用存储引擎，提供了这些内部表的映射，对应数据库 `information_</span>schema<span class="hljs-code">`, 这里面有一些 INNODB 开头的表， 如 `</span>INNODB<span class="hljs-emphasis">_TABLES` 的表结构如下：</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>CREATE TEMPORARY TABLE <code>INNODB_TABLES</code> (<br><code>TABLE_ID</code> bigint(21) unsigned NOT NULL DEFAULT ‘0’,<br><code>NAME</code> varchar(655) NOT NULL DEFAULT ‘’,<br><code>FLAG</code> int(11) NOT NULL DEFAULT ‘0’,<br><code>N_COLS</code> int(11) NOT NULL DEFAULT ‘0’,<br><code>SPACE</code> bigint(21) NOT NULL DEFAULT ‘0’,<br><code>ROW_FORMAT</code> varchar(12) DEFAULT NULL,<br><code>ZIP_PAGE_SIZE</code> int(11) unsigned NOT NULL DEFAULT ‘0’,<br><code>SPACE_TYPE</code> varchar(10) DEFAULT NULL,<br><code>INSTANT_COLS</code> int(11) NOT NULL DEFAULT ‘0’<br>) ENGINE&#x3D;MEMORY DEFAULT CHARSET&#x3D;utf8;</p></li></ul><p>&#96;&#96;&#96;</p><ul><li>TABLE_ID: 表ID</li><li>NAME：表名</li><li>FLAG：有关表格式和存储特性的位级信息数据，包括行格式，压缩页大小（如果适用）以及DATA DIRECTORY子句是否与CREATE TABLE或ALTER TABLE一起使用等，参考 <a href="https://link.zhihu.com/?target=https://dev.mysql.com/doc/refman/5.7/en/innodb-sys-tables-table.html">24.32.22 The INFORMATION_SCHEMA INNODB_SYS_TABLES Table</a></li><li>N_COLS: 表中有多少列</li><li>SPACE：表所属表空间 ID</li><li>ROW_FORMAT：行格式，默认为 Dynamic</li><li>ZIP_PAGE_SIZE: 压缩页大小</li><li>SPACE_TYPE: 表所属的表空间类型。可能的值包括：System(系统表空间)、General(普通表空间)、Single(独立表空间)</li><li>INSTANT_COLS：8.0 之后的新特性，表示插入的列的个数，参考 <a href="https://developer.aliyun.com/article/670691">MySQL8.0 - 新特性 - Instant Add Column</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InnoDB 的完整数据存放在聚簇索引的叶子节点上，索引的一个节点就是一页，为了减少随机 IO，当表中的数据很多时，会一次性分配连续的 64 页，称为一个区，每个区由一个 XDES Entry 结构管理，根据区的状态，这些 XDES Entry 会链成不同的链表，链表头节点保存在表空间的第一个页面上，除此之外，为了尽可能保证叶子节点在物理内存上连续， InnoDB 把叶子节点和非叶子节点通过段分开，每个段由 Inode Entry 管理。</p><p>当定位到页后，InnoDB 还提供了页目录来提高页内检索速度。</p><p>MySQL 服务共有的信息被存储在系统表空间中，最重要的是 InnoDB 数据字典，通过它，我们才可以获取到表空间中的记录。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议详解(HTTP、HTTP2、HTTP3)</title>
    <link href="/2022/07/01/HTTP/"/>
    <url>/2022/07/01/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h1><p>为什么会出现 HTTP 协议，从 HTTP1.0 到 HTTP3 经历了什么？HTTPS 又是怎么回事？</p><p>HTTP 是一种用于获取类似于 HTML 这样的资源的 <strong>应用层通信协议</strong>， 他是万维网的基础，是一种 CS 架构的协议，通常来说，HTTP 协议一般由浏览器等 “客户端” 发起，发起的这个请求被称为 Request, 服务端接受到客户端的请求后，会返回给客户端所请求的资源，这一过程被称为 Response，在大部分情况下，客户端和服务器之间还可能存在许多 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Proxy">proxies</a>，他们的作用可能各不相同，有些可能作为网关存在，有些可能作为缓存存在。</p><p><img src="https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1609752900346-1609752900153.png"></p><p>HTTP 协议有三个基本的特性：</p><ol><li>简单：HTTP 的协议和报文是简单，易于理解和阅读的（HTTP&#x2F;2 已经改用二进制传输数据，但 HTTP 整体还是简单的）</li><li>可拓展的：请求和响应都包括 “Header” 和 “Body” 两部分，我们可以通过添加头部字段轻松的拓展 HTTP 的功能</li><li>无状态的：服务端不保存客户端状态，也就是说每一次请求的服务端来说都是唯一无差别的，我们只能通过 Cookie 等技术创建有状态的会话。</li></ol><h2 id="HTTP-的历史"><a href="#HTTP-的历史" class="headerlink" title="HTTP 的历史"></a>HTTP 的历史</h2><p>HTTP 的历史可以追溯到万维网刚被发明的时候，1989年， Tim Berners-Lee 博士写了一份关于建立一个<strong>通过网络传输超文本系统</strong>的报告。该系统起初被命名为 <em>Mesh</em>，在随后的1990年项目实施期间被更名为万维网（World Wide Web）。他以现有的 TCP IP 协议为基础建造， 由四个部分组成：</p><ul><li>用来表示超文本文档的文本格式，即超文本标记语言（HTML）</li><li>一个用来传输超文本的简单应用层协议，即超文本传输协议（HTTP）</li><li>一个用来显示或编辑超文本文档的客户端，即网络浏览器，而第一个浏览器则被称为 <em>WorldWideWeb</em></li><li>一个用于提供可访问文档的服务，<a href="https://zh.wikipedia.org/wiki/Httpd">httpd</a> 的前身.</li></ul><p>这四部分在 1990 年底完成，这时候的 HTTP 协议还很简单，后来为了于其他版本的协议区分，最初的 HTTP 协议被记为 HTTP&#x2F;0.9，</p><p>后来，随着计算机技术的发展，HTTP 协议也随着 HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2 等关键版本更迭变得更加高效实用。</p><h3 id="HTTP-x2F-0-9-on-line"><a href="#HTTP-x2F-0-9-on-line" class="headerlink" title="HTTP&#x2F;0.9 on-line"></a>HTTP&#x2F;0.9 on-line</h3><p>最初的 0.9 版本也被称为单行协议（on-line）, 基于 TCP 协议，该版本下只有一个可用的请求方法：GET， 请求格式也相当简单：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">GET /index.html<br></code></pre></td></tr></table></figure><p>它表示客户端请求 <code>index.html</code> 的内容，0.9 版本的 HTTP 响应也同样简单，他只允许响应 HTML 格式的字符串，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> ..... <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这一阶段的响应甚至没有响应头，也没有响应码或错误代码，一旦出现问题，服务端会响应一段特殊的 HTML 字符串以便客户端查看。 服务端在发送完数据后，就会立刻关闭 TCP 连接。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>0.9 版本的 HTTP 协议太过于简单甚至是简陋，而随着浏览器和服务器的应用被扩展到越来越多的领域，0.9 版本的协议已经不能适应，直到 1996年11月，<a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> 定义了 HTTP&#x2F;1.0, 但他并不是官方标准，该版本的 HTTP 协议较 0.9 版本有了一下改变：</p><ol><li><p>版本号被添加到了请求头上，像下面这样：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/mypage.html</span> <span class="hljs-meta">HTTP/1.0</span><br></code></pre></td></tr></table></figure></li><li><p>引入了 HTTP头的概念，无论是请求还是响应，允许传输元数据，这使得协议更加灵活和具有拓展性。</p></li><li><p>请求方法拓展到了 GET，HEAD，POST</p></li><li><p>在新 HTTP 头（<code>Content-Type</code>）的帮助下，可以传输不止 HTML 的任意格式的数据。</p></li><li><p>响应时带上了状态码，使得浏览器能够知道响应的状态并作出响应的处理。</p></li><li><p>…</p></li></ol><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>同 0.9 版本一样，1.0 版本下，TCP 连接是不能复用的，数据发送完后服务端会立刻关闭连接，但由于建立 TCP 连接的代价较大，所以 1.0 版本的 HTTP 协议并不是足够高效，加上 HTTP&#x2F;1.0 多种不同的实现方式在实际运用中显得有些混乱，自1995年就开始了 HTTP 的第一个标准化版本的修订工作，到1997年初，HTTP1.1 标准发布。</p><p>1.1 版本的改进包括：</p><ol><li><p>支持长连接：在 HTTP1.1 中默认开启 Connection： keep-alive，允许在一个 TCP 连接上传输多个 HTTP 请求和响应，减少了建立和关闭连接造成的性能消耗。</p></li><li><p>支持 <code>pipline</code>: HTTP&#x2F;1.1 还支持流水线（pipline）工作，流水线是指在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。</p></li><li><p>支持响应分块：对于比较大的响应，HTTP&#x2F;1.2 通过 <code>Transfer-Encoding</code> 首部支持将其分割成多个任意大小的分块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p></li><li><p>新的缓存控制机制：HTTP&#x2F;1.1定义的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况，同时，还提供 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match"><code>If-None-Match</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag"><code>ETag</code></a> ,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified"><code>Last-Modified</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since"><code>If-Modified-Since</code></a> 等实现缓存的验证等工作。</p></li><li><p>允许不同域名配置到同一IP的服务器上：在 HTTP&#x2F;1.0 时，认为每台服务器绑定一个唯一的 IP，但随着技术的进步，一台服务器的多个虚拟主机会共享一个IP，为了区分同一服务器上的不同服务，HTTP&#x2F;1.1 在请求头中加入了 <code>HOST</code> 字段，它指明了请求将要发送到的服务器主机名和端口号，这是一个必须字段，请求缺少该字段服务端将会返回 400.</p></li><li><p>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</p></li><li><p>使用了 100 状态码：HTTP&#x2F;1.0 中，定义：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">o 1xx: Informational - Not used, but reserved for future use<br></code></pre></td></tr></table></figure><p>在 2.0 版本时，使用了这个保留的状态码，用来表示临时响应。</p></li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP&#x2F;1.1 之后，对 HTTP 协议的拓展变得更加简单，但 HTTP 依然存在一个天然的缺陷就是明文传输数据，直到 1994 年底，网景公司在 TCP&#x2F;IP 协议栈的基础上添加了 SSL 层用来加密传输，后来，在标准化的过程中， SSL 成了  TLS （Transport Layer Security 传输层安全协议），基于 HTTPS 通信的客户端和服务器在建立完 TCP 连接之后会协商通信密钥，在之后的通信过程中， 客户端和服务器会使用该密钥对数据进行对称加密，以防数据被窃取或篡改。（密钥协商阶段会使用非对称加密）。</p><h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP&#x2F;1.1 虽然允许连接复用和以流水线方式运作，但在一个 TCP 连接里面，所有数据依然还是按序发送的，服务器只能处理完一个请求再去处理另一个请求，如果第一个请求非常慢，就会造成后面的请求长时间阻塞，这被称为 <strong>队头阻塞（Head-of-line blocking）</strong>，2009 年，谷歌公开了自行研发的 SPDY 协议，它基于 HTTPS，并采用多路复用解决了队头阻塞的问题，同时，它还使用了 Header 压缩等技术大大降低了延时并提高了带宽利用率，在之后的 2015 到 2019 年间，谷歌在自家浏览器上实践和证明了这个协议，SPDY 也成了 HTTP&#x2F;2 的基石。</p><p>2015 年 5 月， HTTP&#x2F;2 正式标准化，他与 1.x 版本 不同在于：</p><ol><li>1.x 版的 HTTP 协议传输的是文本信息，这对开发者很友好，但却浪费了计算机的性能，HTTP&#x2F;2 改成了基于二进制而不再是基于文本的协议，</li><li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP&#x2F;1.x中顺序和阻塞的约束。</li><li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li></ol><p>虽然 HTTP&#x2F;2 2015 年就被标准化，在到目前为止，HTTP&#x2F;1.1 任然被广泛使用，据 <a href="https://myssl.com/https_reports.html">MySSL</a> 的最新统计，截至 2020 年 12 月，已有 65.84% 的站点支持了 HTTP&#x2F;2. HTTP2在HTTP1.1的基础上做了很多性能上的优化，如果你想看看具体优化的结果，请访问<a href="https://http2.akamai.com/demo">这里</a></p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;3 是即将到来的第三个主要版本的 HTTP 协议，在 HTTP&#x2F;3 中，将弃用 TCP 协议，改为使用基于 UDP 的 <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">QUIC</a> 协议实现。QUIC（快速UDP网络连接）是一种实验性的网络传输协议，由Google开发，该协议旨在使网页传输更快。</p><p>在2018年10月28日的邮件列表讨论中，<a href="https://zh.wikipedia.org/wiki/IETF">IETF(互联网工程任务组)</a> HTTP和QUIC工作组主席 <a href="https://zh.wikipedia.org/w/index.php?title=Mark_Nottingham&action=edit&redlink=1">Mark Nottingham</a> 提出了将 HTTP-over-QUIC 更名为 HTTP&#x2F;3 的正式请求，以“明确地将其标识为HTTP语义的另一个绑定……使人们理解它与 QUIC 的不同”，并在最终确定并发布草案后，将 QUIC 工作组继承到 HTTP 工作组, 在随后的几天讨论中，Mark Nottingham 的提议得到了 IETF 成员的接受，他们在2018年11月给出了官方批准，认可 HTTP-over-QUIC 成为 HTTP&#x2F;3。</p><p>2019年9月，HTTP&#x2F;3支持已添加到 CloudFlare 和 Chrome 上。Firefox Nightly 也将在2019年秋季之后添加支持。</p><h2 id="HTTP-x2F-1-1-细节"><a href="#HTTP-x2F-1-1-细节" class="headerlink" title="HTTP&#x2F;1.1 细节"></a>HTTP&#x2F;1.1 细节</h2><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP 的报文都由消息头和消息体两部分组成，两者之间以 <code>CRLF(回车换行)</code> 分割。</p><h4 id="请求头格式"><a href="#请求头格式" class="headerlink" title="请求头格式"></a>请求头格式</h4><p>请求头第一行为<strong>请求行</strong>，其余为请求头字段：如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/api/article/list</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>junebao.top:8888<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>application/json, text/plain, */*<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json;charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>32<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://junebao.top<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://junebao.top/<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br></code></pre></td></tr></table></figure><p>请求行由三部分组成：</p><ol><li>请求方法</li><li>请求资源的 url</li><li>协议版本</li></ol><p>他们以空格分隔，<a href="https://tools.ietf.org/html/rfc2068#section-5.1.1">RFC2068</a> 定义了其中不同的请求方法，他们分别为  OPTIONS， GET， HEAD， POST， PUT， DELETE， TRACE,除此之外，后来还添加了一个 PATCH 方法。</p><table><thead><tr><th>方法</th><th>基本用法</th><th>请求</th><th>响应</th><th>幂等性</th><th>缓存</th><th>安全性</th></tr></thead><tbody><tr><td>OPTIONS</td><td>获取目的资源所支持的通信选项,如检测服务器所支持的请求方法或CORS预检请求</td><td>不能携带请求体或数据</td><td>可以携带响应体，但一般有效数据被放在头部如 Allow 等字段</td><td>幂等</td><td>不可缓存</td><td>安全</td></tr><tr><td>GET</td><td>用于获取某个资源</td><td>参数一般携带在 URL 后面，没有请求体</td><td>有响应体</td><td>幂等</td><td>可缓存</td><td>安全</td></tr><tr><td>HEAD</td><td>用于请求资源的头部信息，如下载前获取大文件的大小</td><td>没有请求体</td><td>没有响应体，响应头应该与使用 GET 请求时的一样</td><td>幂等</td><td>可缓存</td><td>安全</td></tr><tr><td>POST</td><td>将数据发送给服务器</td><td>数据放在请求体中</td><td>有响应体</td><td>不幂等</td><td>可缓存（包含新鲜信息时）</td><td>不安全</td></tr><tr><td>PUT</td><td>使用请求中的负载创建或替换目标资源</td><td>数据放在请求体中</td><td>有响应体</td><td>幂等</td><td>不可缓存</td><td>不安全</td></tr><tr><td>DELETE</td><td>删除指定资源</td><td>可以由请求体</td><td>可以由响应体</td><td>幂等</td><td>不可缓存</td><td>不安全</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td><td>无请求体</td><td>无响应体</td><td>幂等</td><td>不可缓存</td><td>不安全</td></tr><tr><td>PATCH</td><td>作为 PUT 的补充，用于修改已知资源的部分</td><td>有请求体</td><td>无响应体</td><td>非幂等</td><td>不可缓存</td><td>不安全</td></tr></tbody></table><h5 id="请求头字段"><a href="#请求头字段" class="headerlink" title="请求头字段"></a>请求头字段</h5><p><a href="https://tools.ietf.org/html/rfc2068#section-5.3">RFC 2068</a> 提供了 17 种请求头字段，但 HTTP 协议是易于拓展的，我们可以根据自己的需要添加自己的请求头，常见的请求头字段包括：</p><table><thead><tr><th>字段</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>HOST</td><td>指明了要发送到的服务器的主机号和端口号，这是一个必须字段，缺失服务器一般会返回 400,<br />端口号默认 80 和 443</td><td>Host: <a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>ACCEPT</td><td>告知服务器客户端可以处理的内容类型，用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a>来表示。</td><td>Accept: text&#x2F;html</td></tr><tr><td>User-Agent</td><td>用户代理标识</td><td></td></tr><tr><td>Cookies</td><td>用于维持会话</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><h4 id="响应头格式"><a href="#响应头格式" class="headerlink" title="响应头格式"></a>响应头格式</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">Response      = Status-Line<br>                *( general-header<br>                | response-header<br>                | entity-header )<br>                CRLF<br>                [ message-body ]<br></code></pre></td></tr></table></figure><p>类似于请求头，响应头包括状态行和响应头字段两部分组成。</p><p>状态行包括协议版本，状态码，状态描述三部分组成，类似：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http/2 200 ok<br></code></pre></td></tr></table></figure><p>目前 http 使用的状态码分为 5 类：</p><ul><li>1xx: 信息响应类</li><li>2xx: 正常响应类</li><li>3xx: 重定向类</li><li>4xx: 客户端错误类</li><li>5xx: 服务端错误类</li></ul><h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><table><thead><tr><th>状态码</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>迄今为止的所有内容都是可行的，客户端应该继续请求</td></tr><tr><td>200</td><td>Ok</td><td>请求成功</td></tr><tr><td>201</td><td>Created</td><td>该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久重定向</td></tr><tr><td>302</td><td>Found</td><td>临时重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>请求参数错误或语义错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求未认证</td></tr><tr><td>403</td><td>Forbidden</td><td>拒绝服务</td></tr><tr><td>404</td><td>Not Found</td><td>资源不存在</td></tr><tr><td>429</td><td>Too Many Requests</td><td>超过请求速率限制（节流）</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务端未知异常</td></tr><tr><td>501</td><td>Not Implemented</td><td>此请求方法不被服务端支持</td></tr><tr><td>502</td><td>Bad Gateway</td><td>网关错误</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务不可用</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>HTTP 版本不被支持</td></tr></tbody></table><h3 id="无状态的-HTTP"><a href="#无状态的-HTTP" class="headerlink" title="无状态的 HTTP"></a>无状态的 HTTP</h3><p>HTTP 是一个无状态的协议，为了维持会话，每客户端请求时，都应该携带一个 “凭证”，证明 who am i, 目前维持会话常用的技术有：cookie, session, token, 等</p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p><a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a> 定义了 Cookie 的工作方式, Cookie 是服务器发送给客户端并存储在本地的一小段数据，在用户第一次登录时，服务器生成 Cookie 并在响应头里添加 <code>Set-Cookie</code> 字段，客户端收到响应后，将 <code>Set-Cookie</code> 字段的值（Cookie）存储在本地，以后每次请求时，客户端会自动通过 <code>Cookie</code> 字段携带 Cookie。</p><p>Cookie 以键值的形式储存，除了必须的 Name 和 Value，还可以为 Cookie 设置以下属性：</p><ul><li>Domain：指定了哪写主机可以接收该 Cookie，默认为 Origin， 不包含子域名。</li><li>Path：规定了请求主机下的哪些路径时要携带该 Cookie。</li><li>Expires&#x2F;Max-Age: 规定该 Cookie 过期时间或最大生存时间，该时间只与客户端有关。</li><li>HttpOnly: JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie"><code>Document.cookie</code></a> API 无法访问带有 HttpOnly 属性的cookie,用于预防 XSS 攻击；用于持久化会话的 Cookie 一般应该设置 HttpOnly 。</li><li>Secure：标记为 Secure 的 Cookie 只能使用 HTTPS 加密传输给服务器，因此可以防止中间人攻击，但 Cookie 天生具有不安全性，任何敏感数据都不应该使用 Cookie 传输，哪怕标记了 secure.</li><li>Priority：</li><li>SameSite：要求该 Cookie 在跨站请求时不会被发送，用来阻止 CSRF 攻击，它有三种可选的值：<ul><li>None：在同站请求和跨站请求时都会携带上 Cookie</li><li>Strict：只会在访问同站请求时带上 Cookie</li><li>Lex：与 Strict 类似，但用户从外部站点导航至URL时（例如通过链接）除外，新版浏览器一般以 Lex 为默认选项。</li></ul></li></ul><p>Cookie 被完全保存在客户端，对客户端用户来说是透明的，用户可以自己创建和修改 Cookie，所以将敏感信息（如用于持久化会话的用户身份信息等）存放在 Cookie 中是十分危险的，如果不得已需要使用 Cookie 来存储和传递这类信息，应该考虑使用 JWT 等类似机制。</p><p>由于 Cookie 的不安全性，绝大部分 Web 站点已经开始停止使用 Cookie 持久化会话，但 Cookie 在一些对安全性要求不高的场景下依然被广泛使用，如：</p><ul><li>个性化设置</li><li>浏览器用户行为跟踪。</li></ul><blockquote><p>了解更多：</p><p><a href="https://www.sohu.com/a/259750790_185201">超级 Cookie 和僵尸 Cookie</a></p><p><a href="https://yq.aliyun.com/articles/299884/">决战僵尸 Cookie</a></p></blockquote><h4 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h4><p>Cookie 不安全的根源在于它将会话信息保存在了客户端，为此，就有了使用 Session 持久化会话的方案，用户在第一次登录时，服务器会将用户会话状态信息保存在服务器内存中，同时会为这段信息生成一串唯一索引，将这个索引作为 Cookie （Name 一般为 SESSION_IDSESSION_ID）返回给客户端，客户端下一次请求时，会自动携带这个 SESSION_ID, 服务器只需要根据 SESSION_ID 的值找到对应的状态信息就可以知道这次请求是谁发起的。</p><p>SESSION 很大程度上还是依赖于 Cookie，但这时 Cookie 中保存的已经是一段对客户端来说无意义的字符串了，因此使用 Session 能安全的实现会话持久化，但 Session 信息被保存在服务器内存中，可能造成服务器压力过大，并且在分布式和前后端分离的环境下，Session 并不容易拓展。</p><h4 id="TOKEN"><a href="#TOKEN" class="headerlink" title="TOKEN"></a>TOKEN</h4><p>Cookie 和 Session 都是开箱即用的 API，因此，他们不可避免地缺少灵活性，在一般开发中，往往采用更灵活地 Token，Token 与 Session 原理一致，都是将会话信息保存到服务器，然后向客户端返回一个该信息的索引（token），但 Token 完全由开发者实现，可以根据需要将会话信息存储在内存，数据库，文件等地方，而对于该信息的索引，也可以根据具体需要选择使用请求头，请求体或者 Cookie 传递，也不必拘束于只 Cookie 传递。</p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>全称 json web token, 是一种客户端存储会话状态的技术，它使用数字签名技术防止了负荷信息被篡改，jwt 包含三部分信息：</p><ul><li>Header：包含 token 类型和算法名称</li><li>Payload：存储的负载信息（敏感信息不应该明文存放在此）</li><li>Signature：服务端使用私钥对 Header 和 Payload 的签名，防止信息被篡改。</li></ul><p>这三部分原本都是 json 字符串，最终他们会经过 Base64 编码后拼接到一起，使用 <code>.</code> 分割。</p><h4 id="分布式解决方案"><a href="#分布式解决方案" class="headerlink" title="分布式解决方案"></a>分布式解决方案</h4><p>在分布式场景下，同一用户的不同次请求可能会被打到不同的服务器上，这时如果还像单机时那样存储，就会出问题，一般的解决方案包括：</p><ul><li>粘性 session：将用户绑定到一台服务器上，如 Nginx 负载均衡策略使用 ip_hash, 但这样如果当前服务器发生故障，可能导致分配到这台服务器上的用户登录信息失效，容错度低。</li><li>session 复制：一台服务器的 session 改变，就广播给所有服务器，但会影响服务器性能</li><li>session 共享：把所有服务器的 session 放在一起，如使用 redis 等分布式缓存做 session 集群。</li><li>客户端记录状态：使用诸如 JWT 之类的方法。</li></ul><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>连接管理是一个 HTTP 的关键话题：打开和保持连接在很大程度上影响着网站和 Web 应用程序的性能。在 HTTP&#x2F;1.x 里有多种模型：<strong>短连接</strong> <strong>长连接</strong>和<strong>HTTP 流水线</strong></p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>HTTP 最早期的模型，也是  HTTP&#x2F;1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p><p>TCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的冷连接降低了其性能。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>短连接有比较大的问题：</p><ul><li>创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后(热连接)才能得到改善。为了缓解这些问题，<em>长连接</em> 的概念便被设计出来了，甚至在 HTTP&#x2F;1.1 之前。或者这被称之为一个 <em>keep-alive</em> 连接。</li></ul><p>一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive"><code>Keep-Alive</code></a> 协议头来指定一个最小的连接保持时间)。</p><blockquote><p>长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 <a href="https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack">DoS attacks</a> 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。</p><p>HTTP&#x2F;1.0 里默认并不使用长连接。把 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 设置成 <code>close</code> 以外的其它参数都可以让其保持长连接，通常会设置为 <code>retry-after。</code></p></blockquote><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>默认情况下，<a href="https://developer.mozilla.org/en/HTTP">HTTP</a> 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 <a href="https://en.wikipedia.org/wiki/Maximum_segment_size">MSS</a>(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。</p><p>并不是所有类型的 HTTP 请求都能用到流水线：只有 <a href="https://developer.mozilla.org/en-US/docs/Glossary/idempotent">idempotent</a> 方式，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE"><code>DELETE</code></a> 能够被安全的重试：如果有故障发生时，流水线的内容要能被轻易的重试。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/1460000013594854" alt="image"></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><strong>跨源资源共享</strong> (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a>) （或通俗地译为跨域资源共享）是一种基于<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 头的安全机制，该机制通过允许服务器标示除了它自己以外的其它<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90">origin</a>（域，协议和端口），这样浏览器可以访问加载这些资源。出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</p><p>跨源HTTP请求的一个例子：运行在 <a href="http://domain-a.com/">http://domain-a.com</a> 的JavaScript代码使用ajax来发起一个到 <a href="https://domain-b.com/data.json">https://domain-b.com/data.json</a> 的请求。</p><p><img src="https://mdn.mozillademos.org/files/14295/CORS_principle.png" alt="CORS-DEMO"></p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）除了被用户代理自动设置的首部字段（例如 <code>Connection</code>，<code>User-Agent</code>）和在 Fetch 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</p></li><li><p><code>DPR</code></p></li><li><p><code>Downlink</code></p></li><li><p><code>Save-Data</code></p></li><li><p><code>Viewport-Width</code></p></li><li><p><code>Width</code></p></li><li><p><code>Content-Type</code>的值仅限于下列三者之一：</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true<br><span class="hljs-attribute">Access-Control-Expose-Headers</span><span class="hljs-punctuation">: </span>FooBar<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br></code></pre></td></tr></table></figure></blockquote><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://api.alice.com/cors&#x27;</span>;<br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）Access-Control-Request-Method</strong></p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p><p><strong>（2）Access-Control-Request-Headers</strong></p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。否则不作出回应，也就是我们会经常性的出现的一种开发服务时候的错误。</p><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p><strong>HTTP&#x2F;1.1</strong>定义的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><ul><li><pre><code class="html">Cache-Control: no-store  无缓存<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ``` html<br><span class="hljs-title">  Cache-Control:</span> no-cache  缓存但重新验证，此方式下，每次有请求发出时，缓存会将此请求发到服务器,服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回<span class="hljs-number">304</span>），则缓存才使用本地缓存副本。<br></code></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;html<br>Cache-Control: private<br>Cache-Control: public  “public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">#### 缓存的过期机制</span><br><br>缓存的过期机制中，最重要的指令是 <span class="hljs-string">&quot;`max-age=&lt;seconds&gt;`&quot;</span>，表示资源能够被缓存（保持新鲜）的最大时间。相对[Expires](https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Web/</span>HTTP<span class="hljs-regexp">/Headers/</span>Expires)而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。<br><br>```html<br>Cache-Control: max-age=<span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="HTTPS-细节"><a href="#HTTPS-细节" class="headerlink" title="HTTPS 细节"></a>HTTPS 细节</h2><h3 id="HTTPS的请求过程"><a href="#HTTPS的请求过程" class="headerlink" title="HTTPS的请求过程"></a>HTTPS的请求过程</h3><p>1、浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。<br>2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。<br>3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。（注释：证书包括以下这些内容：1. 证书序列号。2. 证书过期时间。3. 站点组织名。4. 站点DNS主机名。5. 站点公钥。6. 证书颁发者名。7. 证书签名。因为证书就是要给大家用的，所以不需要加密传输）<br>4、浏览器进入数字证书认证环节，这一部分是浏览器内置的 TSL 完成的：<br>    <strong>4.1</strong> 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。<br>    <strong>4.2</strong> 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。<br>    <strong>4.3</strong> 浏览器生成一个随机数 R，并使用网站公钥对 R 进行加密。<br>5、浏览器将加密的 R 传送给服务器。<br>6、服务器用自己的私钥解密得到 R。<br>7、服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。<br>8、浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。</p><p>对其中细节的深究可以参见：<a href="https://zhuanlan.zhihu.com/p/43789231">https://zhuanlan.zhihu.com/p/43789231</a></p><h2 id="HTTP-x2F-2-细节"><a href="#HTTP-x2F-2-细节" class="headerlink" title="HTTP&#x2F;2 细节"></a>HTTP&#x2F;2 细节</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>2015 年，HTTP&#x2F;2 发布。HTTP&#x2F;2 是现行 HTTP 协议（HTTP&#x2F;1.x）的替代，但它不是重写，HTTP 方法&#x2F;状态码&#x2F;语义都与 HTTP&#x2F;1.x 一样。HTTP&#x2F;2 基于 SPDY3，专注于<strong>性能</strong>，最大的一个目标是在用户和网站间只用一个连接（connection）。</p><p><strong>那么SPDY3是什么呢？</strong></p><p>SPDY是谷歌自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。谷歌推出 SPDY，才算是正式改造 HTTP 协议本身。降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 HTTP&#x2F;2 的诞生。</p><p>HTTP&#x2F;2 由两个规范（Specification）组成：</p><ol><li>Hypertext Transfer Protocol version 2 - <a href="https://tools.ietf.org/html/rfc7540">RFC7540</a></li><li>HPACK - Header Compression for HTTP&#x2F;2 - <a href="https://tools.ietf.org/html/rfc7541">RFC7541</a></li></ol><p><strong>那么HTTP2在HTTP1.1的基础上做了哪些改进</strong></p><ul><li>二进制传输</li><li>请求和响应复用</li><li>Header压缩</li><li>Server Push（服务端推送）</li></ul><h4 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h4><p>HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP &#x2F; 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong>HTTP&#x2F;2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong>。</p><p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP&#x2F;2 的三个概念：</p><ul><li><em>数据流</em>：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li><em>消息</em>：与逻辑请求或响应消息对应的完整的一系列帧。</li><li><em>帧</em>：HTTP&#x2F;2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的关系总结如下：</p><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg?hl=zh-cn" alt="HTTP/2 数据流、消息和帧"></p><h4 id="请求和响应复用"><a href="#请求和响应复用" class="headerlink" title="请求和响应复用"></a>请求和响应复用</h4><p>在 HTTP&#x2F;1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接这是 HTTP&#x2F;1.x 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。 更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。</p><p>HTTP&#x2F;2 中新的二进制分帧层突破了这些限制，实现了完整的<strong>请求和响应复用</strong>：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。</p><p>在 HTTP&#x2F;2 中，有了二进制分帧之后，HTTP &#x2F;2 不再依赖 TCP 链接去实现多流并行了，在 HTTP&#x2F;2 中：</p><ul><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><p>这一特性，使性能有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>在 HTTP&#x2F;2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2019-03-06-4.png"></p><h4 id="Header压缩"><a href="#Header压缩" class="headerlink" title="Header压缩"></a>Header压缩</h4><p>在 HTTP&#x2F;1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。为了减少这块的资源消耗并提升性能，HTTP&#x2F;2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种强大的技术：</p><ol><li>这种格式支持通过<strong>静态霍夫曼代码对传输的标头字段进行编码</strong>，从而减小了各个传输的大小。</li><li>这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的<strong>索引列表</strong>（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。</li></ol><p>利用霍夫曼编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。</p><p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/header_compression01.svg?hl=zh-cn" alt="HPACK：HTTP/2 的标头压缩"></p><p>作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表；动态表最初为空，将根据在特定连接内交换的值进行更新。 因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p><p>注：在 HTTP&#x2F;2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p><p>如需了解有关 HPACK 压缩算法的完整详情，请参阅 <a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-compression">IETF HPACK - HTTP&#x2F;2 的标头压缩</a>。</p><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>HTTP&#x2F;2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源如下图所示，而无需客户端明确地请求。</p><p><img src="https://developers.google.com/web/fundamentals/performance/http2/images/push01.svg?hl=zh-cn" alt="服务器为推送资源发起新数据流 (promise) "></p><p>为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p><p>事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产（请参阅<a href="https://hpbn.co/http1x/#resource-inlining">资源内联</a>），那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP&#x2F;2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：</p><ul><li>由客户端缓存</li><li>在不同页面之间重用</li><li>与其他资源一起复用</li><li>由服务器设定优先级</li><li>被客户端拒绝</li></ul><h5 id="服务端推送如何实现"><a href="#服务端推送如何实现" class="headerlink" title="服务端推送如何实现"></a>服务端推送如何实现</h5><p>所有服务器推送数据流都由 <code>PUSH_PROMISE</code> 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。 这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。 满足此要求的最简单策略是先于父响应（即，<code>DATA</code> 帧）发送所有 <code>PUSH_PROMISE</code> 帧，其中包含所承诺资源的 HTTP 标头。</p><p>在客户端接收到 <code>PUSH_PROMISE</code> 帧后，它可以根据自身情况选择拒绝数据流（通过 <code>RST_STREAM</code> 帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。） 这是一个相对于 HTTP&#x2F;1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP&#x2F;1.x“优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源。</p><p>使用 HTTP&#x2F;2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。 这些优先级在 HTTP&#x2F;2 连接开始时通过 <code>SETTINGS</code> 帧传输，可能随时更新。</p><h3 id="过渡到-HTTP-x2F-2"><a href="#过渡到-HTTP-x2F-2" class="headerlink" title="过渡到 HTTP&#x2F;2"></a>过渡到 HTTP&#x2F;2</h3><p>上面说了这么多，我们要如何启用HTTP2呢？</p><p>对应Nginx服务器参见：</p><p><a href="https://jkzhao.github.io/2018/01/16/Nginx%E9%85%8D%E7%BD%AEHTTP-2-0/">https://jkzhao.github.io/2018/01/16/Nginx%E9%85%8D%E7%BD%AEHTTP-2-0/</a></p><p>spring boot使用的话如果你是使用的内置的Tomcat服务器，那么只需要在配置文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">http2:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-string">on</span><br></code></pre></td></tr></table></figure><p>Tomcat 服务器：</p><p>只有Tomcat 9 版本之后版本才支持HTTP2协议。在 conf&#x2F;server.xml 中增加内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span> <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">SSLEnabled</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">UpgradeProtocol</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.coyote.http2.Http2Protocol&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span> <span class="hljs-attr">honorCipherOrder</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span> <span class="hljs-attr">certificateKeyFile</span>=<span class="hljs-string">&quot;conf/ca.key&quot;</span> <span class="hljs-attr">certificateFile</span>=<span class="hljs-string">&quot;conf/ca.crt&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其余服务器的话大家应该网上已经有很多文章去介绍了，大家去查一下吧。</p><h2 id="HTTP-x2F-3-细节"><a href="#HTTP-x2F-3-细节" class="headerlink" title="HTTP&#x2F;3 细节"></a>HTTP&#x2F;3 细节</h2><h3 id="为什么要出现HTTP3"><a href="#为什么要出现HTTP3" class="headerlink" title="为什么要出现HTTP3"></a>为什么要出现HTTP3</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 <code>TCP 协议</code>造成的。</p><p>上文提到 HTTP&#x2F;2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP&#x2F;2 的表现情况反倒不如 HTTP&#x2F;1 了。</p><p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP&#x2F;1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p><p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><p>基于这个原因，<strong>Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP&#x2F;3 上</strong>，HTTP&#x2F;3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP&#x2F;3 最大的改造就是使用了 QUIC（快速 UDP Internet 连接）。</p><h3 id="QUIC-功能"><a href="#QUIC-功能" class="headerlink" title="QUIC 功能"></a>QUIC 功能</h3><h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p><p>这里面有两层含义:</p><ul><li>传输层 0 RTT 就能建立连接。</li><li>加密层 0 RTT 就能建立加密连接。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/4d8ca515daf3e1956250032f998086a1.png" alt="img"></p><p>上图中间是HTTPS的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。但是HTTP3使用的QUIC由于建立在 UDP 的基础上，同时又实现了 0 RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>虽然 HTTP&#x2F;2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p><p>同 HTTP2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待，就可以发给用户。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2019-03-06-8.png" alt="img"></p><h4 id="加密认证的报文"><a href="#加密认证的报文" class="headerlink" title="加密认证的报文"></a>加密认证的报文</h4><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><h4 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h4><p>QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。<strong>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</strong>。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>可见HTTP3在效率上和安全性上都有了很大程度上的修改，但是由于目前这个标准还在论证中，Nginx等也只是在测试版中加入了对HTTP3的支持，等到技术真正的论证实现完成，我们就可以使用上快速且安全的HTTP3协议了，期待着这一天的到来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">mozilla 开发文档</a></p><p><a href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn">谷歌开发文档 HTTP2 简介</a></p><p><a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">一文读懂HTTP2和HTTP3</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">WIKI</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合框架八股文</title>
    <link href="/2022/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h3><p><strong>集合框架</strong>：用于存储数据的容器。</p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。<br>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p><p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p><p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p><p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。<br>它减少了程序设计的辛劳。</p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。<br>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p><h3 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h3><p>集合的特点主要有如下两点：</p><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><p><strong>数据结构</strong>：就是容器中存储数据的方式。</p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参阅顶层内容。建立底层对象。</strong></p><h3 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h3><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h3 id="List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？"></a>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc?x-oss-process=image/format,png" alt="img"></p><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set两大接口</p><ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><p>Collection</p><ol><li>List</li></ol><ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul><ol><li>Set</li></ol><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul><p>Map</p><ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h3><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h3 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol><h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list. add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);<br>clist. add(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System. out. println(list. size());<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Iterator&lt;String&gt; it = list. iterator();<br><span class="hljs-keyword">while</span>(it. hasNext())&#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it. next();<br>  System. out. println(obj);<br>&#125;<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h4 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>   *<span class="hljs-comment">// do something*</span><br>   it.remove();<br>&#125;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Integer i : list)&#123;<br>   list.remove(i)<br>&#125;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><p>遍历方式有以下几种：</p><ol><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ol><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><h4 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul><p>ArrayList 的缺点如下：</p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul><p>ArrayList 比较适合顺序添加、随机访问的场景。</p><h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.toArray();<br><br><span class="hljs-comment">// array to list</span><br>String[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>&#125;;<br>Arrays.asList(array);<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p>补充：数据结构基础之双向链表</p><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h4 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</p><h4 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h4><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);<br>synchronizedList.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>synchronizedList.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; synchronizedList.size(); i++) &#123;<br>    System.out.println(synchronizedList.get(i));<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h4 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 中的数组定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>再看一下 ArrayList 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span> <span class="hljs-keyword">throws</span> java.io.IOException&#123;<br>    *<span class="hljs-comment">// Write out element count, and any hidden stuff*</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>    s.defaultWriteObject();<br>    *<span class="hljs-comment">// Write out array length*</span><br>        s.writeInt(elementData.length);<br>    *<span class="hljs-comment">// Write out all elements in the proper order.*</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>            s.writeObject(elementData[i]);<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>&#125;<br><span class="hljs-number">123456789101112</span><br></code></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h4 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h4><p>List , Set 都是继承自Collection 接口</p><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p>Set和List对比</p><p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure><p><strong>hashCode（）与equals（）的相关规定</strong>：</p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>&#x3D;&#x3D;与equals的区别</strong></p><ol><li>&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较&#x3D;&#x3D;</li><li>指引用是否相同 equals()指的是值是否相同</li></ol><h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="BlockingQueue是什么？"><a href="#BlockingQueue是什么？" class="headerlink" title="BlockingQueue是什么？"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>queue. offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>HashMap 基于 Hash 算法实现的</p><ol><li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ol><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p><h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。**数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；**所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法**的方式可以解决哈希冲突。</p><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="jdk1.7中HashMap数据结构"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="jdk1.8中HashMap数据结构"></p><h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 &#x3D; 9次扰动 &#x3D; 4次位运算 + 5次异或运算</td><td>扰动处理 &#x3D; 2次扰动 &#x3D; 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部&#x2F;红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置&#x3D;原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img src="https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="putVal方法执行流程图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//实现Map.put和相关方法</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 步骤①：tab为空则创建 </span><br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 步骤②：计算index，并对null做处理  </span><br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 步骤③：节点key存在，直接覆盖value </span><br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// 步骤④：判断该链为红黑树 </span><br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 步骤⑤：该链为链表 </span><br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <br>                <span class="hljs-comment">//判断该链表尾部指针是不是空的</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">//链表结构转树形结构</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 步骤⑥：超过最大容量就扩容 </span><br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687</span><br></code></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab指向hash桶数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果oldCap不为空的话，就是hash桶数组不为空</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于最大容量了，就赋值为整数最大的阀值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<span class="hljs-comment">//返回</span><br>        &#125;<span class="hljs-comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold 双倍扩容阀值threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span><br>    <span class="hljs-comment">// 直接将该值赋给新的容量</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 新的threshold = 新的cap * 0.75</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 计算出新的数组长度后赋给当前成员变量table</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<span class="hljs-comment">//新建hash桶数组</span><br>    table = newTab;<span class="hljs-comment">//将新数组的值复制给旧的hash桶数组</span><br>    <span class="hljs-comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历新数组的所有桶下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 用同样的hash映射算法把该元素加入新的数组</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 遍历链表</span><br>                    <span class="hljs-keyword">do</span> &#123;             <br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br>                                <span class="hljs-comment">// 代表下标保持不变的链表的头元素</span><br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span>                                <br>                                <span class="hljs-comment">// loTail.next指向当前e</span><br>                                loTail.next = e;<br>                            <span class="hljs-comment">// loTail指向当前的元素e</span><br>                            <span class="hljs-comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br>                            <span class="hljs-comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br>                            <span class="hljs-comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br>                            loTail = e;                           <br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><span class="hljs-number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span><br></code></pre></td></tr></table></figure><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p><h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易</strong>；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n?x-oss-process=image/format,png" alt="img"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</p><h4 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h4><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<span class="hljs-comment">// 与自己右移16位进行异或运算（高低位异或）</span><br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p><h4 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTc5OGYxMzg3ZTNmOGRlOWEucG5n?x-oss-process=image/format,png" alt="img"></p><p>通过上面的**链地址法（使用散列表）**和**扰动函数**我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p><h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h3 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ol><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ol><h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p><ol><li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li></ol><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>那怎么解决呢？</strong></p><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h3 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h3><ol><li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol><h3 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图</strong>：</p><p>HashTable:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY?x-oss-process=image/format,png" alt="img"></p><p>JDK1.7的ConcurrentHashMap：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png" alt="img"></p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk?x-oss-process=image/format,png" alt="img"></p><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h3 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p><strong>JDK1.7</strong></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n?x-oss-process=image/format,png" alt="img"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p><strong>JDK1.8</strong></p><p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><p>结构如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n?x-oss-process=image/format,png" alt="img"></p><p><strong>附加源码，有需要的可以看看</strong></p><p>插入元素过程（建议去看看源码）：</p><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>        <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>&#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>    binCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>        K ek;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((ek = e.key) == key ||<br>             (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>            oldVal = e.val;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                e.val = value;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        Node&lt;K,V&gt; pred = e;<br>        <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>            pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-number">12345678910111213141516171819</span><br></code></pre></td></tr></table></figure><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol><h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA集合框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型详解</title>
    <link href="/2021/10/01/IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/10/01/IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>有五种I&#x2F;O模型：</p><ol><li>阻塞型I&#x2F;O：blocking IO</li><li>非阻塞型I&#x2F;O：nonblocking IO</li><li>I&#x2F;O复用：IO multiplexing</li><li>信号驱动I&#x2F;O：signal driven IO</li><li>异步I&#x2F;O：asynchronous IO</li></ol><p>对于一个network IO (以read举例)，它会涉及到两个系统对象：一个是调用这个IO的进程，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><p><strong>阶段1：</strong>等待数据准备 (Waiting for the data to be ready)</p><p><strong>阶段2：</strong> 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010165434.png" alt="img"></p><h3 id="阻塞型I-x2F-O"><a href="#阻塞型I-x2F-O" class="headerlink" title="阻塞型I&#x2F;O"></a>阻塞型I&#x2F;O</h3><p>阻塞型IO就是，<strong>数据的读入和写出都在一个线程内，需要等待其完成。</strong></p><p>​当在使用阻塞IO的时候，应用程序会被无情的挂起，等待内核完成操作，因为此时的内核可能将CPU时间切换到了其它需要的进程中，在我们的应用程序看来感觉被卡主(阻塞)了。</p><p>​采用 <strong>BIO 通信模型</strong> 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在<code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010164243.png" alt="img"></p><p><strong>问题：</strong></p><p>我们都知道重复的进行创建销毁线程是很耗费系统资源的，并且其线程的利用率也不是很高。</p><h3 id="非阻塞型I-x2F-O"><a href="#非阻塞型I-x2F-O" class="headerlink" title="非阻塞型I&#x2F;O"></a>非阻塞型I&#x2F;O</h3><p>当使用非阻塞函数的时候，和阻塞IO类比，<strong>内核会立即返回，返回后获得足够的CPU时间继续做其它的事情。</strong></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br><strong>所以，用户进程第一个阶段不是阻塞的,需要不断的主动询问kernel数据好了没有；第二个阶段依然总是阻塞的。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010165830.png" alt="NIO"></p><h3 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h3><p>IO复用(IO multiplexing)，也称事件驱动IO(event-driven IO)，就是在<strong>单个线程里同时监控多个套接字，通过 select 或 poll 轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</strong></p><p>IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。</p><p><strong>I&#x2F;O复用的特点是进行了两次系统调用，进程先是阻塞在 select&#x2F;poll 上，再是阻塞在读操作的第二个阶段上。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010173348.png" alt="img"></p><p><strong>select的缺点</strong></p><ul><li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程</li><li>内核 &#x2F; 用户空间内存拷贝问题，select每次都会改变内核中的句柄数据结构集，因而每次select调用时都需要从用户空间向内核空间复制所有的句柄数据结构，产生巨大的开销</li><li>单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量</li></ul><p><strong>epoll实现</strong></p><blockquote><p>epoll在内核中会维护一个红黑树和一个双向链表，红黑树存放通过epoll_ctl方法向epoll对象中添加进来的事件，所以不需要每次调用epoll_wait都全量复制所有的事件结构。双向链表存放就绪的事件，所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。调用epoll_wait就会直接返回链表中的就绪事件，效率高。</p></blockquote><p><strong>缺点：</strong></p><p>我们现在可以使用select&#x2F;poll等系统调用进行事件的检测，但是select会返回所有建立连接的文件描述符，我们需要一个一个去遍历文件描述符，才能知道哪些数据准备好了，然后才能进行后续的操作，但是如果有10K个连接过来，然后我们调用一次select 或者poll的函数调用，然后去遍历所有的文件描述符，结果只有两个客户端的数据准备好了，那么我们剩下的9998次都是在空转，消耗了很多的系统资源。</p><h3 id="信号驱动I-x2F-O"><a href="#信号驱动I-x2F-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h3><p>信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。<br>如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010175721.png" alt="SIGIO"></p><h3 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><p>异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程<strong>IO操作执行完毕</strong>（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010175808.png" alt="AIO"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201010175831.png" alt="img"></p><p><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=1">马士兵讲BIO、NIO、AIO</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习</title>
    <link href="/2021/01/03/kafka/"/>
    <url>/2021/01/03/kafka/</url>
    
    <content type="html"><![CDATA[<h2 id="什么叫消息队列"><a href="#什么叫消息队列" class="headerlink" title="什么叫消息队列"></a>什么叫消息队列</h2><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p><p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><h2 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h2><ol><li><strong>提高系统响应速度使用了消息队列，生产者一方，把消息往队列里一扔，就可以立马返回，响应用户了。无需等待处理结果</strong><br>处理结果可以让用户稍后自己来取，如医院取化验单。也可以让生产者订阅（如：留下手机号码或让生产者实现listener接口、加入监听队列），有结果了通知。获得约定将结果放在某处，无需通知。</li><li><strong>提高系统稳定性</strong><br>考虑电商系统下订单，发送数据给生产系统的情况。电商系统和生产系统之间的网络有可能掉线，生产系统可能会因维护等原因暂停服务。如果不使用消息队列，电商系统数据发布出去，顾客无法下单，影响业务开展。两个系统间不应该如此紧密耦合。应该通过消息队列解耦。同时让系统更健壮、稳定。</li><li><strong>异步</strong><br>比如我们在注册成功一般网站会给我们的邮箱发送一个邮件，如果是同步的进行邮件的发送，让系统完成邮件发送后才会给我弹出注册成功，如果有许多用户进行注册，对这个系统的压力和堆用户的反馈就不是很好，如果我们使用了消息队列，那么将消息进行发送后，由对应的邮件发送子系统进行发放，那么效率将会提高很多。</li><li><strong>削峰</strong><br>峰值的问题。在分布式系统中，一次分布式事务关联的是多个节点，其中每一个节点出现问题都会成为整个事务处理流程中的瓶颈。如果逻辑节点与数据库之间没有一个起到缓冲作用的节点，那就是每次操作都要访问数据库，对于MMO来说，一个玩家上线load几百K数据，一个服10万个玩家上线已经足够搞垮一个mysql节点了。如果直接搞垮还是比较好的结果，至少是前面的玩家确实登录上去了并且可以正常游戏，后面的玩家登录不上。但是很可惜，十年前开始流行的C10K说法就是在讲：并发量上来之后，会造成chain reaction，大量的并发不会直接挂掉你的mysql节点，但是会拖慢速度，降低吞吐量，一个玩家的请求由于处理时间太长，导致玩家放弃重试，但是对于后端来说，对该玩家之前的处理过程消耗的资源就全部浪费了，陷入恶性循环。</li><li><strong>解耦</strong><br>同异步，将系统成为两部分，降低了项目的耦合，增加了项目的可扩展性。</li></ol><h2 id="什么是kafka"><a href="#什么是kafka" class="headerlink" title="什么是kafka"></a>什么是kafka</h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web&#x2F;nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>主要应用场景是：<code>日志收集系统和消息系统</code></p><p>Kafka主要设计目标如下：</p><ul><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out:支持在线水平扩展</li></ul><p>kafka有两种主要的消息传递模式：<strong>点对点传递模式、发布-订阅模式</strong>。大部分的消息系统选用发布-订阅模式。<strong>Kafka就是一种发布-订阅模式</strong>。</p><h2 id="kafka架构"><a href="#kafka架构" class="headerlink" title="kafka架构"></a>kafka架构</h2><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/kafka-apis.png" alt="img"></p><p>Kafka有四个核心的API:</p><ul><li>The <a href="https://kafka.apachecn.org/documentation.html#producerapi">Producer API</a> 允许一个应用程序发布一串流式的数据到一个或者多个Kafka topic。</li><li>The <a href="https://kafka.apachecn.org/documentation.html#consumerapi">Consumer API</a> 允许一个应用程序订阅一个或多个 topic ，并且对发布给他们的流式数据进行处理。</li><li>The <a href="https://kafka.apachecn.org/documentation/streams">Streams API</a> 允许一个应用程序作为一个<em>流处理器</em>，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li>The <a href="https://kafka.apachecn.org/documentation.html#connect">Connector API</a> 允许构建并运行可重用的生产者或者消费者，将Kafka topics连接到已存在的应用程序或者数据系统。比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><h3 id="Topic和Partition"><a href="#Topic和Partition" class="headerlink" title="Topic和Partition"></a>Topic和Partition</h3><p><strong>Topic</strong>就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。</p><p>对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/log_anatomy.png" alt="kafka-topic"></p><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p><p>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题.</p><p><strong>topic中的数据分割为一个或多个partition每个topic至少有一个partition</strong>，每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/log_consumer.png" alt="img"></p><p>事实上，在每一个消费者中唯一保存的元数据是offset（偏移量）即消费在log中的位置.偏移量由消费者所控制:通常在读取记录后，消费者会以线性的方式增加偏移量，但是实际上，由于这个位置由消费者控制，所以消费者可以采用任何顺序来消费记录。例如，一个消费者可以重置到一个旧的偏移量，从而重新处理过去的数据；也可以跳过最近的记录，从”现在”开始消费。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/consumer-groups.png" alt="img"></p><p>如图，这个 Kafka 集群有两台 server 的，四个分区(p0-p3)和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p><p>通常情况下，每个 topic 都会有一些消费组，一个消费组对应一个”逻辑订阅者”。一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个的进程。</p><p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p><p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p><ul><li>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</li><li>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</li><li>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</li></ul><h2 id="kafka安装使用"><a href="#kafka安装使用" class="headerlink" title="kafka安装使用"></a>kafka安装使用</h2><p>建议使用docker-compose 进行安装，这里笔者也只说一下dockers-compose的安装方法</p><p>docker-compose.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-comment"># 以下192.168.0.103为docker所在宿主机，临时ip</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zoo1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/zookeeper</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;2181:2181&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zookeeper</span><br><br>  <span class="hljs-comment">#kafka version=2.6.0</span><br>  <span class="hljs-attr">kafka1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/kafka</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.70</span><span class="hljs-number">.81</span> <span class="hljs-comment"># 这里为宿主机host name</span><br>      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">&quot;zoo1:2181&quot;</span><br>      <span class="hljs-attr">KAFKA_BROKER_ID:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#broker的全局唯一编号，不能重复</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://192.168.70.81:9092</span><br>      <span class="hljs-attr">KAFKA_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://0.0.0.0:9092</span><br>      <span class="hljs-attr">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka1</span><br>  <span class="hljs-attr">kafka2:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/kafka</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9093:9093&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.70</span><span class="hljs-number">.81</span> <span class="hljs-comment"># 这里为宿主机host name</span><br>      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">&quot;zoo1:2181&quot;</span><br>      <span class="hljs-attr">KAFKA_BROKER_ID:</span> <span class="hljs-number">1</span>  <br>      <span class="hljs-attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://192.168.70.81:9093</span><br>      <span class="hljs-attr">KAFKA_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://0.0.0.0:9093</span><br>      <span class="hljs-attr">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka2</span><br>  <span class="hljs-attr">kafka3:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/kafka</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9094:9094&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.70</span><span class="hljs-number">.81</span> <span class="hljs-comment"># 这里为宿主机host name</span><br>      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">&quot;zoo1:2181&quot;</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://192.168.70.81:9094</span><br>      <span class="hljs-attr">KAFKA_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://0.0.0.0:9094</span><br>      <span class="hljs-attr">KAFKA_BROKER_ID:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka3</span><br></code></pre></td></tr></table></figure><p>然后我们运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br></code></pre></td></tr></table></figure><p>之后我们可以新建一个topic看看是否部署成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it kafka1 bash<br><span class="hljs-comment">#创建topic</span><br>kafka-topics.sh --create --zookeeper zoo1:2181 --replication-factor 3 --partitions 3 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment">#查看注册到集群的topics</span><br>kafka-topics.sh --list --zookeeper zoo1:2181<br><span class="hljs-comment">#查看topic的情况</span><br>kafka-topics.sh --describe --zookeeper zookeeper:2181 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment">#删除</span><br>kafka-topics.sh --delete --zookeeper zookeeper:2181 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>确认部署后我们可以用命令行的方式创建一个生产者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-producer.sh  --topic test --broker-list kafka2:9093<br></code></pre></td></tr></table></figure><p>然后来一个消费者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-consumer.sh --topic test --bootstrap-server kafka2:9093<br></code></pre></td></tr></table></figure><p>这个时候用生产者生产消息，可以看到消费者打印出了消息</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201227135020582.png" alt="kafka-20201227135020582-xx"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201227135028272.png" alt="kafka-20201227135028272--xx2"></p><h2 id="kafka怎么保证数据可靠性"><a href="#kafka怎么保证数据可靠性" class="headerlink" title="kafka怎么保证数据可靠性"></a>kafka怎么保证数据可靠性</h2><p>在kafka中topic只是一个虚拟的概念不是真实存在的，真实存在的是partition分区，这些分区才是实实在在的存储在硬盘上的数据。为了保证数据的可靠性，尽量不丢失数据。kafka使用了以下方法来实现数据的可靠性</p><p>我们都知道当我们要把数据通过生产者发送给kafka的时候会指定一个topic，首先生产者把生产的消息发送给topic，然后再发送到各个topic的分区partition，为了保证数据不丢失，我们就需要各个partition进行ack，如果生产者成功收到了ack，那么证明这次数据发送是成功的，否则的话证明这次数据的发送不成功，进行重发等操作。</p><p>但是这样做会引发问题：</p><h3 id="什么时候发送ack"><a href="#什么时候发送ack" class="headerlink" title="什么时候发送ack"></a>什么时候发送ack</h3><p>我们应该在什么时候发送ACK呢？是应该当分区的leader完成同步后就发送ACK，还是应该等待leader和follower都完成了数据同步才发送ACK呢？如果使用第一种方法的话，那么就会提高我们整个kafka的吞吐量，但是显而易见的，可能会对可靠性产生一点的影响，如果leader同步完之后就发送ACK的话，那么可能这个时候follower还没同步完成，leader挂了，那么就会造成数据的丢失。用第二种的话当然会在效率上有所损失，但是会提高我们数据的可靠性。但同时，第二种方法也会存在一些问题，我们在同步的时候是应该等待全部的follower都同步完在发送ACK还是当半数以上的follower完成同步就可以进行ack了呢。</p><table><thead><tr><th align="center">方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">半数以上就可以进行ACK</td><td align="center">降低延迟</td><td align="center">选举新的leader的时候，容忍n台节点故障，需要2n+1个副本</td></tr><tr><td align="center">全部发送完成才进行ACK</td><td align="center">选举新的leader，容忍容忍n台节点故障，需要n+1个副本</td><td align="center">延迟高</td></tr></tbody></table><p>Kafka 选择了第二种方案，采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么办？</p><p>为了解解决这个问题，kafka使用了ISR技术</p><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。<strong>当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack</strong>。如果 follower 长时间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR ， 该 时 间 阈 值 由replica.lag.time.max.ms 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置。</p><ul><li>0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时<strong>有可能丢失数据</strong>； </li><li>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会<strong>丢失数据</strong>；</li><li>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成<strong>数据重复</strong>。</li></ul><h3 id="HW和HEO（保证一致性）"><a href="#HW和HEO（保证一致性）" class="headerlink" title="HW和HEO（保证一致性）"></a>HW和HEO（保证一致性）</h3><p><strong>HW(High Watermark)高水位</strong></p><p><strong>HEO(Log End Offset)记录结束偏移量</strong></p><p>LEO指的是每个副本最大的offset</p><p>HW指的是消费者能见到的最大的offset，即ISR队列中的最小的LEO。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201227160556053.png" alt="image-20201227160556053"></p><p>利用HW可以保证的是消费者消费信息的一致性，因为如果和上图一样不适用HW的话，那么可能leader可消费19条消息，然后leader挂了图中的第二个队列成为了leader，那么消费者又会发现，可消费的消息变成了12条，发生什么事了。就会导致消费者看起来消息的不一致，这是我们HW用来保证消费者消息一致性的，但是应该注意，使用HW并不能保证数据不丢失，数据丢失不丢失是上面ACK决定的，这里只能确定消费者消费的一致性。</p><p>（1）follower 故障 </p><p>follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。 </p><p>（2）leader 故障 </p><p>leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，<strong>其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据</strong>。 注意：<strong>新当选的leader不会把自己的HW之后的截取</strong></p><h3 id="精准一次性（exactly-once）"><a href="#精准一次性（exactly-once）" class="headerlink" title="精准一次性（exactly once）"></a>精准一次性（exactly once）</h3><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。</p><p>At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。</p><p>幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即： </p><p><strong>At Least Once + 幂等性 &#x3D; Exactly Once</strong></p><p>要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。 但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。</p><h2 id="kafka分区分配策略"><a href="#kafka分区分配策略" class="headerlink" title="kafka分区分配策略"></a>kafka分区分配策略</h2><p>一个 consumer group 中有多个consumer，一个 topic有多个partition，所以必然会涉及 到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。 </p><p>Kafka 有两种分配策略，<strong>RoundRobin(轮询)和Range</strong></p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>range</code> （默认分配策略）对应的实现类是<code>org.apache.kafka.clients.consumer.RangeAssignor</code> 。</p><ul><li>首先，将分区按数字顺序排行序，消费者按名称的字典序排序。</li><li>然后，用分区总数除以消费者总数。如果能够除尽，平均分配；若除不尽，则位于排序前面的消费者将多负责一个分区。</li></ul><ol><li>假设，有1个主题、10个分区、3个消费者线程， 10 &#x2F; 3 &#x3D; 3，而且除不尽，那么消费者C1将会多消费一个分区，分配结果是：<ul><li>C1将消费T1主题的0、1、2、3分区。</li><li>C2将消费T1主题的4、5、6分区。</li><li>C3将消费T1主题的7、8、9分区</li></ul></li><li>假设，有11个分区，分配结果是：<ul><li>C1将消费T1主题的0、1、2、3分区。</li><li>C2将消费T1主题的4、5、 6、7分区。</li><li>C2将消费T1主题的8、9、10分区。</li></ul></li><li>假如，有2个主题（T0和T1），分别有3个分区，分配结果是：<ul><li>C1将消费T1主题的 0、1 分区，以及T1主题的 0、1 分区。</li><li>C2将消费T1主题的 2、3 分区，以及T2主题的 2、3 分区。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2269232-76b62107a30c8e4c.jpg"></p><h3 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h3><p><code>RoundRobin基于轮询算法</code>对应的实现类是 <code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code></p><ul><li>首先，将所有主题的分区组成<code>TopicAndPartition</code>列表。</li><li>然后对TopicAndPartition列表按照hashCode进行排序某个 topic。</li></ul><p>假设，有两个消费者C0和C1，两个主题T0和T1，每个主题有3个分区，分配结果是：</p><ul><li>C0将消费T0主题的0、2分区，以及T1主题的1分区。</li><li>C1将消费T0主题的1分区，以及T1主题的0、2分区。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/2269232-06213b2afcd0fc47.jpg" alt="img"></p><h2 id="如何维护offset"><a href="#如何维护offset" class="headerlink" title="如何维护offset"></a>如何维护offset</h2><p>​为了保证一个Consumer Group中的consumer从一个Topic的多个Partition中消费消息时，保证offset的准确定，offset的存储在Zookeeper内是保存在 Consumer Group下的，格式：ConsumerGroup+Topic+Partition。</p><p>　Kafka 0.9 之前的版本，Consumer默认将offset保存在Zookeeper中，从0.9 版本开始，Consumer默认将offset保存在 Kafka一个内置的 Topic中，该topic为 __consumer_offset。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./bin/kafka-topics.sh --zookeeper 172.16.0.227:2181 --list</span><br>__consumer_offsets<br><span class="hljs-meta prompt_">#</span><span class="language-bash">这个就是offset</span><br></code></pre></td></tr></table></figure><h2 id="消费者生产者API使用"><a href="#消费者生产者API使用" class="headerlink" title="消费者生产者API使用"></a>消费者生产者API使用</h2><h3 id="一般生产者"><a href="#一般生产者" class="headerlink" title="一般生产者"></a>一般生产者</h3><ol><li><p>首先我们在kafka中创建了一个topic名称为<code>first</code>，之后我们JAR包进行导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    //具体版本看自己的安装版本<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>然后我们启动一个控制台的消费者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kafka-console-consumer.sh --bootstrap-server  kafka1:9092 --topic first<br></code></pre></td></tr></table></figure></li><li><p>然后Java写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//kafka集群</span><br>        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;kklll.cn:9092,kklll.cn:9093,kklll.cn:9094&quot;</span>);<br>        <span class="hljs-comment">//ACK级别</span><br>        properties.put(ProducerConfig.ACKS_CONFIG, <span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-comment">//重试次数</span><br>        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//批次大小</span><br>        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="hljs-number">16384</span>);<br>        <span class="hljs-comment">//等待时间</span><br>        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//RecordAccumulator 缓冲区大小</span><br>        properties.put(ProducerConfig.RECEIVE_BUFFER_CONFIG, <span class="hljs-number">33554432</span>);<br>        <span class="hljs-comment">//序列化器</span><br>        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        <span class="hljs-comment">//创建生产者对象</span><br>        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(properties);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//发送消息</span><br>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;消息-------&quot;</span> + i));<br>        &#125;<br>        producer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以看到我们控制台生成了消息</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20210102141115002.png" alt="image-20210102141115002"></p></li></ol><h3 id="带回调的生产者"><a href="#带回调的生产者" class="headerlink" title="带回调的生产者"></a>带回调的生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//kafka集群</span><br>        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;kklll.cn:9092,kklll.cn:9093,kklll.cn:9094&quot;</span>);<br>        <span class="hljs-comment">//ACK级别</span><br>        properties.put(ProducerConfig.ACKS_CONFIG, <span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-comment">//重试次数</span><br>        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//批次大小</span><br>        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="hljs-number">16384</span>);<br>        <span class="hljs-comment">//等待时间</span><br>        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//RecordAccumulator 缓冲区大小</span><br>        properties.put(ProducerConfig.RECEIVE_BUFFER_CONFIG, <span class="hljs-number">33554432</span>);<br>        <span class="hljs-comment">//序列化器</span><br>        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        <span class="hljs-comment">//创建生产者对象</span><br>        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(properties);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;消息-------&quot;</span> + i), (metadata, exception) -&gt; &#123;<br>                <span class="hljs-comment">//有异常的话处理异常,否则处理成功信息的metadata</span><br>                <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) &#123;<br>                    System.out.println(metadata.partition() + <span class="hljs-string">&quot;-------&quot;</span> + metadata.offset());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    exception.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        producer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义分区器"><a href="#自定义分区器" class="headerlink" title="自定义分区器"></a>自定义分区器</h3><p>自定义分区器可以将消息进行分区，这样可以的实现我们自己定义分区的规则。</p><ol><li><p>首先我们需要新建实现<code>partitioner</code>的类，实现接口中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPartitioner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Partitioner</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(String topic, Object key, <span class="hljs-type">byte</span>[] keyBytes, Object value, <span class="hljs-type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; configs)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>其次我们需要在新建连接的时候把分区器的累写入到properties中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomPartitionProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//kafka集群</span><br>        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;kklll.cn:9092,kklll.cn:9093,kklll.cn:9094&quot;</span>);<br>        <span class="hljs-comment">//ACK级别</span><br>        properties.put(ProducerConfig.ACKS_CONFIG, <span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-comment">//重试次数</span><br>        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//批次大小</span><br>        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="hljs-number">16384</span>);<br>        <span class="hljs-comment">//等待时间</span><br>        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//RecordAccumulator 缓冲区大小</span><br>        properties.put(ProducerConfig.RECEIVE_BUFFER_CONFIG, <span class="hljs-number">33554432</span>);<br>        <span class="hljs-comment">//序列化器</span><br>        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        <span class="hljs-comment">//创建生产者对象</span><br><br>        <span class="hljs-comment">//设置分区器</span><br>        properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, <span class="hljs-string">&quot;com.kklll.zookeeperlearn.kafka.partition.MyPartitioner&quot;</span>);<br><br>        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(properties);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;测试信息&quot;</span>, <span class="hljs-string">&quot;消息-------&quot;</span> + i), (metadata, exception) -&gt; &#123;<br>                <span class="hljs-comment">//有异常的话处理异常,否则处理成功信息的metadata</span><br>                <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span>) &#123;<br>                    System.out.println(metadata.partition() + <span class="hljs-string">&quot;-------&quot;</span> + metadata.offset());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    exception.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        producer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConsumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//kafka集群</span><br>        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;kklll.cn:9092,kklll.cn:9093,kklll.cn:9094&quot;</span>);<br>        <span class="hljs-comment">//自动提交</span><br>        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//提交的超时事时间，这个配置即1秒提交一次</span><br>        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="hljs-string">&quot;1000&quot;</span>);<br>        <span class="hljs-comment">//反序列化类</span><br>        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        <span class="hljs-comment">//消费者组</span><br>        properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="hljs-string">&quot;test_group&quot;</span>);<br><br>        <span class="hljs-comment">//是否重置offset 可选&quot;latest&quot;, &quot;earliest&quot;, &quot;none&quot;，前提是要更换消费者组(组名不存在)</span><br>        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,<span class="hljs-string">&quot;earliest&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者对象</span><br>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);<br>        <span class="hljs-comment">//消费者订阅主题</span><br>        consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>));<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//获取数据</span><br>            ConsumerRecords&lt;String, String&gt; poll = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : poll) &#123;<br>                System.out.println(consumerRecord.key());<br>                System.out.println(consumerRecord.value());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者进行手动offset提交"><a href="#消费者进行手动offset提交" class="headerlink" title="消费者进行手动offset提交"></a>消费者进行手动offset提交</h3><h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步提交</span><br>consumer.commitSync();<br></code></pre></td></tr></table></figure><h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步提交</span><br>consumer.commitAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OffsetCommitCallback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span>&#123;<br>        <span class="hljs-comment">//回调函数写具体逻辑</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="自定义存储offset"><a href="#自定义存储offset" class="headerlink" title="自定义存储offset"></a>自定义存储offset</h2><p>Kafka0.9版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。</p><p>offset 的维护是相当繁琐的，因为需要考虑到消费者的Rebalace。 当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做Rebalance。</p><p>消费者发生Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费。</p><p>要实现自定义存储 offset，需要借助<code>ConsumerRebalanceListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerRebalanceListener</span>() &#123;<br>            <span class="hljs-comment">//rebalanced之前调用</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPartitionsRevoked</span><span class="hljs-params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;<br><span class="hljs-comment">//提交该消费者所有分区的 offset</span><br>            &#125;<br><br>            <span class="hljs-comment">//rebalanced之后调用</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPartitionsAssigned</span><span class="hljs-params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;<br>                <span class="hljs-comment">// 定位到最近提交的offset 位置继续消费</span><br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>首先我们要定义自定义的拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。</span><br><span class="hljs-comment">     * 用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的 topic 和分区，否则会影响目标分区的计算。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(record.topic(), record.partition(), record.key(), System.currentTimeMillis() + record.value());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该方法会在消息从RecordAccumulator 成功发送到Kafka Broker 之后，或者在发送过程 中失败时调用。</span><br><span class="hljs-comment">     * 并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在 producer 的 IO 线程中，</span><br><span class="hljs-comment">     * 因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息发送效率</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAcknowledgement</span><span class="hljs-params">(RecordMetadata metadata, Exception exception)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> DeepBlue</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span>: 2021/1/3 13:54</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>: 关闭拦截器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> DeepBlue</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span>: 2021/1/3 13:54</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@description</span>:进行配置文件的配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; configs)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">successCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">errorCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord record)</span> &#123;<br>        <span class="hljs-keyword">return</span> record;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAcknowledgement</span><span class="hljs-params">(RecordMetadata metadata, Exception exception)</span> &#123;<br>        <span class="hljs-keyword">if</span> (metadata != <span class="hljs-literal">null</span>) &#123;<br>            successCount++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>            errorCount++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        log.warn(<span class="hljs-string">&quot;Success:&#123;&#125;&quot;</span>, successCount);<br>        log.warn(<span class="hljs-string">&quot;Error:&#123;&#125;&quot;</span>, errorCount);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; configs)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们写一个带拦截器的生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//kafka集群</span><br>        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;kklll.cn:9092,kklll.cn:9093,kklll.cn:9094&quot;</span>);<br>        <span class="hljs-comment">//ACK级别</span><br>        properties.put(ProducerConfig.ACKS_CONFIG, <span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-comment">//重试次数</span><br>        properties.put(ProducerConfig.RETRIES_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//批次大小</span><br>        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="hljs-number">16384</span>);<br>        <span class="hljs-comment">//等待时间</span><br>        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//RecordAccumulator 缓冲区大小</span><br>        properties.put(ProducerConfig.RECEIVE_BUFFER_CONFIG, <span class="hljs-number">33554432</span>);<br>        <span class="hljs-comment">//序列化器</span><br>        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<br>                <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br><br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;com.kklll.zookeeperlearn.kafka.interceptor.MyInterceptor&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;com.kklll.zookeeperlearn.kafka.interceptor.CounterInterceptor&quot;</span>);<br>        properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, list);<br>        <span class="hljs-comment">//创建生产者对象</span><br>        KafkaProducer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;String, String&gt;(properties);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;消息-------&quot;</span> + i));<br>        &#125;<br>        producer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就好了</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关</title>
    <link href="/2020/11/01/JVM/"/>
    <url>/2020/11/01/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java内存区域：</p><ul><li>本地方法栈(native)</li><li>虚拟机栈</li><li>程序计数器</li><li>方法区（包括运行时常量池）</li><li>堆</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/95SQkNJiHuToDwE.png" alt="JVM各版本"></p><p>JDK1.8与JDK1.7最大的区别是：<strong>JDK1.8将永久代取消，取而代之的是元空间，在JDK1.8中方法区是由元空间来实现</strong>，所以原来属于方法区的运行时常量池就属于元空间了。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的，它内部包括局部变量表，操作数栈、动态链接、出口信息等，他和虚拟机栈的区别是，虚拟机栈是执行JAVA方法的，当时本地方法栈是执行本地方法的，通常不是Java语言编写的方法。 <code>在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一</code></p><p>会出现<strong>StackOverFlowError</strong>和<strong>OutOfMemoryError</strong>： Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也是线程私有的，它内部包括方法的栈帧，每个栈帧由局部变量表，操作数栈、动态链接、出口信息等构成，当执行方法的时候将栈帧压入，等待方法执行完成后将栈帧进行弹出。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器也是线程私有的，，我的理解是，就是指示当前程序执行到了哪里，其具体的作用是：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p><strong>方法区存着类的信息，常量和静态变量，即类被编译后的数据。这个说法其实是没问题的，只是太笼统了。更加详细一点的说法是方法区里存放着类的版本，字段，方法，接口和常量池。常量池里存储着字面量和符号引用。</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。<code>Class 文件中除了有类的版本、字段、方法、接口等描述信息外</code>，还有<code>常量池信息</code><strong>（用于存放编译期生成的各种字面量和符号引用）</strong></p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><p><img src="https://camo.githubusercontent.com/17620721a9f326a235aeec8956949cec03f3f125/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是Java里面最大的一块，堆是由所有线程共享的区域，他里面主要存储的类生成的对象的实例信息<strong>几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20201004203612.jpg"></p><p><strong>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</strong></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记-清除</li><li>标记-整理</li><li>复制算法</li><li>分代算法</li></ul><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p>类加载的阶段 加载&#x3D;》验证&#x3D;》准备&#x3D;》解析&#x3D;》初始化&#x3D;》使用&#x3D;》卸载</p><p><strong>加载：</strong>加载类的全限定类名所指的class文件&#x3D;》生成java.lang.Class的类到内存中</p><p><strong>验证</strong>：主要是对（class文件或者其他的二进制流）进行验证，验证的即是比如cafebabe，版本号是否支持，元数据验证（是否有父类，是否继承自其他类等）、语法语义验证（比如在static 方法中使用了非static值）</p><p><strong>准备</strong>：内存的分配，其中类变量会进入方法区，常量进入静态常量池并进行类变量的初始化</p><p><strong>解析</strong>：虚拟机将常量池内的符号引用替换为直接引用的过程</p><p><strong>什么是字面量和符号引用？直接引用？</strong></p><p><strong>初始化</strong>：主要包括<code>&lt;cinit&gt;</code>和其中类初始化会初始化静态代码块和静态初始化语句。</p><h4 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h4><ol><li>加载Class文件（如果没加载，加载了的话就直接跳到第二步）</li><li><strong>分配内存</strong>在堆内存中分配内存</li><li>初始化，执行&lt;init&gt;指令进行初始化</li><li>将对象的地址传递给引用。</li></ol><h4 id="双亲委派策略"><a href="#双亲委派策略" class="headerlink" title="双亲委派策略"></a>双亲委派策略</h4><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/16be8e7a9b686137" alt="pic"></p><p><strong>双亲委派为什么要出现？</strong></p><p>因为它使得类有了层次的划分。就拿<code>java.lang.Object</code>来说，你加载它经过一层层委托最终是由<code>Bootstrap ClassLoader</code>来加载的，也就是最终都是由<code>Bootstrap ClassLoader</code>去找<code>&lt;JAVA_HOME&gt;\lib</code>中rt.jar里面的<code>java.lang.Object</code>加载到JVM中。</p><p><strong>怎么破坏？</strong></p><p>JAVA开发者开发了ThreadContextClassLoader(线程上下文类加载器)，这个类加载器可以通过java.lang.Thread类中的setContextClassLoader()方法进行设置，如果创建线程的时候没有设置，那么就是默认的应用程序类加载器。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><strong>在介绍synchronized关键词之前首先要介绍一下对象头</strong></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>Java对象保存在内存中时，由以下三部分组成：</p><ol><li><strong>对象头</strong></li><li><strong>实例数据</strong></li><li><strong>填充数据</strong></li></ol><p>2和3我们都很好理解，其中2代表的实例对象的一些值，3是因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数。</p><p>那么对象头是啥呢？</p><p><strong>对象头由如下组成：</strong></p><ol><li><strong>Mark Word</strong></li><li><strong>指向类的指针</strong></li><li><strong>数组长度（只有数组对象才有）</strong></li></ol><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p><p><strong>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</strong></p><p>Mark Word在不同的锁状态下存储的内容不同，在64位JVM中是这么存的：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201107164941313.png" alt="image-20201107164941313"></p><p>指向类的指针，这个就不用说了，因为有时候需要用到类的信息，那么通过这个对象指向类的指针就能够访问到类的属性。</p><p>需要注意的是数组对象还会额外的多出一个数组长度的字段，用来存储数组对象的长度。</p><h3 id="synchronized关键词"><a href="#synchronized关键词" class="headerlink" title="synchronized关键词"></a>synchronized关键词</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>1、偏向锁获取过程：</strong></p><p>　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p><p>　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</p><p>　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</p><p>　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p><p>　　（5）执行同步代码。</p><p><strong>2、偏向锁的释放：</strong></p><p>　　偏向锁的撤销在上述第四步骤中有提到<strong>。</strong>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p><strong>转换关系</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/820406-20160424163618101-624122079.png" alt="img"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>1、<strong>轻量级锁的加锁过程</strong></p><p>　　（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p><p>　　（2）拷贝对象头中的Mark Word复制到锁记录中。</p><p>　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。</p><p>　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。</p><p>　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201024215715251.png" alt="锁膨胀的过程"></p><p><strong>2、轻量级锁的解锁过程：</strong></p><p>　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p><p>　　（2）如果替换成功，整个同步过程就完成了。</p><p>　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，将监视器中的owner指向null，之后唤醒被挂起的线程。</p><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。</p><p>重量级锁的状态下，对象的<code>mark word</code>为指向一个堆中monitor对象的指针。</p><p>一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。</p><p>其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/16759dd1b0ad4fbe" alt="1517900250327"></p><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到ContentionList的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将ContentionList中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td align="center">适用于只有一个线程访问同步块场景。</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了程序的响应速度。</td><td align="center">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td align="center">追求响应时间。同步块执行速度非常快。</td></tr><tr><td align="center">重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗CPU。</td><td align="center">线程阻塞，响应时间缓慢。</td><td align="center">追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><p>自己实现一个ThreadPool(简单的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kklll.leetcode.face.meituan;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> DeepBlue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/10/27 10:59</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j(topic = &quot;test&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThreadPool</span> <span class="hljs-variable">myThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadPool</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            myThreadPool.exec(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPool</span> &#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br>    <span class="hljs-comment">//获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">//当任务没有超过coreSize那么worker执行</span><br>        <span class="hljs-comment">//否则放入BlockingQueue</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增worker&#123;&#125;，&#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                taskQueue.put(task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//当task没任务，那么执行任务</span><br>            <span class="hljs-comment">//当没任务的时候去找阻塞队列的任务执行</span><br><span class="hljs-comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//锁</span><br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">//生产者条件，消费者条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWait</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWait</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//带timeout的阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//转换成ns</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//返回剩余时间</span><br>                    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    l = emptyWait.awaitNanos(l);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeLast();<br>            fullWait.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWait.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeLast();<br>            fullWait.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T t)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fullWait.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addFirst(t);<br>            emptyWait.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加拒绝策略后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kklll.leetcode.face.meituan;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> DeepBlue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/10/27 10:59</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j(topic = &quot;test&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyThreadPool</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThreadPool</span> <span class="hljs-variable">myThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadPool</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">1</span>,<br>                (queue, task) -&gt; &#123;<br><span class="hljs-comment">//            1.等待超时</span><br><span class="hljs-comment">//            queue.offer(task,500,TimeUnit.MILLISECONDS);</span><br><span class="hljs-comment">//            2.直接放弃</span><br><span class="hljs-comment">//            log.debug(&quot;放弃任务&#123;&#125;&quot;,task);</span><br><span class="hljs-comment">//            3.抛出异常</span><br><span class="hljs-comment">//            throw new RuntimeException(&quot;任务失败了&quot;);</span><br><span class="hljs-comment">//            4.自己去执行吧</span><br><span class="hljs-comment">//            task.run();</span><br>                &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            myThreadPool.exec(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; blockingQueue, T t)</span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPool</span> &#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br>    <span class="hljs-comment">//获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-comment">//拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapacity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">//当任务没有超过coreSize那么worker执行</span><br>        <span class="hljs-comment">//否则放入BlockingQueue</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增worker&#123;&#125;，&#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                1.死等</span><br><span class="hljs-comment">                2.超时等待</span><br><span class="hljs-comment">                3.放弃任务执行</span><br><span class="hljs-comment">                4.抛出异常</span><br><span class="hljs-comment">                5.让调用者自己执行</span><br><span class="hljs-comment">                 */</span><br><span class="hljs-comment">//                taskQueue.put(task);</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//当task没任务，那么执行任务</span><br>            <span class="hljs-comment">//当没任务的时候去找阻塞队列的任务执行</span><br><span class="hljs-comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//锁</span><br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">//生产者条件，消费者条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWait</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWait</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//带timeout的阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//转换成ns</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//返回剩余时间</span><br>                    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    l = emptyWait.awaitNanos(l);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeLast();<br>            fullWait.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果队列满了</span><br>            <span class="hljs-keyword">if</span> (queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                queue.addFirst(task);<br>                emptyWait.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWait.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeLast();<br>            fullWait.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T t)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;任务队列满了等待------------&quot;</span>);<br>                    fullWait.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, t);<br>            queue.addFirst(t);<br>            emptyWait.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时添加的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T t, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;任务队列满了等待------------&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (l &lt;= <span class="hljs-number">0</span>) &#123;<br>                        log.debug(<span class="hljs-string">&quot;进行拒绝&#123;&#125;&quot;</span>, t);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    l = fullWait.awaitNanos(l);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, t);<br>            queue.addFirst(t);<br>            emptyWait.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阻塞队列的种类"><a href="#阻塞队列的种类" class="headerlink" title="阻塞队列的种类"></a>阻塞队列的种类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h5><p>ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><p>DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</p><p><strong>PriorityBlockingQueue</strong></p><p>PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p><h4 id="线程池的四种拒绝策略"><a href="#线程池的四种拒绝策略" class="headerlink" title="线程池的四种拒绝策略"></a>线程池的四种拒绝策略</h4><p>1、直接丢弃（DiscardPolicy）</p><p>2、丢弃队列中最老的任务(DiscardOldestPolicy)。</p><p>3、抛异常(AbortPolicy)</p><p>4、将任务分给调用线程来执行(CallerRunsPolicy)</p><h4 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h4><p><strong>1.newFixedThreadPool</strong>，固定大小的线程池，没有应急线程吗，全部为核心线程，拒绝策略为AbortPolicy，阻塞队列为LinkedBlockingQueue，且没有指定阻塞队列的最大值，所以为2^31-1，阻塞队列可能会OOM。</p><p><strong>2.newCachedThreadPool</strong>，缓存线程池，没有核心线程，全部为应急线程，拒绝策略是AbortPolicy。60S内没有新的任务，应急线程会被放掉，阻塞队列为SynchronousQueue，这个阻塞队列它的内部同时只能够容纳单个元素，已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走<strong>一手交钱，一手交货</strong></p><p><strong>3.newSingleThreadExecutor</strong>,单例线程池，只有一个核心线程，没有应急线程，阻塞队列为LinkedBlockingQueue，没有指定大小，界限为Integer.MAX_VALUE，拒绝策略为AbortPolicy。</p><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p><strong><code>AbstractQueuedSynchronizer</code>抽象队列同步器</strong>，简称为<code>AQS</code>，可用于构建<strong>阻塞锁</strong>或者其他相关<strong>同步器</strong>的基础框，是Java并发包的基础工具类。通过<code>AQS</code>这个框架可以对<strong>同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理</strong>进行统一管理。<br><code>AQS</code>是抽象类，并不能直接实例化，当需要使用<code>AQS</code>的时候需要继承<code>AQS</code>抽象类并且重写指定的方法，这些重写方法包括<strong>线程获取资源和释放资源的方式</strong>(如ReentractLock通过分别重写线程获取和释放资源的方式实现了公平锁和非公平锁)，<strong>同时子类还需要负责共享变量state的维护，如当state为0时表示该锁没有被占，大于0时候代表该锁被一个或多个线程占领(重入锁)<strong>，而队列的维护(获取资源失败入队、线程唤醒、线程的状态等)不需要我们考虑，<code>AQS</code>已经帮我们实现好了。<code>AQS</code>的这种设计模式采用的正是</strong>模板方法模式</strong>。<br><strong>总结起来子类的任务有：</strong></p><ol><li>通过<code>CAS</code>操作维护共享变量<code>state</code>。</li><li>重写资源的获取方式。</li><li>重写资源释放的方式。</li></ol><p><strong>AQS的数据结构：</strong></p><ol><li><p>state状态，表示当前同步器是否有线程占用。</p></li><li><p>Node，即队列中的元素。（有如下属性：）</p><table><thead><tr><th>方法和属性值</th><th>含义</th></tr></thead><tbody><tr><td>waitStatus</td><td>当前节点在队列中的状态</td></tr><tr><td>thread</td><td>表示处于该节点的线程</td></tr><tr><td>prev</td><td>前驱指针</td></tr><tr><td>predecessor</td><td>返回前驱节点，没有的话抛出npe</td></tr><tr><td>nextWaiter</td><td>指向下一个处于CONDITION状态的节点</td></tr><tr><td>next</td><td>后继指针</td></tr></tbody></table><p>其中waitState的取值及含义：</p><table><thead><tr><th align="left">取值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">当一个Node被初始化的时候的默认值</td></tr><tr><td align="left">CANCELLED</td><td align="left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td align="left">CONDITION</td><td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align="left">PROPAGATE</td><td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align="left">SIGNAL</td><td align="left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table></li><li><p>条件队列（单向链表）等待某个特定条件发生的队列。</p></li><li><p>同步队列（双向链表）等待当前资源释放后运行的线程组成的队列。</p></li></ol><p><code>AQS</code>内部数据结构为一个<strong>双向链表</strong>和一个<strong>单向链表</strong>，双链表为同步队列，队列中的每个节点对应一个<code>Node</code>内部类，<code>AQS</code>通过控制链表的节点而达到阻塞、同步的目的，单链表为条件队列，<strong>可以把同步队列和条件队列理解成储存等待状态的线程的队列</strong>，但是条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，同步队列的唤醒结果是线程去尝试获取锁，而条件队列的唤醒结果是把线程从条件队列移到同步队列中，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201029112731331.png"></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/image-20201029113032248.png" alt="image-20201029113032248"></p><p><strong>ReentrantLock的lock方法流程</strong></p><p><strong>公平锁：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/b8b53a70984668bc68653efe9531573e78636.png" alt="img"></p><ol><li>首先CAS更改同步状态state变量，如果成功，那么将当前同步器的独占线程拥有者换成自己，否则执行同步器的acquire方法。</li><li>进入同步器的acquire方法后会尝试进行加锁（tryacquire方法），如果加锁成功，将当前同步器的独占线程拥有者换成自己。否则进行下一步。</li><li>调用nofiretryacquire方法，此时还会进行CAS尝试获取锁，如果获取成功的话，也是将当前线程设置成独占线程的持有者，否则进行下一步。</li><li>将当前线程包装成一个Node，然后使用CAS将其加入到同步队列中（其实创建了两个节点，第一个节点叫dummy节点，无实际作用，这其中还要把dummy节点的state置成-1，表示其有义务唤醒后继节点的义务）。</li></ol><p><strong>非公平锁：</strong></p><p>可以看出公平锁和非公平锁之间的区别在于：<strong>公平锁不会直接进去就使用CAS改变同步器的state状态</strong>而是调用公平锁的tryAcquire方法，且方法内会判断当前的同步队列中是不是有正在等待资源的线程，如果有的话将当前线程添加到同步队列的末尾。</p><p><strong>ReentrantLock的unlock方法流程</strong></p><ol><li>unlock方法调用同步器的release方法，可以看出其中的大概逻辑，首先先获取同步器的state，将其减去1（一般情况下，让然你也可以自己实现），然后判断state是不是等于0，如果等于零的话，证明该锁要被释放掉。否则，返回一个false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁的特性：</p><ol><li><strong>读读可以并发执行，读写不能并发。</strong></li><li><strong>读锁不支持条件变量</strong></li><li><strong>重入不能升级（即同一线程先获得读锁，后获得写锁是不支持的）</strong></li><li><strong>重入时可以降级（即同一线程先获取写锁，再获取读锁是支持的）</strong></li></ol><p><strong>读写锁的底层实现：</strong></p><p><strong>读写锁使用的是一个同步器而不是两个</strong>，其中同步器内部的state标志位有所不同，其中的state分为第十六位和高十六位，其中读锁在高十六位，写锁占用的是低十六位。（0表示为加读锁，1表示加了锁，大于1为重入状态的计数），这种设计能够大大提高效率，因为只去访问一次内存就能拿到读写锁的所有mark word，并且使用CAS的时候只用一次就行了。</p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/16e3e72e34ef7d2f" alt="读写锁" style="zoom:80%;" /><h4 id="写锁的lock方法"><a href="#写锁的lock方法" class="headerlink" title="写锁的lock方法"></a>写锁的lock方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先调用了同步器的acquire方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//acquire中的逻辑和reentrantLock基本相同。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Walkthrough:</span><br><span class="hljs-comment">             * 1. If read count nonzero or write count nonzero</span><br><span class="hljs-comment">             *    and owner is a different thread, fail.</span><br><span class="hljs-comment">             * 2. If count would saturate, fail. (This can only</span><br><span class="hljs-comment">             *    happen if count is already nonzero.)</span><br><span class="hljs-comment">             * 3. Otherwise, this thread is eligible for lock if</span><br><span class="hljs-comment">             *    it is either a reentrant acquire or</span><br><span class="hljs-comment">             *    queue policy allows it. If so, update state</span><br><span class="hljs-comment">             *    and set owner.</span><br><span class="hljs-comment">             */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取state值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//查看写锁部分的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>        <span class="hljs-comment">//判断写锁是不是等于0，如果等于0说明读锁不为零，那么需要阻塞。或者是当前线程不是当前AQS的持有者</span><br>        <span class="hljs-comment">//那么也需要阻塞</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果上面不满足，判断是不是重入，如果是冲入而且超过最大冲入次数，那么报错</span><br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">// Reentrant acquire</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (writerShouldBlock() ||<br>        !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在tryAcquire()方法中，先通过<code>exclusiveCount()</code>方法来计算写锁的数量，怎么计算的呢？就是将state和<code>0x0000FFFF</code>进行<code>与运算</code>。</p></li><li><p>然后判断state是否等于0，如果等于0，就表示读锁和写锁都没有被获取，当前线程就调用<code>writerShouldBlock()</code>方法判断线程是否需要等待，如果需要等待，tryAcquire()方法就返回false，表示获取锁失败，那么就会回到AQS的acquire()方法中，后面的逻辑与排他锁的逻辑一样。如果不需要等待，就尝试去修改state的值，如果修改成功，就表示获取锁成功，否则失败。</p></li><li><p>如果state不等于0，那么就表示存在读锁或者写锁，那么究竟是读锁还是写锁呢？就需要根据w的值进行判断了。</p></li><li><p>如果w为0，说明写锁的数量为0，而此时又因为c不等于0，说明锁被占用，但是不是写锁，那么此时锁的状态一定是读锁，既然是读锁状态，那么写锁此时来获取锁时，就肯定失败，因为读锁存在时，是不能去获取写锁的。因此当w等于0时，tryAcquire()方法返回false。</p></li><li><p>如果w不为0，说明此时锁的状态是写锁，接着进行<code>current != getExclusiveOwnerThread()</code>判断，判断持有锁的线程是否是当前线程。如果不是当前线程，那么tryAcquire()返回false；如果是当前线程，那么就进行后面的逻辑。为什么是当前线程持有锁，就能执行后面的逻辑呢？ 因为读写锁是支持重入的。</p></li><li><p>如果是当前线程获取的写锁，接着就判断，再次对写锁进行重入时，会不会超出写锁的最大重入次数，如果是，就抛出异常。（因为state的低16位表示写锁，所以写锁最大可被重入的次数是<img src="https://juejin.im/equation?tex=2%5E%7B16%7D" alt="2^{16}">-1）。</p></li></ul><h4 id="读锁的lock方法"><a href="#读锁的lock方法" class="headerlink" title="读锁的lock方法"></a>读锁的lock方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//调用同步器的acquireShared方法</span><br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Walkthrough:</span><br><span class="hljs-comment">             * 1. If write lock held by another thread, fail.</span><br><span class="hljs-comment">             * 2. Otherwise, this thread is eligible for</span><br><span class="hljs-comment">             *    lock wrt state, so ask if it should block</span><br><span class="hljs-comment">             *    because of queue policy. If not, try</span><br><span class="hljs-comment">             *    to grant by CASing state and updating count.</span><br><span class="hljs-comment">             *    Note that step does not check for reentrant</span><br><span class="hljs-comment">             *    acquires, which is postponed to full version</span><br><span class="hljs-comment">             *    to avoid having to check hold count in</span><br><span class="hljs-comment">             *    the more typical non-reentrant case.</span><br><span class="hljs-comment">             * 3. If step 2 fails either because thread</span><br><span class="hljs-comment">             *    apparently not eligible or CAS fails or count</span><br><span class="hljs-comment">             *    saturated, chain to version with full retry loop.</span><br><span class="hljs-comment">             */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">//如果有人加了写锁，且当前线程不是加写锁的线程，返回-1</span><br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//获取锁的数值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>        <span class="hljs-comment">// 读锁数量为0时，就将当前线程设置为firstReader，firstReaderHoldCount=1</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 读锁数量不为0且firstReader(第一次获取读的线程)为当前线程，就将firstReaderHoldCount累加</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读锁数量不为0，且第一个获取到读锁的线程不是当前线程</span><br>            <span class="hljs-comment">// 下面这一段逻辑就是保存当前线程获取读锁的次数，如何保存的呢？</span><br>            <span class="hljs-comment">// 通过ThreadLocal来实现的，readHolds就是一个ThreadLocal的实例</span><br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquireShared方法，返回值是int类型的，<strong>如果返回-1，表示获取读锁失败，返回0表示加锁成功，且不需要唤醒后续节点，如果返回正数表明，需要唤醒几个后继节点，在读写锁中只会出现前两种情况</strong></p><ul><li><p>在tryAcquireShared()方法中，会先通过<code>exclusiveCount()</code>方法来计算写锁的数量，如果写锁存在，再判断持有写锁的线程是不是当前线程，如果不是当前线程，就表示写锁被其他线程给占用，此时当前线程不能获取读锁。tryAcquireShared()方法返回-1，表示获取读锁失败。如果写锁不存在或者持有写锁的线程是当前线程，那么就表示当前线程有机会获取到读锁。</p></li><li><p>接下里会判断当前线程获取读锁是否不需要排队，读锁数量是否会超过最大值，以及通过CAS修改读锁的状态是否成功（将state的值加 1&lt;&lt;16）。如果这三个条件成立，就进入if语句块中，这一块的代码比较繁琐，但是功能比较单一，就是统计读锁的数量以及当前线程对读锁的重入次数，底层原理就是<code>ThreadLocal</code>。因为在读写锁中提供了<code>getReadLockCount()、getReadHoldCount()</code>等方法，这几个方法的数据就来自这儿。</p></li></ul><h4 id="写锁的unlock方法"><a href="#写锁的unlock方法" class="headerlink" title="写锁的unlock方法"></a>写锁的unlock方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">//写锁减一</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">//如果减成0了，那么证明可以释放锁了</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (free)<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    setState(nextc);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>写锁的释放与排他锁的释放逻辑也几乎一样。当调用writeLock.unlock()时，先调用到AQS的release()方法，在release()方法中会先调用子类的tryRelease()方法。在这里调用的是ReentrantReadWriteLock的内部类Sync的tryRelease()方法。</p><h4 id="读锁的unlock方法"><a href="#读锁的unlock方法" class="headerlink" title="读锁的unlock方法"></a>读锁的unlock方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>        <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span><br>        <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>            firstReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span><br>            firstReaderHoldCount--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>        <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>            rh = readHolds.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>            readHolds.remove();<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>        &#125;<br>        --rh.count;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// 将修改同步变量的值（读锁状态减去1&lt;&lt;16）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span><br>            <span class="hljs-comment">// but it may allow waiting writers to proceed if</span><br>            <span class="hljs-comment">// both read and write locks are now free.</span><br>            <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在tryReleaseShared()方法中，会先修改和读锁计数有关的数据，然后在for的死循环中，通过CAS操作将state的值减去1&lt;&lt;16。如果CAS操作成功，才会从for循环中退出。当读锁数量为0时，tryReleaseShared()返回true，表示锁被完全释放。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2020/10/01/JMM/"/>
    <url>/2020/10/01/JMM/</url>
    
    <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p>JMM全称是（Java Memory Model）即Java内存模型，那他是用来干什么的呢？其实他就越是一种规范，规定了你应该怎么去存取内存中的数据、类变量等资源。</p><p>**规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。　**</p><blockquote><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201021102246.png" alt="image-20201021102244772"></p><p><strong>Java内存模型规定了所有的变量都存在主内存中，每个线程可以拥有自己独立的工作内存，工作内存中保存着该线程使用的变量的副本，线程对变量的操作在在自己的工作内存中进行，线程不能直接操作主内存中的变量。</strong></p><ul><li>主内存：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</li><li>工作内存：主要存储当前方法的所有<code>本地变量信息</code>(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</li></ul><p>根据虚拟机规范，对于一个实例对象中的成员方法而言，<strong>如果方法中包含本地变量的基本数据类型(boolean,byte,short,char,int,long,float,double)，那么这些本地变量将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在方法内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。</strong>需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201021103058.png" alt="image-20201021103056810"></p><p>同时JMM也规定了工作内存和主内存之间进行交互操作时的具体的协议，即一个共享变量如何从主内存拷贝到工作内存，如何从工作内存刷新到主内存。其中规定了八个原子操作。</p><h4 id="Java内存交互协议"><a href="#Java内存交互协议" class="headerlink" title="Java内存交互协议"></a>Java内存交互协议</h4><p>Java定义了8种操作来完成主内存和工作内存之间的变量访问：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li><strong>不允许read和load、store和write操作之一单独出现，也就是read操作后必须load，store操作后必须write</strong></li><li><strong>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</strong></li><li><strong>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</strong></li><li><strong>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</strong></li><li><strong>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</strong></li><li><strong>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</strong></li><li><strong>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</strong></li><li><strong>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</strong></li></ul><h3 id="为什么一定要有这个JMM呢？"><a href="#为什么一定要有这个JMM呢？" class="headerlink" title="为什么一定要有这个JMM呢？"></a>为什么一定要有这个JMM呢？</h3><p>简单来说的话，因为共享变量在主存中存放，每个线程持有的变量又是主存中的变量的拷贝，如果没有JMM这个规范来进行一些规定，那么各个线程之间的数据访问就会出现一些问题，比如现在主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x&#x3D;1进行操作，A&#x2F;B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？<strong>答案是，不确定</strong>，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x&#x3D;1拷贝到自己的工作内存中，这样B线程读取到的值就是x&#x3D;1，但如果A线程已将x&#x3D;2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x&#x3D;2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。</p><p>我们都知道计算机科学是很严谨的学科，是多少就是多少，那么这种不确定一定不能出现，那么，我们就搞一个JMM模型来消灭掉这个不确定性吧（这也是为什么JMM一定要出现的原因）</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/pics/20201021105307.png" alt="image-20201021105303180"></p><h3 id="怎么去消灭这个不确定性呢？"><a href="#怎么去消灭这个不确定性呢？" class="headerlink" title="怎么去消灭这个不确定性呢？"></a>怎么去消灭这个不确定性呢？</h3><p>为了消除这个不确定性，Java内存模型给我们定义了三个特性：<code>原子性</code> <code>可见性</code> <code>有序性</code></p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><strong>就是说一个操作不能被打断，要么执行完要么不执行，</strong>类似事务操作。</p><p>Java 基本类型数据的访问大都是原子操作，<strong>long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，</strong>也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 synchronized 等。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p><p><strong>JMM中怎么保证原子性？</strong></p><ol><li>使用JMM规定的上面的八个原子操作中的read、load、assign、use、write、store等变量来保证。</li><li>使用lock和unlock指令(synchronized关键词是这两个指令的高级实现)，也就是使用synchronized关键词来保证原子性。</li></ol><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象（<strong>指令的重排序</strong>：为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做<strong>指令的重排序</strong>），重排后的指令与原指令的顺序未必一致，要明白的是，<strong>在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的</strong>，前半句指的是单线程内保证串行语义执行的一致性，<strong>后半句则指指令重排现象和工作内存与主内存同步延迟现象。</strong></p><p><strong>JMM如何保证有序性？</strong></p><p>Java中提供了synchronized关键词和volatile关键词来保证线程之间的操作具有有序性，volatile本身就包含了禁止指令重排的指令，而synchronized关键词则是“一个变量在同一时刻只能由一个线程对其进行lock操作来得到”，从而保证了程序的有序性。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。</strong>对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p><p><strong>JMM如何保证可见性？</strong></p><p>JMM中除了上面我们说到的<strong>volatile</strong>能够保证可见性之外，还有两个关键词也能保证可见性，这两个关键词就是<strong>synchronized</strong>和<strong>final</strong>关键词，其中synchronized关键词是根据<strong>对一个变量进行unlock之前必须先把该变量刷新到主存中</strong>，<strong>final保证可见性是指，final修饰的字段在构造器中初始化完成后其他线程就能看到被final修饰的值</strong></p><h3 id="Volatile如何禁止指令重排列的？"><a href="#Volatile如何禁止指令重排列的？" class="headerlink" title="Volatile如何禁止指令重排列的？"></a>Volatile如何禁止指令重排列的？</h3><p>Volatile的可见性和有序性是由Java虚拟机的<strong>内存屏障</strong>来实现的，那么什么是内存屏障呢？</p><p>内存屏障：</p><p><strong>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<code>有序性</code>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<code>可见性</code>。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Store1;<br>Store2;<br>Load1;<br>StoreLoad;  <span class="hljs-comment">//内存屏障</span><br>Store3;<br>Load2;<br>Load3;<br></code></pre></td></tr></table></figure><p>对于上面的一组 CPU 指令（Store表示写入指令，Load表示读取指令），StoreLoad 屏障之前的 Store 指令无法与StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p><p>常见的 4 种屏障</p><ul><li><strong>LoadLoad</strong> 屏障：对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore</strong> 屏障：对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore</strong> 屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad</strong> 屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为<strong>全能屏障</strong>，兼具其它三种内存屏障的功能。</li></ul><h3 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p><ul><li><strong>单线程下的 happens-before</strong> 字节码的先后顺序天然包含happens-before关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</li><li><strong>多线程下的 happens-before</strong> 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程1更新执行操作A共享变量的值之后，线程2开始执行操作B，此时操作A产生的结果对操作B不一定可见。</li></ul><p>﻿为了让我们程序员更好的开发程序，Java模型实现了下面几种先行发生关系：</p><ol><li><strong>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</strong></li><li><strong>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</strong></li><li><strong>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</strong></li><li><strong>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</strong></li><li><strong>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</strong></li><li><strong>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</strong></li><li><strong>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</strong></li><li><strong>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</strong></li></ol><p><strong>程序次序规则</strong>：一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。</p><p><strong>锁定规则</strong>：这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p><p><strong>volatile变量规则</strong>：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p><p><strong>传递规则</strong>：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p><p><strong>线程启动规则</strong>：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p><p><strong>线程终结规则</strong>：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA集合框架结构</title>
    <link href="/2020/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合框架结构"><a href="#JAVA集合框架结构" class="headerlink" title="JAVA集合框架结构"></a>JAVA集合框架结构</h1><p>首先我们知道JAVA的集合框架中有两大体系，一类是<code>Collection</code>，另一类是<code>Map</code>。其中Collection中包含<code>List</code>(ArrayList、LinkedList、<code>Vector</code>、还有继承自Vector的Stack)、<code>Set</code>(HashSet、LinkedHashSet、继承自Set的SortedSet接口下的TreeSet)、<code>Queue</code>(继承自Queue的Deque双向队列)。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources/files/1601456033018-1601456033008.png"></p><p>Map下包括HashMap、LinkedHashMap、(继承自Map的SortedMap接口，以及其实现类TreeMap)、Hashtable等实现类。下面就一个一个来进行解析。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/4c0ea9d4d39c4ab09ed7e81ac76993d1.jpg" alt="img"></p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List接口下有<code>ArrayList</code>、<code>LinkedList</code>（LinkedList是实现了List接口和Deque接口的类）、<code>Vector</code>、<code>Stack</code></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 是一个动态数组结构，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低。</p><p>ArrayList是我们平时使用的比较多的一个数据结构了，其底层实现为Array数组，我们看看他的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// 存储数据的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//容器当前的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//默认大小</span><br><span class="hljs-comment">//带初始化容量的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//无参构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><span class="hljs-comment">//实现Collection接口的子类的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到其如果进行无参构造的话，那么会得到一个DEFAULT_CAPACITY&#x3D;10的ArrayList，如果有指定初始容量，且大小合规的话，那么就创建初始化大小的ArrayList，如果参数是实现了Collection接口的，那么就调用Collection接口下的toArray()方法，将其变成数组，然使用Arrays.copyof()方法将原来容器内的元素拷贝到当前ArrayList下。</p><p>需要注意的是其大小达到其容量的时候会触发grow()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其扩容后的容量为int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);即新容量&#x3D;旧容量*1.5；</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是一个双向链表结构，在任意位置插入删除都很方便，但是不支持随机取值，每次都只能从一端开始遍历，直到找到查询的对象，然后返回；不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-comment">//看到first和last</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//内部类节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//包含两个构造函数</span><br><span class="hljs-comment">//第一个什么都没干，就是初始化了成员变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-comment">//第二个就是将继承自Collection接口的元素一个一个链接起来</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面看一下其add方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//调用了linkLast方法将其元素链接到尾节点中</span><br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">//在构造方法中将前驱指针置为当前last元素，后记节点置为Null;</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//last节点</span><br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector 也是一个动态数组结构，一个元老级别的类，早在 jdk1.1 就引入进来类，之后在 jdk1.2 里引进 ArrayList，ArrayList 大部分的方法和 Vector 比较相似，两者是不同的，Vector 是允许同步访问的，Vector 中的操作是线程安全的，但是效率低，而 ArrayList 所有的操作都是异步的，执行效率高，但不安全！需要注意的是Vector和ArrayList的扩容方式有所区别，Vector的扩容是新容量&#x3D;旧容量*2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                     capacityIncrement : oldCapacity);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>Vector</code>，现在用的很少了，因为里面的<code>get</code>、<code>set</code>、<code>add</code>等方法都加了<code>synchronized</code>，所以，执行效率会比较低，如果需要在多线程中使用，可以采用下面语句创建 ArrayList 对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">List&lt;<span class="hljs-built_in">Object</span>&gt; list =Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">Object</span>&gt;()); <br></code></pre></td></tr></table></figure><p>也可以考虑使用复制容器 <code>java.util.concurrent.CopyOnWriteArrayList</code>进行操作，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;<span class="hljs-built_in">Object</span>&gt; cowList = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;<span class="hljs-built_in">String</span>&gt;(<span class="hljs-built_in">Object</span>); <br></code></pre></td></tr></table></figure><p>其底层代码和ArrayList基本相同，不同点在于其对数组的操作都加入了<code>synchronized</code>关键词，所以保证了其再多线程条件下也是可以保证其线程的安全性的，但是由于使用了<code>sychronized</code>关键词，所以导致其效率不太行。所以一般推荐使用<code>Collections.synchronizedList</code>进行操作，是因为<code>Vector</code>读写性能可以和<code>Collections.synchronizedList</code>比肩(因为虽然一个是是在方法上进行加锁，另一个是在同步代码块内加锁，但是其锁住的范围几乎相同)，但<code>Collections.synchronizedList</code>不仅可以包装<code>ArrayList</code>,也可以包装其他List,扩展性和兼容性更好。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 是 Vector 的一个子类，本质也是一个动态数组结构，不同的是，它的数据结构是先进后出，取名叫栈！</p><p>关于<code>Stack</code>，现在用的也很少，因为有个<code>ArrayDeque</code>双端队列，可以替代<code>Stack</code>所有的功能，并且执行效率比它高！</p><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>说到HashSet，那就不得不说HashMap，HashSet底层是基于 HashMap 的<code>k</code>实现的，元素不可重复，特性同 HashMap。</p><p>具体的实现与HashMap不同的是，其value是固定的一个Object对象。</p><p>我们可以查看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">//内置的HashMap对象。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br></code></pre></td></tr></table></figure><p>每次进行add操作的时候都是执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//Put一个固定的元素。</span><br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其他的部分和HashMap基本相同，如果对HashMap不熟悉的话可以看后面关于HashMap的详细解析。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet底层也是基于 LinkedHashMap 的<code>k</code>实现的，一样元素不可重复，特性同 LinkedHashMap。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><p>我们看一下他的源码，发现其方法都是用了父类<code>HashSet</code>的方法，然后其父类也是基本使用HashMap实现的，所以LinkedHashMap还是和HashMap有着千丝万缕的关系，当然和LinkedHashMap有着更近的关系，我们看他的构造函数，发现其使用的构造函数还是LinkedHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br></code></pre></td></tr></table></figure><p>再看看他的类图是不是和HashMap很像呢？</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/image-20201001115529209.png" alt="image-20201001115529209"></p><p>类的方法也基本上只有构造函数，连重写都没有，真的美滋滋。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/image-20201001114833512.png" alt="image-20201001114833512"></p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet也是对<code>NavigableSe</code>t的继承，在NavigableSet顾名思义是一导航的接口，它定义了方法 lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null，通过这个导航类来实现排序的功能。</p><p>其底层是根据红黑树来进行实现的，具体关于红黑树的讲解参考：**<a href="https://zhuanlan.zhihu.com/p/79980618">https://zhuanlan.zhihu.com/p/79980618</a>**</p><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h2><p>Queue是一个队列集合，队列通常是指“先进先出”（FIFO）的容器。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>ArrayQueue是一个基于数组实现的双端队列，可以想象，在队列中存在两个指针，一个指向头部，一个指向尾部，因此它具有“FIFO队列”及“栈”的方法特性。</p><p>其具体的实现是一个数组，其扩容方法是将容量扩大为原来的两倍，即新容量&#x3D;旧容量&lt;&lt;1;</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue也是一个队列的实现类，此实现类中存储的元素排列并不是按照元素添加的顺序进行排列，而是内部会按元素的大小顺序进行排列，是一种能够自动排序的队列。</p><h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是List接口的实现类，也是Deque的实现类，底层是一种双向链表的数据结构，LinkedList可以根据索引来获取元素，增加或删除元素的效率较高，如果查找的话需要遍历整合集合，效率较低，LinkedList同时实现了stack、Queue、PriorityQueue的所有功能。</p><p>我们看看他的构造函数：</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/image-20201001171730235.png" alt="image-20201001171730235"></p><p>内部实现是使用数组，构造函数将上面集中接口初始化的方式都涵盖了。</p><h4 id="重要的几个方法"><a href="#重要的几个方法" class="headerlink" title="重要的几个方法"></a>重要的几个方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//第一个则不排序</span><br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//排序</span><br>        siftUp(i, e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> queue.length;<br>    <span class="hljs-comment">// Double size if small; else grow by 50%</span><br>    <span class="hljs-comment">//看到奇怪的的扩容方法，如果容量小于64的话，那么每次新容量=旧容量*2+2否则新容量=旧容量*1.5</span><br>    <span class="hljs-comment">//且其初始容量是奇怪的11 private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="hljs-number">64</span>) ?<br>                                     (oldCapacity + <span class="hljs-number">2</span>) :<br>                                     (oldCapacity &gt;&gt; <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 防止整数溢出</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">//扩容，增加需要的元素的内存大小。</span><br>    queue = Arrays.copyOf(queue, newCapacity);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//如果指定了比较器用比较器进行排序</span><br>        siftUpUsingComparator(k, x);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则使用Comparable接口的方法排序</span><br>        siftUpComparable(k, x);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    Comparable&lt;? <span class="hljs-built_in">super</span> E&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> E&gt;) x;<br>    <span class="hljs-comment">//二分查找后插入</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo((E) e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = key;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a>Map（映射）</h1><h2 id="Map（映射）-1"><a href="#Map（映射）-1" class="headerlink" title="Map（映射）"></a>Map（映射）</h2><p>Map是一个双列集合，其中保存的是键值对，键要求保持唯一性，值可以重复。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是使用数组和单链表（在JDK1.8红黑树）组成的数据结构，因为使用的是哈希表存储元素，所以输入的数据与输出的数据，顺序基本不一致，另外，HashMap最多只允许一条记录的 key 为 null。</p><p>HashMap应该是我们日常开发中使用的最多的一个工具类，本人的话就经常用它来传递JSON数据给前端。</p><p>说到HashMap的历史，<strong>在JDK1.7中，HashMap是使用Entry进行对节点的存储，而JDK1.8，中使用Node和TreeNode静态内部类进行数据的存储。JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</strong></p><p>初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-comment">//默认容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-comment">//无参构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><span class="hljs-comment">//初始化构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">//默认容量及加载因子</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                               initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                               loadFactor);<br>        <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h4><h5 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>看到put方法调用了putval方法，去看看</p><h5 id="Putval"><a href="#Putval" class="headerlink" title="Putval"></a>Putval</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.put and related methods.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to put</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> previous value, or null if none</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; <br>    Node&lt;K,V&gt; p;<br>    <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">//初始化tab，这里我们看看resize方法。</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//n是新的Node数组的长度</span><br>        n = (tab = resize()).length;<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//哈希值和(n-1)做&amp;，即011111这种形式，避免数组越界，且得到的下标为null，直接插入</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//否则就是出现了哈希值的碰撞，这个时候就要考虑是进行链表插入还是红黑树的插入</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//如果插入的元素的hash与传入的hash一样（即发生hash碰撞）且两个对象的key一样，把p赋值给e</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">//否则两个对象的key并不相同且发生hash碰撞，且p是红黑树类型的Node</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">//那么就把这个元素加入到红黑树中，然后复制给e，这个e是红黑树类型的Node</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">//否则两个对象的key并不相同且发生hash碰撞，且p不是红黑树类型的Node（TreeNode）-现在已经发生hash碰撞，且没有达到转换成红黑树的临界条件</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">//找到链表最后的节点</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//可以看到 TREEIFY_THRESHOLD 的值为8，即当链表长度大于等于8的时候使用treeifyBin方法，将链表变成红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">//如果大于8个节点，那么就转成红黑树，-》转换成红黑树的方法</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到新的Node数组方法</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//旧容量已经达到Integer.MAX_VALUE，就不扩容了，自生自灭好吧。</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//旧容量*2之后如果小于Integer.MAX_VALUE且旧容量&gt;默认容量16</span><br>        <span class="hljs-comment">//那么容量=容量*2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        <span class="hljs-comment">// 如果还没初始化呢，那么就算一下</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">//重新计算hash值和容量-1的&amp;</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">//MIN_TREEIFY_CAPACITY=64;</span><br>    <span class="hljs-comment">//如果当前哈希表为空，或者哈希表中元素的个数小于进行树形化的阈值(默认为 64)，就去新建/扩容</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>扩容流程对比图</strong></p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20180905105129591" alt="这里写图片描述" style="zoom: 67%;" /><h5 id="几个注意的问题："><a href="#几个注意的问题：" class="headerlink" title="几个注意的问题："></a>几个注意的问题：</h5><p>HashMap在什么情况下灰扩容呢?</p><ul><li><strong>当<code>map</code>中包含的<code>Entry</code>的数量大于等于<code>threshold = loadFactor * capacity</code>的时候，且新建的<code>Entry</code>刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍。</strong></li></ul><p><strong>最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</strong></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>HashMap 的子类，内部使用链表数据结构来记录插入的顺序，使得输入的记录顺序和输出的记录顺序是相同的。<strong>LinkedHashMap与HashMap最大的不同处在于，LinkedHashMap输入的记录和输出的记录顺序是相同的！</strong></p><p>LinkedHashMap实现和HashMap最大的区别在于：</p><ul><li>记录节点Entry的结构不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 <strong>before</strong> 和 <strong>after</strong>，它们分别用于维护双向链接列表。特别需要注意的是，<strong>next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kklll/Resources@master/files/20170512160734275"></p><p>LinkedHashMap的put方法还是使用的HashMap的put方法，并没有进行重写。但是重写了构建新节点的<code>newNode()</code>方法，这个方法会在putVal()方法中被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt; <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; p =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);<br>    linkNodeLast(p);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkNodeLast</span><span class="hljs-params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; last = tail;<br>    tail = p;<br>    <span class="hljs-comment">//如果此时加入的元素是第一个元素</span><br>    <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>        head = p;<br>    <span class="hljs-comment">//否则进行链表的链接</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        p.before = last;<br>        last.after = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedHashMap比较重要的一点就是其重写了三个回调函数：<code>afterNodeRemoval</code> <code>afterNodeInsertion</code>  <code>afterNodeAccess</code> 这三个回调函数在特定的操作发生后被调用，通过这三个回调函数维持其<code>有序性</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> &#123; <span class="hljs-comment">// unlink</span><br>    <span class="hljs-comment">//元素e被除移之后</span><br>    <span class="hljs-comment">//b为前序节点（or null），a为后序节点（or null）</span><br>    LinkedHashMap.Entry&lt;K,V&gt; p =<br>        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>    <span class="hljs-comment">//将其与前后节点的链接删除</span><br>    p.before = p.after = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//如果前驱节点是null证明删除的是第一个节点，那么他的后继节点就是头节点了</span><br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>)<br>        head = a;<br>    <span class="hljs-comment">//否则前驱节点的下一个就是后继节点</span><br>    <span class="hljs-keyword">else</span><br>        b.after = a;<br>    <span class="hljs-comment">//同理</span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>)<br>        tail = b;<br>    <span class="hljs-keyword">else</span><br>        a.before = b;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-type">boolean</span> evict)</span> &#123; <span class="hljs-comment">// possibly remove eldest</span><br>    LinkedHashMap.Entry&lt;K,V&gt; first;<br>    <span class="hljs-comment">//evict一直为True，且不为空链表且removeEldestEntry(first))为TRUE的话，就删除first节点，因此可以用作LRU算法</span><br>    <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;<br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> first.key;<br>        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> &#123; <br>    LinkedHashMap.Entry&lt;K,V&gt; last;<br>    <span class="hljs-comment">//accessOrder是我们构造的时候确定的，下面就是将节点移动到链表的最后面。</span><br>    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>        LinkedHashMap.Entry&lt;K,V&gt; p =<br>            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>        p.after = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>)<br>            head = a;<br>        <span class="hljs-keyword">else</span><br>            b.after = a;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>)<br>            a.before = b;<br>        <span class="hljs-keyword">else</span><br>            last = b;<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>            head = p;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p.before = last;<br>            last.after = p;<br>        &#125;<br>        tail = p;<br>        ++modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这三个回调方法中的<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>方法与LRU缓存算法的形成密切相关，就能用作LRU算法，如下，是不是很easy?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(capacity,<span class="hljs-number">0.75f</span>,<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">this</span>.size=capacity;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span>&#123;<br>        <span class="hljs-keyword">return</span> size()&gt;<span class="hljs-built_in">this</span>.size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getOrDefault(key,-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//这个也可以不写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">super</span>.put(key,value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>Hashtable，一个元老级的类，键值不能为空，与HashMap不同的是，方法都加了<code>synchronized</code>同步锁，是线程安全的，但是效率上，没有HashMap快！</p><p>同时，HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，区别在于 HashMap 允许K和V为空，而HashTable不允许K和V为空，由于非线程安全，效率上可能高于 Hashtable。</p><p>如果需要在多线程环境下使用HashMap，可以使用如下的同步器来实现或者使用并发工具包中的<code>ConcurrentHashMap</code>类，但是建议使用<code>ConcurrentHashMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; map =Collections.synchronizedMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历时，得到的记录是排过序的；如需使用排序的映射，建议使用 TreeMap。TreeMap实际使用的比较少！</p><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a>Collection类</h3><ul><li><strong>addAll</strong>：向指定的集合c中加入特定的一些元素elements</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> T&gt; c, T… elements)</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="binarySearch：利用二分法在指定的集合中查找元素"><a href="#binarySearch：利用二分法在指定的集合中查找元素" class="headerlink" title="binarySearch：利用二分法在指定的集合中查找元素"></a>binarySearch：利用二分法在指定的集合中查找元素</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合元素T实现Comparable接口的方式，进行查询</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; list, T key)</span><br><br><span class="hljs-comment">//元素以外部实现Comparator接口的方式，进行查询</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List&lt;? extends T&gt; list, T key, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="sort：排序"><a href="#sort：排序" class="headerlink" title="sort：排序"></a>sort：排序</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合元素T实现Comparable接口的方式，进行排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span><br><br><span class="hljs-comment">//元素以外部实现Comparator接口的方式，进行排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="reverse：集合排列反转"><a href="#reverse：集合排列反转" class="headerlink" title="reverse：集合排列反转"></a>reverse：集合排列反转</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接反转集合的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(List&lt;?&gt; list)</span><br><br><span class="hljs-comment">//返回可以使集合反转的比较器Comparator</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">reverseOrder</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//集合的反转的反转，如果cmp不为null，返回cmp的反转的比较器，如果cmp为null，效果等同于第二个方法.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">reverseOrder</span><span class="hljs-params">(Comparator&lt;T&gt; cmp)</span><br></code></pre></td></tr></table></figure><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul><li><h5 id="asList：将一个数组转变成一个ArrayList"><a href="#asList：将一个数组转变成一个ArrayList" class="headerlink" title="asList：将一个数组转变成一个ArrayList"></a>asList：将一个数组转变成一个ArrayList</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>sort：对数组进行排序，适合byte,char,double,float,int,long,short等基本类型，还有Object类型</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数据类型，例子int类型数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span><br><br><span class="hljs-comment">//Object类型数组</span><br><span class="hljs-comment">//如果使用Comparable进行排序，Object需要实现Comparable</span><br><span class="hljs-comment">//如果使用Comparator进行排序，可以使用外部比较方法实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(T[] a, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Object[] a)</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="copyOf：数组拷贝，底层采用System-arrayCopy（native方法）实现。"><a href="#copyOf：数组拷贝，底层采用System-arrayCopy（native方法）实现。" class="headerlink" title="copyOf：数组拷贝，底层采用System.arrayCopy（native方法）实现。"></a>copyOf：数组拷贝，底层采用System.arrayCopy（native方法）实现。</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数据类型，例子int类型数组，newLength新数组长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength)<br><br><span class="hljs-comment">//T为泛型数组，newLength新数组长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-type">int</span> newLength)<br></code></pre></td></tr></table></figure><ul><li><strong>copyOfRange：数组拷贝，指定一定的范围，底层采用System.arrayCopy（native方法）实现。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数据类型，例子int类型数组，from：开始位置，to：结束位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOfRange(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)<br><br><span class="hljs-comment">//T为泛型数组，from：开始位置，to：结束位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)<br></code></pre></td></tr></table></figure><ul><li><h5 id="equals和deepEquals：判断两个数组的每一个对应的元素是否相等"><a href="#equals和deepEquals：判断两个数组的每一个对应的元素是否相等" class="headerlink" title="equals和deepEquals：判断两个数组的每一个对应的元素是否相等"></a>equals和deepEquals：判断两个数组的每一个对应的元素是否相等</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数据类型，例子int类型数组，a为原数组，a2为目标数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] a2)</span><br><br><span class="hljs-comment">//Object数组，a为原数组，a2为目标数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span><br>    <br><span class="hljs-comment">//主要针对一个数组中的元素还是数组的情况(多维数组比较)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deepEquals</span><span class="hljs-params">(Object[] a1, Object[] a2)</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="toString和deepToString：将数组转换成字符串，中间用逗号隔开"><a href="#toString和deepToString：将数组转换成字符串，中间用逗号隔开" class="headerlink" title="toString和deepToString：将数组转换成字符串，中间用逗号隔开"></a>toString和deepToString：将数组转换成字符串，中间用逗号隔开</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本数据类型，例子int类型数组，a为数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span><br><br><span class="hljs-comment">//Object数组，a为数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(Object[] a)</span><br></code></pre></td></tr></table></figure><h1 id="国庆和中秋终于在2020碰到一起了，国庆快乐！中秋快乐！努力吧少年！"><a href="#国庆和中秋终于在2020碰到一起了，国庆快乐！中秋快乐！努力吧少年！" class="headerlink" title="国庆和中秋终于在2020碰到一起了，国庆快乐！中秋快乐！努力吧少年！"></a>国庆和中秋终于在2020碰到一起了，国庆快乐！中秋快乐！努力吧少年！</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
